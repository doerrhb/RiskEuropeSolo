<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Risk Europe: Solo Companion</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap');
        :root {
            --parchment: #f7eed8; --parchment-dark: #eedfc0; --ink: #1e140a; --ink-light: #4a3020;
            --accent: #8b1a1a; --gold: #c8952a; --gold-light: #f0c060;
            --border: #6b4c2a; --border-light: #a07050;
            --p-orange: #f97316; --p-green: #4db847; --p-purple: #3b0764; --p-blue: #5bb8f5;
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: 'Crimson Text', Georgia, serif; background: #0d0a06; color: var(--ink);
               display: flex; flex-direction: column; align-items: center; padding: 8px; margin: 0; min-height: 100vh; }
        .screen { width: 100%; max-width: 680px; }
        .paper { background: var(--parchment); border: 3px solid var(--border); border-radius: 4px;
                 box-shadow: 0 0 40px rgba(0,0,0,0.8); position: relative; overflow: hidden; }
        .inner { padding: 18px; position: relative; z-index: 1; }

        /* WIZARD */
        .wizard-header { background: var(--ink); color: var(--gold-light); padding: 13px 18px;
                         font-family: 'Cinzel', serif; display: flex; justify-content: space-between; align-items: center; }
        .wh-title { font-size: 1em; font-weight: 700; letter-spacing: 0.05em; }
        .wh-step  { font-size: 0.78em; opacity: 0.7; }
        .progress-bar { height: 4px; background: rgba(200,149,42,0.2); }
        .progress-fill { height: 100%; background: var(--gold); transition: width 0.4s; }
        .setup-title { font-family: 'Cinzel', serif; font-size: 1.35em; font-weight: 700; color: var(--accent);
                       text-align: center; margin: 0 0 6px; }
        .setup-sub { text-align: center; color: var(--ink-light); font-size: 0.93em; margin: 0 0 18px; line-height: 1.55; }
        .color-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 18px; }
        .color-choice { border-radius: 10px; padding: 18px 10px; text-align: center; cursor: pointer;
                        border: 3px solid transparent; transition: all 0.2s; color: white;
                        font-family: 'Cinzel', serif; font-weight: 700; font-size: 1em; letter-spacing: 0.06em; }
        .color-choice.selected { border-color: white; box-shadow: 0 0 0 3px var(--ink); transform: scale(1.04); }
        .color-choice:active { transform: scale(0.97); }
        .capital-card { background: rgba(255,252,245,0.92); border: 2px solid var(--border-light);
                        border-radius: 8px; padding: 12px 14px; margin-bottom: 10px; }
        .cap-header { display: flex; align-items: center; gap: 10px; margin-bottom: 7px; }
        .cap-dot { width: 15px; height: 15px; border-radius: 50%; flex-shrink: 0; border: 2px solid rgba(0,0,0,0.2); }
        .cap-name { font-family: 'Cinzel', serif; font-weight: 700; font-size: 0.95em; color: var(--accent); }
        .cap-body { font-size: 0.87em; line-height: 1.7; }
        .cap-note { font-style: italic; color: var(--ink-light); font-size: 0.85em; margin-top: 3px; }
        .cap-chooser { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 10px 0; }
        .cap-btn { background: rgba(255,252,245,0.92); border: 2px solid var(--border-light); border-radius: 8px;
                   padding: 12px 8px; text-align: center; cursor: pointer; transition: all 0.15s;
                   font-family: 'Cinzel', serif; font-weight: 700; font-size: 0.88em; color: var(--ink); }
        .cap-btn:active { transform: scale(0.97); }
        .cap-btn.selected { border-color: var(--accent); background: rgba(139,26,26,0.07); color: var(--accent); }
        .cap-btn .cap-tax { font-size: 0.75em; color: var(--ink-light); font-family: 'Crimson Text',serif; font-weight:400; margin-top:3px; }
        .info-box { background: rgba(200,149,42,0.1); border-left: 3px solid var(--gold);
                    padding: 10px 14px; border-radius: 0 6px 6px 0; font-size: 0.87em;
                    line-height: 1.6; margin: 10px 0; }

        /* GAME HEADER */
        .game-header { background: var(--ink); color: var(--gold-light); padding: 10px 16px;
                       font-family: 'Cinzel', serif; display: flex; justify-content: space-between; align-items: center;
                       border-bottom: 3px solid var(--gold); }
        .save-btn { background:none; border:1px solid rgba(200,149,42,0.5); color:var(--gold-light); border-radius:5px;
                    font-family:'Cinzel',serif; font-size:0.65em; padding:4px 8px; cursor:pointer; letter-spacing:0.04em; }
        .save-btn:hover { background:rgba(200,149,42,0.15); }
        /* Save/Load overlay */
        .saveload-overlay { position:fixed;inset:0;background:rgba(0,0,0,0.65);z-index:9100;display:flex;align-items:center;justify-content:center; }
        .saveload-modal { background:var(--parchment);border-radius:12px;width:min(96vw,420px);padding:20px;box-shadow:0 8px 40px rgba(0,0,0,0.5); }
        .saveload-modal h3 { font-family:'Cinzel',serif;margin:0 0 14px;color:var(--ink);font-size:1em; }
        .save-slot { display:flex;align-items:center;justify-content:space-between;padding:10px 12px;background:#fff;
                     border:1px solid var(--border-light);border-radius:8px;margin-bottom:8px; }
        .save-slot-info { font-size:0.82em;color:var(--ink); }
        .save-slot-info .slot-name { font-family:'Cinzel',serif;font-weight:700;font-size:0.95em; }
        .save-slot-info .slot-meta { color:var(--ink-light);font-size:0.85em;margin-top:2px; }
        .save-slot-btns { display:flex;gap:6px; }
        .sl-btn { font-size:0.75em;padding:5px 10px;border-radius:5px;border:none;cursor:pointer;font-family:'Cinzel',serif;font-weight:700; }
        .sl-btn.save  { background:var(--gold);color:#1a1208; }
        .sl-btn.load  { background:var(--ink);color:var(--gold-light); }
        .sl-btn.del   { background:#8b1a1a;color:#fff; }
        .sl-btn:disabled { opacity:0.35;cursor:not-allowed; }
        .sl-export { margin-top:12px;padding-top:12px;border-top:1px solid var(--border-light); }
        .sl-export textarea { width:100%;height:80px;font-size:0.7em;font-family:monospace;border:1px solid var(--border);border-radius:6px;padding:6px;box-sizing:border-box;resize:vertical; }
        .gh-round { font-size: 1.05em; font-weight: 700; }
        .gh-step  { font-size: 0.8em; opacity: 0.85; }
        .log-strip { background: #1a1208; border-bottom: 2px solid var(--border); padding: 5px 14px;
                     font-family: 'Courier New', monospace; font-size: 0.75em; min-height: 2.1em; }
        .log-entry { color: #d4a84b; }
        .log-entry.old { color: #7a6030; }

        /* PLAYER BAR */
        .players-bar { display: grid; grid-template-columns: repeat(4,1fr); border-bottom: 2px solid var(--border); padding-bottom: 18px; }
        .player-tile { padding: 9px 3px 7px; text-align: center; position: relative; border-right: 1px solid rgba(0,0,0,0.15); }
        .player-tile:last-child { border-right: none; }
        .player-tile.active { box-shadow: inset 0 0 0 3px rgba(255,255,255,0.9); z-index: 2; }
        .player-tile.active::after { content: '▼ ACTIVE'; position: absolute; bottom: -16px; left: 50%;
            transform: translateX(-50%); color: white; font-size: 7px; font-family: 'Cinzel',serif; font-weight: 700;
            letter-spacing: 0.05em; white-space: nowrap; background: var(--ink); padding: 1px 5px; border-radius: 3px; z-index: 10; }
        .p-name { font-family: 'Cinzel',serif; font-size: 0.7em; font-weight: 700; letter-spacing: 0.08em;
                  color: rgba(255,255,255,0.95); display: flex; align-items: center; justify-content: center; gap: 4px; }
        .crown-badge { font-size: 11px; cursor: pointer; padding: 1px 3px; border-radius: 3px; opacity: 0.35; line-height: 1; transition: 0.15s; }
        .player-tile.is-first .crown-badge { opacity: 1; filter: drop-shadow(0 0 4px silver); }
        .player-tile.is-saved { border-color: #b8860b; background: #fef9e7; }
        .player-tile.is-eliminated { opacity: 0.45; filter: grayscale(0.7); }
        .player-tile.is-pending .crown-badge { opacity: 1; filter: drop-shadow(0 0 6px #c0c0c0); animation: pulse 1s infinite; }
        @keyframes pulse { 0%,100%{transform:scale(1)}50%{transform:scale(1.3)} }
        .coin-row { display: flex; align-items: center; justify-content: center; gap: 5px; margin: 4px 0 3px; }
        .coin-count { font-family: 'Cinzel',serif; font-size: 1.28em; font-weight: 700; color: inherit; min-width: 24px; text-align: center; }
        .coin-btn { background: rgba(128,128,128,0.2); border: 1px solid rgba(0,0,0,0.2); color: inherit;
                    width: 22px; height: 22px; border-radius: 50%; cursor: pointer; font-size: 14px;
                    display: flex; align-items: center; justify-content: center; padding: 0; transition: background 0.1s; }
        .coin-btn:active { background: rgba(128,128,128,0.4); }
        .coin-threshold { font-size: 0.58em; font-weight: 700; padding: 2px 6px; border-radius: 8px;
                          color: white; letter-spacing: 0.05em; font-family: 'Cinzel',serif; }
        .mode-tax   { background: rgba(0,0,0,0.5); border: 1px solid rgba(255,100,100,0.7); }
        .mode-spend { background: rgba(0,0,0,0.5); border: 1px solid rgba(100,255,150,0.6); }
        .deck-pip { font-size: 0.58em; color: inherit; opacity: 0.55; font-family: 'Courier New',monospace; }

        /* ACTION AREA */
        .action-area { padding: 14px; }


        .action-card { display: block; background: #fffdf5; border: 3px solid var(--border); border-radius: 10px;
                       padding: 20px 20px 16px; font-family: 'Cinzel',serif; font-size: 1.2em; font-weight: 700;
                       color: var(--accent); letter-spacing: 0.04em; text-align: center; margin-bottom: 12px;
                       box-shadow: 0 4px 12px rgba(0,0,0,0.12); position: relative; }
        .action-card.revealed  { border-color: var(--accent); }
        .action-card.unrevealed{ color: #bbb; border-color: #ccc; }
        .card-sub { font-size: 0.58em; color: var(--ink-light); font-family: 'Crimson Text',serif; font-weight: 400; margin-top: 4px; }
        .human-banner { border: 3px dashed var(--player-color); border-radius: 10px; padding: 22px 16px;
                        text-align: center; background: rgba(26,95,168,0.06); margin-bottom: 12px; }
        .human-banner h2 { font-family: 'Cinzel',serif; color: var(--player-color); margin: 0 0 6px; font-size: 1.2em; }
        .human-banner p { margin: 0; color: var(--ink-light); font-size: 0.9em; line-height: 1.55; }

        /* STEPS */
        .steps-panel { background: rgba(255,252,245,0.95); border: 2px solid var(--border-light); border-radius: 8px; overflow: hidden; margin-bottom: 12px; }
        .steps-header { color: white; padding: 8px 14px; font-family: 'Cinzel',serif; font-size: 0.8em; font-weight: 700; letter-spacing: 0.06em; }
        .step-item { display: flex; gap: 11px; padding: 11px 14px; border-bottom: 1px solid rgba(0,0,0,0.07);
                     cursor: pointer; align-items: flex-start; transition: background 0.1s; }
        .step-item:last-child { border-bottom: none; }
        .step-item.checked { background: rgba(30,126,68,0.07); }
        .step-checkbox { width: 26px; height: 26px; border: 2px solid var(--border-light); border-radius: 6px;
                         flex-shrink: 0; display: flex; align-items: center; justify-content: center;
                         font-size: 15px; transition: all 0.15s; margin-top: 2px; }
        .step-item.checked .step-checkbox { background: var(--p-green); border-color: var(--p-green); color: white; }
        .step-num { font-family: 'Cinzel',serif; font-weight: 700; color: var(--gold); font-size: 0.8em; margin-top: 4px; flex-shrink: 0; }
        .step-text { font-size: 0.88em; line-height: 1.62; color: var(--ink); flex: 1; }
        .step-text b { color: var(--accent); }
        .if-tie { font-style: italic; color: var(--ink-light); display: block; margin-top: 2px; font-size: 0.92em; }
        .rule-note { display: block; margin-top: 5px; padding: 4px 8px; background: rgba(200,149,42,0.1);
                     border-left: 2px solid var(--gold); border-radius: 0 4px 4px 0; font-size: 0.9em; color: var(--ink-light); }
        .buy-highlight { display: block; font-family: 'Cinzel',serif; font-size: 0.95em; color: var(--accent); font-weight: 700; margin: 4px 0; }
        .steps-progress { background: rgba(0,0,0,0.08); height: 4px; }
        .steps-progress-fill { height: 100%; background: var(--p-green); transition: width 0.2s; }
        .step-divider {
            display: flex; align-items: center; gap: 10px;
            padding: 8px 14px; background: var(--ink); color: var(--gold-light);
            font-family: 'Cinzel',serif; font-size: 0.78em; font-weight: 700;
            letter-spacing: 0.07em; text-transform: uppercase;
        }
        .step-divider::before, .step-divider::after {
            content:''; flex:1; height:1px; background: rgba(240,192,96,0.35);
        }

        /* BUTTONS */
        .btn-primary { display: block; width: 100%; background: var(--accent); color: white; border: none;
                       border-radius: 8px; padding: 17px; font-family: 'Cinzel',serif; font-size: 1.02em;
                       font-weight: 700; letter-spacing: 0.06em; cursor: pointer;
                       box-shadow: 0 4px 0 #4a0a0a; transition: all 0.1s; margin-bottom: 10px; }
        .btn-primary:active { transform: translateY(2px); box-shadow: 0 2px 0 #4a0a0a; }
        .btn-advance { display: block; width: 100%; background: var(--ink); color: #e8d8b8; border: none;
                       border-radius: 8px; padding: 15px; font-family: 'Cinzel',serif; font-size: 0.95em;
                       font-weight: 600; letter-spacing: 0.05em; cursor: pointer;
                       box-shadow: 0 3px 0 #050301; transition: all 0.1s; margin-bottom: 10px; }
        .btn-advance:active { transform: translateY(2px); box-shadow: 0 1px 0 #050301; }
        .btn-advance:disabled { background: #555; cursor: not-allowed; opacity: 0.55; box-shadow: 0 3px 0 #222; }
        .btn-secondary { display: block; width: 100%; background: var(--parchment-dark); color: var(--ink);
                         border: 2px solid var(--border); border-radius: 8px; padding: 13px;
                         font-family: 'Cinzel',serif; font-size: 0.93em; font-weight: 600; cursor: pointer;
                         margin-bottom: 10px; transition: all 0.1s; }
        .btn-secondary:active { transform: scale(0.98); }
        .btn-reset { background: none; border: none; color: #999; font-size: 0.8em; cursor: pointer; padding: 8px; text-decoration: underline; display: block; margin: 4px auto 0; }

        /* REFERENCE */
        .ref-toggle { background: rgba(255,252,245,0.9); border: 1px solid var(--border-light); border-radius: 6px; margin-bottom: 8px; overflow: hidden; }
        .ref-toggle-btn { width: 100%; padding: 9px 14px; background: none; border: none; cursor: pointer;
                          display: flex; justify-content: space-between; align-items: center;
                          font-family: 'Cinzel',serif; font-size: 0.76em; font-weight: 700; letter-spacing: 0.06em;
                          color: var(--accent); text-transform: uppercase; text-align: left; }
        .ref-toggle-btn .arrow { transition: transform 0.2s; font-size: 0.9em; }
        .ref-toggle-btn.open .arrow { transform: rotate(180deg); }
        .ref-body { display: none; padding: 8px 14px 12px; font-size: 0.84em; line-height: 1.65; border-top: 1px solid var(--border-light); }
        .ref-body.open { display: block; }
        .ref-body table { width: 100%; border-collapse: collapse; margin-top: 6px; }
        .ref-body td, .ref-body th { padding: 3px 5px; border-bottom: 1px solid rgba(0,0,0,0.07); }
        .ref-body th { font-weight: 700; font-family: 'Cinzel',serif; font-size: 0.82em; color: var(--accent); }

        @media (max-width: 480px) {
            .inner { padding: 13px; }
            .cap-chooser { grid-template-columns: 1fr 1fr; }
        }
    
        /* BOARD EDITOR */
        .board-btn { position:fixed; bottom:16px; right:16px; z-index:100; background:var(--ink); color:var(--gold-light); border:2px solid var(--gold); border-radius:50px; padding:10px 18px; font-family:'Cinzel',serif; font-size:0.8em; font-weight:700; letter-spacing:0.06em; cursor:pointer; box-shadow:0 4px 12px rgba(0,0,0,0.5); }
        .board-overlay { display:none; position:fixed; top:0;left:0;right:0;bottom:0; background:rgba(0,0,0,0.7); z-index:200; overflow-y:auto; padding:8px; }
        .board-overlay.open { display:block; }
        .board-modal { background:var(--parchment); max-width:680px; margin:0 auto; border:3px solid var(--border); border-radius:6px; overflow:hidden; }
        .board-modal-header { background:var(--ink); color:var(--gold-light); padding:12px 16px; display:flex; justify-content:space-between; align-items:center; font-family:'Cinzel',serif; font-weight:700; font-size:0.95em; }
        .board-close { background:none; border:none; color:var(--gold-light); font-size:1.4em; cursor:pointer; padding:0 4px; }
        .board-content { padding:10px; max-height:75vh; overflow-y:auto; }
        /* Step 1 — territory list */
        .be-terr-list { margin:0; padding:0; list-style:none; }
        .be-terr-item { display:flex; align-items:center; justify-content:space-between; padding:13px 14px; border-bottom:1px solid rgba(0,0,0,0.07); cursor:pointer; transition:background 0.1s; }
        .be-terr-item:last-child { border-bottom:none; }
        .be-terr-item:active, .be-terr-item.sel { background:rgba(139,26,26,0.06); }
        .be-terr-item .bt-name { font-family:'Cinzel',serif; font-size:0.95em; font-weight:700; color:var(--ink); }
        .be-terr-item .bt-sub  { font-size:0.78em; color:var(--ink-light); margin-top:2px; }
        .be-terr-item .bt-badge { font-size:0.78em; color:var(--ink-light); text-align:right; }
        .be-terr-item .bt-badge b { font-family:'Cinzel',serif; color:var(--ink); }
        .be-terr-item .bt-arrow { color:var(--accent); font-size:1.1em; margin-left:8px; }
        /* Step 2 — move panel */
        .be-back-btn { display:flex; align-items:center; gap:6px; background:none; border:none; font-family:'Cinzel',serif; font-size:0.82em; color:var(--accent); cursor:pointer; padding:4px 0 10px; font-weight:700; letter-spacing:0.04em; }
        .be-from-banner { background:var(--ink); color:var(--gold-light); padding:10px 14px; border-radius:6px; margin-bottom:12px; }
        .be-from-banner .bfb-name { font-family:'Cinzel',serif; font-size:1em; font-weight:700; }
        .be-from-banner .bfb-units { font-size:0.82em; opacity:0.85; margin-top:2px; }
        .be-dest-label { font-family:'Cinzel',serif; font-size:0.72em; font-weight:700; letter-spacing:0.08em; color:var(--ink-light); text-transform:uppercase; margin-bottom:8px; }
        .be-dest-list { display:flex; flex-direction:column; gap:7px; margin-bottom:14px; }
        .be-dest-item { display:flex; align-items:center; gap:10px; padding:11px 14px; border:2px solid var(--border-light); border-radius:8px; cursor:pointer; background:#fffdf5; transition:all 0.12s; }
        .be-dest-item:active { opacity:0.8; }
        .be-dest-item.sel { border-color:var(--accent); background:rgba(139,26,26,0.05); }
        .be-dest-item.is-enemy { border-color:rgba(139,26,26,0.35); }
        .be-dest-item.is-friendly { border-color:rgba(30,126,68,0.35); }
        .be-dest-dot { width:13px; height:13px; border-radius:50%; flex-shrink:0; border:1px solid rgba(0,0,0,0.15); }
        .be-dest-info { flex:1; }
        .be-dest-name { font-family:'Cinzel',serif; font-size:0.92em; font-weight:700; color:var(--ink); }
        .be-dest-sub  { font-size:0.76em; color:var(--ink-light); margin-top:1px; }
        /* Count picker */
        .be-count-box { background:rgba(0,0,0,0.04); border-radius:8px; padding:12px 14px; }
        .be-count-label { font-size:0.82em; color:var(--ink-light); margin-bottom:10px; }
        .be-count-row { display:flex; align-items:center; gap:12px; }
        .be-cnt-btn { width:36px; height:36px; border-radius:7px; border:2px solid var(--border); background:var(--parchment-dark); font-size:20px; cursor:pointer; display:flex; align-items:center; justify-content:center; font-weight:700; }
        .be-cnt-val { font-family:'Cinzel',serif; font-size:1.5em; font-weight:700; min-width:36px; text-align:center; }
        .be-cnt-note { font-size:0.78em; color:var(--ink-light); }
        .be-confirm-btn { margin-top:12px; width:100%; background:var(--accent); color:white; border:none; border-radius:8px; padding:14px; font-family:'Cinzel',serif; font-size:0.95em; font-weight:700; cursor:pointer; }
        .be-confirm-btn:active { opacity:0.85; }
        .be-confirm-btn:disabled { background:#aaa; cursor:not-allowed; }
        /* Correction panel at bottom */
        .be-corrections { margin-top:14px; border-top:1px solid var(--border-light); padding-top:10px; }
        .be-corr-title { font-family:'Cinzel',serif; font-size:0.72em; font-weight:700; letter-spacing:0.08em; color:var(--ink-light); text-transform:uppercase; margin-bottom:8px; }
        .be-owner-row { display:flex; align-items:center; gap:6px; margin-bottom:6px; flex-wrap:wrap; }
        .be-owner-row span { font-size:0.8em; color:var(--ink-light); }
        .be-odot { width:18px; height:18px; border-radius:50%; cursor:pointer; border:2px solid transparent; transition:0.12s; flex-shrink:0; }
        .be-odot.sel { border-color:var(--ink); box-shadow:0 0 0 2px white; transform:scale(1.15); }
        .be-castle-btn { font-size:0.78em; padding:4px 9px; border:1px solid var(--border-light); border-radius:5px; background:var(--parchment-dark); cursor:pointer; font-family:'Cinzel',serif; }
        .be-castle-btn.on { background:rgba(200,149,42,0.15); border-color:var(--gold); color:#7a5a00; }
        /* Full board view */
        .fbs-section { margin-bottom:14px; }
        .fbs-section-hdr { display:flex; align-items:center; gap:8px; padding:7px 10px; border-radius:6px; font-family:'Cinzel',serif; font-size:0.78em; font-weight:700; letter-spacing:0.06em; color:white; margin-bottom:4px; }
        .fbs-row { display:grid; grid-template-columns:1fr 80px 110px; align-items:center; padding:6px 10px; border-bottom:1px solid rgba(0,0,0,0.05); font-size:0.83em; }
        .fbs-row:last-child { border-bottom:none; }
        .fbs-row .fr-name { font-family:'Cinzel',serif; font-weight:700; color:var(--ink); overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
        .fbs-row .fr-sub  { font-size:0.78em; color:var(--ink-light); text-align:center; }
        .fbs-row .fr-units { font-size:0.82em; color:var(--ink); text-align:right; white-space:nowrap; }
        .fbs-empty { color:var(--ink-light); font-style:italic; padding:6px 10px; font-size:0.82em; }
        .fbs-back-btn { display:flex; align-items:center; gap:5px; background:none; border:none; font-family:'Cinzel',serif; font-size:0.82em; color:var(--accent); cursor:pointer; padding:0 0 10px; font-weight:700; }
        .btn-full-board { width:100%; margin-top:10px; padding:11px; background:var(--ink); color:var(--gold-light); border:none; border-radius:7px; font-family:'Cinzel',serif; font-size:0.82em; font-weight:700; cursor:pointer; letter-spacing:0.04em; }
        .btn-full-board:active { opacity:0.85; }
                .ub { background:rgba(0,0,0,0.08); border:1px solid rgba(0,0,0,0.15); border-radius:3px; width:20px; height:20px; cursor:pointer; font-size:12px; display:flex; align-items:center; justify-content:center; }
        .be-terr-item.be-moved { opacity:0.45; background:rgba(0,0,0,0.04); cursor:default; }
        .be-terr-item.be-moved .bt-name { text-decoration: line-through; }
        /* Unit type steppers */
        .unit-type-grid { display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:10px; }
        .unit-type-row { display:flex; align-items:center; justify-content:space-between; background:#fff; border:1px solid var(--border-light); border-radius:7px; padding:8px 10px; }
        .unit-type-row.zero { opacity:0.4; }
        .ut-label { font-family:'Cinzel',serif; font-size:0.82em; font-weight:700; color:var(--ink); }
        .ut-avail { font-size:0.72em; color:var(--ink-light); }
        .ut-stepper { display:flex; align-items:center; gap:6px; }
        .ut-btn { width:26px; height:26px; border-radius:5px; border:1px solid var(--border); background:var(--parchment-dark); font-size:15px; cursor:pointer; display:flex; align-items:center; justify-content:center; font-weight:700; }
        .ut-btn:disabled { opacity:0.3; cursor:not-allowed; }
        .ut-val { font-family:'Cinzel',serif; font-size:1em; font-weight:700; min-width:20px; text-align:center; }



        /* ---- COMBAT MODAL ---- */
        .combat-overlay {
            display:none; position:fixed; top:0;left:0;right:0;bottom:0;
            background:rgba(0,0,0,0.85); z-index:300; overflow-y:auto; padding:8px;
        }
        .combat-overlay.open { display:block; }
        .combat-modal {
            background:var(--parchment); max-width:680px; margin:0 auto;
            border:3px solid var(--accent); border-radius:6px; overflow:hidden;
            box-shadow: 0 0 40px rgba(200,0,0,0.4);
        }
        .combat-header {
            background:var(--accent); color:white; padding:12px 16px;
            font-family:'Cinzel',serif; font-weight:700; font-size:1em;
            display:flex; justify-content:space-between; align-items:center;
        }
        .combat-phase-badge {
            background:rgba(255,255,255,0.2); border-radius:20px;
            padding:3px 10px; font-size:0.75em; letter-spacing:0.06em;
        }
        .combat-body { padding:14px; }
        .combat-territory-row {
            display:flex; align-items:center; justify-content:space-between;
            gap:8px; margin-bottom:14px;
        }
        .combat-side {
            flex:1; border-radius:8px; padding:10px 12px; color:white; text-align:center;
        }
        .combat-side .side-label { font-family:'Cinzel',serif; font-size:0.72em; font-weight:700; letter-spacing:0.08em; opacity:0.85; }
        .combat-side .side-name  { font-family:'Cinzel',serif; font-size:1em; font-weight:700; margin:3px 0; }
        .combat-side .side-units { font-size:0.82em; margin-top:4px; opacity:0.9; }
        .combat-vs { font-family:'Cinzel',serif; font-size:1.3em; font-weight:700; color:var(--accent); flex-shrink:0; }
        .combat-side.neutral-side { background:#777; }

        /* Dice display */
        .dice-section {
            background:rgba(255,252,245,0.9); border:1px solid var(--border-light);
            border-radius:8px; padding:12px; margin-bottom:10px;
        }
        .dice-section h5 {
            font-family:'Cinzel',serif; font-size:0.78em; font-weight:700;
            color:var(--accent); text-transform:uppercase; letter-spacing:0.06em;
            margin:0 0 10px; border-bottom:1px solid rgba(139,26,26,0.15); padding-bottom:6px;
        }
        .dice-row { display:flex; flex-wrap:wrap; gap:6px; margin-bottom:8px; align-items:center; }
        .die-face {
            width:36px; height:36px; border-radius:6px; display:flex; align-items:center;
            justify-content:center; font-size:1.6em; border:2px solid rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        .die-face.hit   { background:#1e7e44; border-color:#155330; }
        .die-face.miss  { background:#ddd;    border-color:#bbb; }
        .die-face.rolling { animation: diceRoll 0.3s ease; }
        @keyframes diceRoll { 0%{transform:rotate(0) scale(1)} 50%{transform:rotate(180deg) scale(1.2)} 100%{transform:rotate(360deg) scale(1)} }
        .dice-label { font-size:0.82em; color:var(--ink-light); font-style:italic; }
        .hit-count { font-family:'Cinzel',serif; font-weight:700; font-size:1.05em; }
        .hit-count.has-hits { color:#1e7e44; }
        .hit-count.no-hits  { color:#aaa; }

        /* Human input */
        .human-roll-box {
            background:rgba(26,95,168,0.07); border:2px solid var(--p-blue);
            border-radius:8px; padding:12px 14px; margin-bottom:10px;
        }
        .human-roll-box h5 { font-family:'Cinzel',serif; font-size:0.82em; font-weight:700;
            color:var(--p-blue); margin:0 0 10px; }
        .dice-count-big { font-family:'Cinzel',serif; font-size:1.4em; font-weight:700;
            color:var(--p-blue); }
        .hit-input-row { display:flex; align-items:center; gap:10px; margin-top:10px; flex-wrap:wrap; }
        .hit-stepper { display:flex; align-items:center; gap:8px; }
        .hit-stepper .hs-btn { width:32px; height:32px; border-radius:6px; border:2px solid var(--border);
            background:var(--parchment-dark); font-size:18px; cursor:pointer; display:flex;
            align-items:center; justify-content:center; font-weight:700; }
        .hit-stepper .hs-val { font-family:'Cinzel',serif; font-size:1.4em; font-weight:700;
            min-width:32px; text-align:center; }

        /* Casualty report */
        .casualty-box {
            background:rgba(139,26,26,0.06); border-left:3px solid var(--accent);
            border-radius:0 6px 6px 0; padding:10px 14px; margin-bottom:10px;
            font-size:0.88em; line-height:1.7;
        }
        .casualty-box b { color:var(--accent); }
        .remove-instruction { font-weight:600; color:var(--accent); }

        /* Round history */
        .round-history { max-height:120px; overflow-y:auto; margin-bottom:10px; }
        .round-entry { font-size:0.8em; color:var(--ink-light); padding:3px 0;
            border-bottom:1px dotted #ddd; font-family:'Courier New',monospace; }
        .round-entry:last-child { border-bottom:none; }
        .round-entry.attacker-win { color:#1e7e44; }
        .round-entry.defender-win { color:var(--accent); }

        /* Auto-combat log */
        .auto-combat-log { background:#1a1208; border-radius:6px; padding:10px 14px;
            font-family:'Courier New',monospace; font-size:0.8em; max-height:200px;
            overflow-y:auto; margin-bottom:12px; }
        .acl-line { color:#d4a84b; padding:2px 0; border-bottom:1px solid rgba(255,255,255,0.05); }
        .acl-line.hit  { color:#4db847; }
        .acl-line.loss { color:#e8192c; }
        .acl-line.end  { color:#f0c060; font-weight:bold; border-top:1px solid rgba(240,192,96,0.3); margin-top:4px; padding-top:4px; }

        /* Combat action buttons */
        .combat-btn-row { display:flex; gap:10px; margin-top:10px; }
        .btn-combat-primary {
            flex:2; background:var(--accent); color:white; border:none; border-radius:8px;
            padding:15px; font-family:'Cinzel',serif; font-size:0.95em; font-weight:700;
            cursor:pointer; box-shadow:0 3px 0 #4a0a0a; transition:all 0.1s;
        }
        .btn-combat-primary:active { transform:translateY(2px); box-shadow:0 1px 0 #4a0a0a; }
        .btn-combat-primary:disabled { background:#aaa; box-shadow:0 3px 0 #666; cursor:not-allowed; }
        .btn-combat-retreat {
            flex:1; background:var(--ink); color:#e8d8b8; border:none; border-radius:8px;
            padding:15px; font-family:'Cinzel',serif; font-size:0.85em; font-weight:600;
            cursor:pointer; box-shadow:0 3px 0 #050301; transition:all 0.1s;
        }
        .btn-combat-retreat:active { transform:translateY(2px); }
        .combat-result-banner {
            text-align:center; padding:16px; border-radius:8px; margin-bottom:12px;
            font-family:'Cinzel',serif; font-size:1.1em; font-weight:700;
        }
        .combat-result-banner.win  { background:rgba(30,126,68,0.15); color:#1e7e44; border:2px solid #1e7e44; }
        .combat-result-banner.loss { background:rgba(139,26,26,0.12); color:var(--accent); border:2px solid var(--accent); }
        .combat-result-banner.draw { background:rgba(200,149,42,0.15); color:var(--gold); border:2px solid var(--gold); }

        
        /* ===== COMBAT MODAL ===== */
        .combat-overlay{display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.87);z-index:300;overflow-y:auto;padding:8px;}
        .combat-overlay.open{display:block;}
        .combat-modal{background:var(--parchment);max-width:680px;margin:0 auto;border:3px solid var(--accent);border-radius:6px;overflow:hidden;box-shadow:0 0 40px rgba(200,0,0,0.4);}
        .combat-header{background:var(--accent);color:white;padding:12px 16px;font-family:'Cinzel',serif;font-weight:700;font-size:1em;display:flex;justify-content:space-between;align-items:center;}
        .combat-phase-badge{background:rgba(255,255,255,0.2);border-radius:20px;padding:3px 10px;font-size:0.75em;letter-spacing:0.06em;}
        .combat-body{padding:14px;}
        .combat-sides-row{display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:14px;}
        .combat-side{flex:1;border-radius:8px;padding:10px 12px;text-align:center;}
        .combat-side .sl{font-family:'Cinzel',serif;font-size:0.68em;font-weight:700;letter-spacing:0.08em;opacity:0.82;}
        .combat-side .sn{font-family:'Cinzel',serif;font-size:0.95em;font-weight:700;margin:3px 0;}
        .combat-side .su{font-size:0.8em;margin-top:3px;opacity:0.9;}
        .combat-vs{font-family:'Cinzel',serif;font-size:1.3em;font-weight:700;color:var(--accent);flex-shrink:0;}
        .dice-section{background:rgba(255,252,245,0.9);border:1px solid var(--border-light);border-radius:8px;padding:11px;margin-bottom:10px;}
        .dice-section h5{font-family:'Cinzel',serif;font-size:0.76em;font-weight:700;color:var(--accent);text-transform:uppercase;letter-spacing:0.06em;margin:0 0 9px;border-bottom:1px solid rgba(139,26,26,0.15);padding-bottom:5px;}
        .dice-row{display:flex;flex-wrap:wrap;gap:5px;align-items:center;margin-bottom:5px;}
        .die-face{width:34px;height:34px;border-radius:6px;display:flex;align-items:center;justify-content:center;font-size:1.5em;border:2px solid rgba(0,0,0,0.18);}
        .die-face.hit{background:#1e7e44;border-color:#155330;}
        .die-face.miss{background:#ddd;border-color:#bbb;}
        .hits-summary{font-family:'Cinzel',serif;font-size:0.9em;font-weight:700;}
        .hits-summary.some{color:#1e7e44;}
        .hits-summary.none{color:#999;}
        .human-roll-box{background:rgba(26,95,168,0.07);border:2px solid var(--p-blue);border-radius:8px;padding:12px 14px;margin-bottom:10px;}
        .human-roll-box h5{font-family:'Cinzel',serif;font-size:0.8em;font-weight:700;color:var(--p-blue);margin:0 0 8px;}
        .dice-count-big{font-family:'Cinzel',serif;font-size:1.4em;font-weight:700;color:var(--p-blue);}
        .hit-input-row{display:flex;align-items:center;gap:10px;margin-top:10px;flex-wrap:wrap;}
        .hs-btn{width:32px;height:32px;border-radius:6px;border:2px solid var(--border);background:var(--parchment-dark);font-size:18px;cursor:pointer;display:flex;align-items:center;justify-content:center;font-weight:700;}
        .hs-val{font-family:'Cinzel',serif;font-size:1.4em;font-weight:700;min-width:32px;text-align:center;}
        .casualty-report{background:rgba(139,26,26,0.06);border-left:3px solid var(--accent);border-radius:0 6px 6px 0;padding:10px 14px;margin-bottom:10px;font-size:0.87em;line-height:1.7;}
        .round-log{max-height:130px;overflow-y:auto;margin-bottom:10px;}
        .round-log-entry{font-size:0.78em;color:var(--ink-light);padding:2px 0;border-bottom:1px dotted #ddd;font-family:'Courier New',monospace;}
        .auto-log{background:#1a1208;border-radius:6px;padding:10px 14px;font-family:'Courier New',monospace;font-size:0.78em;max-height:220px;overflow-y:auto;margin-bottom:12px;}
        .al{color:#d4a84b;padding:1px 0;}
        .al.g{color:#4db847;}
        .al.r{color:#e8192c;}
        .al.y{color:#f0c060;font-weight:bold;}
        .combat-btn-row{display:flex;gap:10px;margin-top:12px;}
        .btn-fight{flex:2;background:var(--accent);color:white;border:none;border-radius:8px;padding:15px;font-family:'Cinzel',serif;font-size:0.95em;font-weight:700;cursor:pointer;box-shadow:0 3px 0 #4a0a0a;transition:all 0.1s;}
        .btn-fight:active{transform:translateY(2px);box-shadow:0 1px 0 #4a0a0a;}
        .btn-fight:disabled{background:#aaa;box-shadow:0 3px 0 #666;cursor:not-allowed;}
        .btn-retreat{flex:1;background:var(--ink);color:#e8d8b8;border:none;border-radius:8px;padding:15px;font-family:'Cinzel',serif;font-size:0.85em;font-weight:600;cursor:pointer;box-shadow:0 3px 0 #050301;}
        .btn-retreat:active{transform:translateY(2px);}
        .result-banner{text-align:center;padding:16px;border-radius:8px;margin-bottom:12px;font-family:'Cinzel',serif;font-size:1.1em;font-weight:700;}
        .result-banner.win{background:rgba(30,126,68,0.14);color:#1e7e44;border:2px solid #1e7e44;}
        .result-banner.loss{background:rgba(139,26,26,0.1);color:var(--accent);border:2px solid var(--accent);}
        .result-banner.draw{background:rgba(200,149,42,0.14);color:var(--gold);border:2px solid var(--gold);}

        
        /* ===== HUMAN TURN ===== */
        .human-turn-steps { margin-top: 12px; }
        .ht-step {
            display: flex; align-items: flex-start; gap: 11px; padding: 11px 14px;
            border-bottom: 1px solid rgba(26,95,168,0.1); background: rgba(255,253,250,0.95);
            cursor: pointer; transition: background 0.1s;
        }
        .ht-step:last-child { border-bottom: none; }
        .ht-step.done { background: rgba(30,126,68,0.07); }
        .ht-step .ht-cb {
            width: 26px; height: 26px; border: 2px solid var(--player-color); border-radius: 6px;
            flex-shrink: 0; display: flex; align-items: center; justify-content: center;
            font-size: 15px; margin-top: 2px; transition: all 0.15s;
        }
        .ht-step.done .ht-cb { background: var(--p-green); border-color: var(--p-green); color: white; }
        .ht-step .ht-text { font-size: 0.88em; line-height: 1.62; color: var(--ink); flex: 1; }
        .ht-step .ht-text b { color: var(--player-color); }
        /* Human card picker */
        .hcp-wrap { padding:14px; }
        .hcp-label { font-family:'Cinzel',serif; font-size:0.8em; font-weight:700; color:var(--ink-light); text-transform:uppercase; letter-spacing:0.06em; margin-bottom:10px; }
        .hcp-grid { display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:12px; }
        .hcp-card { border:2px solid var(--border-light); border-radius:8px; padding:10px 10px 8px; cursor:pointer; background:#fffdf7; transition:all 0.15s; font-family:'Cinzel',serif; font-size:0.75em; font-weight:700; color:var(--ink); text-align:center; line-height:1.3; }
        .hcp-card:hover { border-color:var(--accent); background:#fff7f0; }
        .hcp-card.selected { border-color:var(--accent); background:rgba(139,26,26,0.08); color:var(--accent); }
        .hcp-card .hcp-count { font-size:0.78em; font-weight:400; color:var(--ink-light); margin-top:3px; font-family:inherit; }
        .hcp-confirm { width:100%; padding:12px; background:var(--accent); color:#fff; border:none; border-radius:8px; font-family:'Cinzel',serif; font-size:0.88em; font-weight:700; cursor:pointer; }
        .hcp-confirm:disabled { background:#bbb; cursor:not-allowed; }
        .hcp-discard { font-size:0.72em; color:var(--ink-light); text-align:center; margin-top:8px; }
        .ht-open-board {
            display: flex; align-items: center; gap: 8px; padding: 10px 14px;
            background: rgba(0,0,0,0.04); border: 2px solid var(--player-color);
            border-radius: 8px; font-family: 'Cinzel',serif; font-size: 0.88em;
            font-weight: 700; color: var(--player-color); cursor: pointer;
            margin: 8px 0; transition: background 0.15s; width: 100%;
        }
        .ht-open-board:active { background: rgba(26,95,168,0.15); }
        .ht-open-board.done-board { background: rgba(30,126,68,0.1); border-color: var(--p-green); color: #1e7e44; }
        .ht-progress { background: rgba(0,0,0,0.08); height: 4px; border-radius: 0 0 6px 6px; }
        .ht-progress-fill { height: 100%; background: var(--player-color); border-radius: 0 0 6px 6px; transition: width 0.2s; }

        
        /* Territory edit modal */
        .terr-edit-overlay { display:none; position:fixed; top:0;left:0;right:0;bottom:0; background:rgba(0,0,0,0.75); z-index:400; overflow-y:auto; padding:10px; }
        .terr-edit-overlay.open { display:block; }
        .terr-edit-modal { background:var(--parchment); max-width:480px; margin:0 auto; border:3px solid var(--border); border-radius:8px; overflow:hidden; }
        .terr-edit-hdr { background:var(--ink); color:var(--gold-light); padding:11px 16px; display:flex; justify-content:space-between; align-items:center; font-family:'Cinzel',serif; font-weight:700; font-size:0.95em; }
        .terr-edit-close { background:none; border:none; color:var(--gold-light); font-size:1.4em; cursor:pointer; }
        .terr-edit-body { padding:14px; }
        .te-section { margin-bottom:14px; }
        .te-label { font-family:'Cinzel',serif; font-size:0.72em; font-weight:700; letter-spacing:0.08em; color:var(--ink-light); text-transform:uppercase; margin-bottom:8px; }
        .te-owner-row { display:flex; gap:8px; flex-wrap:wrap; }
        .te-owner-btn { flex:1; min-width:60px; padding:8px 4px; border:3px solid transparent; border-radius:7px; font-family:'Cinzel',serif; font-size:0.72em; font-weight:700; cursor:pointer; text-align:center; transition:0.12s; }
        .te-owner-btn.sel { border-color:var(--ink); box-shadow:0 0 0 2px white, 0 0 0 4px var(--ink); }
        .te-units-grid { display:grid; grid-template-columns:1fr 1fr; gap:8px; }
        .te-unit-row { display:flex; align-items:center; justify-content:space-between; background:#fffdf5; border:1px solid var(--border-light); border-radius:7px; padding:8px 10px; }
        .te-unit-label { font-family:'Cinzel',serif; font-size:0.82em; font-weight:700; }
        .te-unit-sub { font-size:0.7em; color:var(--ink-light); }
        .te-stepper { display:flex; align-items:center; gap:6px; }
        .te-btn { width:28px; height:28px; border-radius:5px; border:1px solid var(--border); background:var(--parchment-dark); font-size:16px; cursor:pointer; display:flex; align-items:center; justify-content:center; font-weight:700; }
        .te-val { font-family:'Cinzel',serif; font-size:1.1em; font-weight:700; min-width:24px; text-align:center; }
        .te-castle-row { display:flex; align-items:center; justify-content:space-between; padding:10px 12px; background:#fffdf5; border:1px solid var(--border-light); border-radius:7px; }
        .te-castle-label { font-family:'Cinzel',serif; font-size:0.88em; font-weight:700; }
        .te-castle-toggle { padding:7px 16px; border-radius:6px; border:2px solid var(--border); font-family:'Cinzel',serif; font-size:0.82em; font-weight:700; cursor:pointer; background:var(--parchment-dark); transition:0.12s; }
        .te-castle-toggle.on { background:rgba(200,149,42,0.15); border-color:var(--gold); color:#7a5a00; }
        .te-save-btn { width:100%; margin-top:14px; padding:14px; background:var(--accent); color:white; border:none; border-radius:8px; font-family:'Cinzel',serif; font-size:0.95em; font-weight:700; cursor:pointer; }
        .te-save-btn:active { opacity:0.85; }
        .te-total-badge { font-size:0.8em; color:var(--ink-light); font-style:italic; }

        
        /* ===== COMBAT PHASE SCREEN ===== */
        .cp-overlay { display:none; position:fixed; top:0;left:0;right:0;bottom:0; background:rgba(10,0,0,0.92); z-index:350; overflow-y:auto; padding:10px; }
        .cp-overlay.open { display:block; }
        .cp-modal { background:var(--parchment); max-width:680px; margin:0 auto; border:3px solid var(--accent); border-radius:8px; overflow:hidden; box-shadow:0 0 60px rgba(200,0,0,0.5); }
        .cp-header { background:var(--accent); color:white; padding:14px 18px; font-family:'Cinzel',serif; font-weight:700; font-size:1.1em; letter-spacing:0.04em; text-align:center; }
        .cp-subhdr { background:rgba(139,26,26,0.08); padding:10px 16px; font-size:0.82em; color:var(--ink-light); text-align:center; border-bottom:1px solid var(--border-light); }
        .cp-body { padding:12px; }
        .cp-battle { border:2px solid var(--border-light); border-radius:8px; margin-bottom:10px; overflow:hidden; background:#fffdf5; }
        .cp-battle.resolved { opacity:0.55; }
        .cp-battle.active { border-color:var(--accent); background:#fff; box-shadow:0 2px 12px rgba(139,26,26,0.15); }
        .cp-battle-hdr { display:flex; align-items:center; justify-content:space-between; padding:10px 14px; border-bottom:1px solid var(--border-light); }
        .cp-battle-title { font-family:'Cinzel',serif; font-size:0.88em; font-weight:700; color:var(--ink); }
        .cp-battle-sub { font-size:0.75em; color:var(--ink-light); margin-top:1px; }
        .cp-battle-badge { font-size:0.72em; padding:3px 9px; border-radius:20px; font-family:'Cinzel',serif; font-weight:700; }
        .cp-battle-badge.pending { background:rgba(139,26,26,0.1); color:var(--accent); }
        .cp-battle-badge.done { background:rgba(30,126,68,0.12); color:#1e7e44; }
        .cp-battle-badge.auto { background:rgba(0,0,0,0.07); color:var(--ink-light); }
        .cp-auto-log { padding:10px 14px; font-size:0.8em; color:var(--ink-light); line-height:1.7; }
        .dice-row { display:flex; flex-wrap:wrap; gap:3px; margin:3px 0 5px 0; align-items:center; }
        .die { font-size:1.45em; line-height:1; }
        .die.hit  { color:#1a7a3c; }
        .die.miss { color:#bbb; }
        .board-instruction { background:#f0f7f0; border:1.5px solid #1a7a3c; border-radius:6px;
            padding:8px 12px; margin:6px 0; font-size:0.82em; color:#1a4a2a; line-height:1.6; }
        .board-instruction b { color:#145c25; }
        .board-instruction.neutral { background:#f5f0ea; border-color:#8b6914; color:#5a3e10; }
        .board-instruction.neutral b { color:#6b4c10; }
        .cp-human-panel { padding:12px 14px; }
        .cp-sides { display:flex; align-items:center; gap:8px; margin-bottom:12px; }
        .cp-side { flex:1; border-radius:7px; padding:10px 12px; color:white; text-align:center; }
        .cp-side .cps-label { font-size:0.7em; font-family:'Cinzel',serif; font-weight:700; letter-spacing:0.06em; opacity:0.8; }
        .cp-side .cps-name  { font-family:'Cinzel',serif; font-size:0.95em; font-weight:700; margin:3px 0; }
        .cp-side .cps-units { font-size:0.8em; opacity:0.9; }
        .cp-vs { font-family:'Cinzel',serif; font-size:1.2em; font-weight:700; color:var(--accent); flex-shrink:0; }
        .cp-result-banner { text-align:center; padding:12px; border-radius:7px; margin-bottom:10px; font-family:'Cinzel',serif; font-size:1em; font-weight:700; }
        .cp-result-banner.win  { background:rgba(30,126,68,0.12); color:#1e7e44; border:2px solid #1e7e44; }
        .cp-result-banner.loss { background:rgba(139,26,26,0.1); color:var(--accent); border:2px solid var(--accent); }
        .cp-result-banner.draw { background:rgba(200,149,42,0.12); color:var(--gold); border:2px solid var(--gold); }
        /* ── Full Log Overlay ── */
        .full-log-overlay { position:fixed;inset:0;background:rgba(0,0,0,0.6);z-index:9000;display:flex;align-items:center;justify-content:center; }
        .full-log-modal { background:var(--parchment);border-radius:12px;width:min(96vw,540px);max-height:80vh;display:flex;flex-direction:column;box-shadow:0 8px 40px rgba(0,0,0,0.4); }
        .full-log-header { display:flex;justify-content:space-between;align-items:center;padding:14px 16px;border-bottom:2px solid var(--border);font-family:'Cinzel',serif;font-size:1em;font-weight:700;color:var(--ink); }
        .full-log-header button { background:none;border:none;font-size:1.3em;cursor:pointer;color:var(--ink-light);line-height:1; }
        .full-log-body { overflow-y:auto;padding:10px 14px;flex:1; }
        .full-log-entry { font-size:0.78em;color:var(--ink);padding:5px 0;border-bottom:1px dotted var(--border-light);font-family:'Courier New',monospace;line-height:1.4; }
        .full-log-entry:first-child { color:var(--ink);font-weight:bold; }
        .full-log-entry.old { color:var(--ink-light); }
        .cp-end-btn { width:100%; padding:16px; background:var(--ink); color:var(--gold-light); border:none; border-radius:8px; font-family:'Cinzel',serif; font-size:1em; font-weight:700; cursor:pointer; margin-top:4px; letter-spacing:0.04em; }
        .cp-end-btn:active { opacity:0.85; }
        .cp-end-btn:disabled { opacity:0.4; cursor:not-allowed; }
        .cp-next-btn { width:100%; padding:14px; background:var(--accent); color:white; border:none; border-radius:8px; font-family:'Cinzel',serif; font-size:0.95em; font-weight:700; cursor:pointer; margin-top:8px; }

        
        /* Shield reminder steps */
        .shield-reminder {
            background: linear-gradient(135deg, rgba(200,149,42,0.12), rgba(200,149,42,0.06));
            border: 2px solid var(--gold);
            border-radius: 7px;
            padding: 9px 13px;
            font-family: 'Cinzel', serif;
            font-size: 0.82em;
            font-weight: 700;
            color: #7a5a00;
            letter-spacing: 0.02em;
        }

        </style>
</head>
<body>

<div id="setup-screen" class="screen">
<div class="paper">
    <div class="wizard-header">
        <span class="wh-title">RISK EUROPE — SOLO SETUP</span>
        <span class="wh-step" id="wiz-step-label">Step 1 of 7</span>
    </div>
    <div class="progress-bar"><div class="progress-fill" id="wiz-progress" style="width:14%"></div></div>
    <div class="inner" id="wiz-body"></div>
</div>
</div>

<div id="game-screen" class="screen" style="display:none">
<div class="paper">
    <div class="game-header">
        <span class="gh-round" id="round-display">ROUND 1</span>
        <span class="gh-step"  id="step-display">ACTION 1 of 2</span>
        <button class="save-btn" onclick="openSaveLoad()">💾 Save / Load</button>
    </div>
    <div id="saveload-overlay" class="saveload-overlay" style="display:none">
        <div class="saveload-modal">
            <h3>💾 Save / Load Game</h3>
            <div id="saveload-slots"></div>
            <div class="sl-export">
                <div style="font-size:0.78em;color:var(--ink-light);margin-bottom:4px;">Export / Import (copy-paste to back up or transfer between devices):</div>
                <textarea id="sl-json" placeholder="Paste exported save data here to import…"></textarea>
                <div style="display:flex;gap:8px;margin-top:6px;">
                    <button class="sl-btn save" onclick="slExport()">📋 Export to text</button>
                    <button class="sl-btn load" onclick="slImport()">📥 Import from text</button>
                    <button class="sl-btn del" onclick="closeSaveLoad()" style="margin-left:auto;">✕ Close</button>
                </div>
            </div>
        </div>
    </div>
    <div class="log-strip" id="action-log" onclick="openFullLog()" title="Tap to view full log" style="cursor:pointer;"></div>
    <div id="full-log-overlay" class="full-log-overlay" style="display:none">
        <div class="full-log-modal">
            <div class="full-log-header">
                <span>Full Game Log</span>
                <button onclick="closeFullLog()">✕</button>
            </div>
            <div class="full-log-body" id="full-log-body"></div>
        </div>
    </div>
    <div class="players-bar" id="player-bar"></div>
    <div class="action-area">
        <div id="ai-view">
            <div class="action-card unrevealed" id="card-display">
                Tap button to reveal<br><span class="card-sub">Automaton card is face-down</span>
            </div>
            <button class="btn-primary" id="reveal-btn" onclick="revealAction()">▶ REVEAL ACTION</button>
        </div>
        <div id="human-view" style="display:none">
            <!-- populated by renderHumanTurn() -->
        </div>

        <div class="steps-panel" id="steps-panel" style="display:none">
            <div class="steps-header" id="steps-header">STEPS TO PERFORM</div>
            <div class="steps-progress"><div class="steps-progress-fill" id="steps-progress-fill" style="width:0%"></div></div>
            <div id="steps-list"></div>
        </div>

        <div class="ref-toggle">
            <button class="ref-toggle-btn" onclick="toggleRef('ref-arrival')">
                ⚔ Arrival Minima (Attacking) <span class="arrow">▼</span>
            </button>
            <div class="ref-body" id="ref-arrival">
                Each unit (regardless of type) counts as 1. To attack an enemy territory:<br><br>
                <table>
                    <tr><th>Arriving army size</th><th>Attack threshold</th></tr>
                    <tr><td>1 – 5 units</td><td>Must be ≥ defender count</td></tr>
                    <tr><td>6 – 10 units</td><td>May be up to 3 fewer than defender</td></tr>
                    <tr><td>11 – 15 units</td><td>May be up to 4 fewer than defender</td></tr>
                    <tr><td>16 – 20 units</td><td>May be up to 5 fewer than defender</td></tr>
                    <tr><td>21+ units</td><td>No restriction</td></tr>
                </table>
                <br>⚠ A Siege Engine is always required to attack a city that has a Castle.
            </div>
        </div>
        <div class="ref-toggle">
            <button class="ref-toggle-btn" onclick="toggleRef('ref-move')">
                🚶 Movement <span class="arrow">▼</span>
            </button>
            <div class="ref-body" id="ref-move">
                <b>EXPAND</b> — Move an army from any territory into an adjacent city (non-owned).<br>
                Priority: highest Tax city &amp; largest army. If tied: fewest defenders; roll die.<br><br>

                <b>SPLIT EXPAND</b> — Move one army up to <b>2 territories</b> toward a city to enter it.<br>
                Cannot pass through enemy territory — must stop and fight if it enters one.<br>
                Priority: highest Tax → 1 step preferred over 2 → fewest defenders. If can't reach any city: fall back to Maneuver.<br><br>

                <b>POSITION</b> — When no city entry is possible, move the <b>largest army</b> one step toward the highest-Tax non-owned city.<br><br>

                <b>MANEUVER</b> — Relocate any units from one own territory to another own or disputed territory up to <b>2 territories away</b>, travelling only through own territories.<br>
                Cannot move out of a disputed territory. Stops upon entering a disputed territory.<br>
                Priority: reinforce threatened territory (highest Tax) → reinforce frontline near enemy city → reposition.<br><br>

                <hr style="border:none;border-top:1px solid var(--border);margin:8px 0;">
                <b>LEAVE-BEHIND</b> — When an army departs a territory it must leave units behind:<br><br>
                • <b>Non-urban territory:</b> always leave <b>1 unit</b>.<br>
                • <b>City:</b> leave units equal to the city's <b>Tax value</b> (e.g. Tax 3 → leave 3).<br><br>
                <b>Which units to leave (cheapest first):</b><br>
                A. Footmen &nbsp;→&nbsp; B. Archers &nbsp;→&nbsp; C. Siege Engines &nbsp;→&nbsp; D. Cavalry
            </div>
        </div>
        <div class="ref-toggle">
            <button class="ref-toggle-btn" onclick="toggleRef('ref-spend')">
                💰 Full Spend Table <span class="arrow">▼</span>
            </button>
            <div class="ref-body" id="ref-spend">
                Automatons spend at the row matching their exact coin count (or highest row ≤ their coins):<br><br>
                <table>
                    <tr><th>Coins</th><th>Purchase</th></tr>
                    <tr><td>5</td><td>2 Footmen + 1 Cavalry</td></tr>
                    <tr><td>6</td><td>1 Footman + 1 Archer + 1 Cavalry</td></tr>
                    <tr><td>7</td><td>2 Footmen + 1 Archer + 1 Cavalry</td></tr>
                    <tr><td>8</td><td>2 Footmen + 2 Cavalry</td></tr>
                    <tr><td>9</td><td>2 Footmen + 2 Archers + 1 Cavalry</td></tr>
                    <tr><td>10</td><td>1 Siege Engine</td></tr>
                    <tr><td>11</td><td>1 Footman + 1 Siege Engine</td></tr>
                    <tr><td>12</td><td>1 Castle</td></tr>
                    <tr><td>13</td><td>1 Cavalry + 1 Siege Engine</td></tr>
                    <tr><td>14</td><td>2 Footmen + 1 Castle</td></tr>
                    <tr><td>15</td><td>2 Footmen + 1 Cavalry + 1 Siege Engine</td></tr>
                    <tr><td>16</td><td>2 Footmen + 1 Archer + 1 Castle</td></tr>
                    <tr><td>17</td><td>2 Footmen + 1 Archer + 1 Cavalry + 1 Siege Engine</td></tr>
                    <tr><td>18</td><td>2 Footmen + 1 Cavalry + 1 Castle</td></tr>
                    <tr><td>19</td><td>2 Footmen + 2 Archers + 1 Cavalry + 1 Siege Engine</td></tr>
                    <tr><td>20</td><td>3 Footmen + 1 Archer + 1 Cavalry + 1 Castle</td></tr>
                </table>
                <br>No castles left in supply → buy 1 Crown Card + 2 Footmen instead.<br>
                Missing a figure type → substitute 2 Footmen ↔ 1 Archer. Keep leftover coins.
            </div>
        </div>

        <div style="margin-top: 12px;">
            <button class="btn-advance" id="complete-btn" onclick="advanceTurn()" disabled>
                ✓ COMPLETE TURN — NEXT PLAYER
            </button>
            <div id="stuck-hint" style="display:none;text-align:center;margin-top:4px;">
                <button onclick="forceAdvance()" style="background:none;border:none;color:var(--ink-light);font-size:0.75em;cursor:pointer;text-decoration:underline;">Stuck? Force advance turn →</button>
            </div>
            <button class="btn-reset" onclick="confirmReset()">↺ Full Reset / Return to Setup</button>
        </div>
    </div>
</div>
</div>

<script>
// ================================================================
// DATA
// ================================================================
const CAPITALS = [
    // name = territory key in T[]; city = display name; adjOptions = starting secondary options
    { name:"León Castile", city:"Madrid",         tax:3, units:3, adjOptions:[{name:"Valencia",units:2},{name:"Portugal",units:2},{name:"Navarre",units:2}] },
    { name:"France",       city:"Paris",          tax:3, units:3, adjOptions:[{name:"Normandy",units:2},{name:"Lorraine",units:2},{name:"Navarre",units:2},{name:"Burgundy",units:2}] },
    { name:"England",      city:"London",         tax:3, units:3, adjOptions:[{name:"Wales",units:2},{name:"Normandy",units:2},{name:"Scotland",units:2}] },
    { name:"Sweden",       city:"Stockholm",      tax:3, units:3, adjOptions:[{name:"Norway",units:2},{name:"Denmark",units:2},{name:"Finland",units:2}] },
    { name:"Rusland",      city:"Kiev",           tax:2, units:2, adjOptions:[{name:"Galicia",units:3},{name:"Smolensk",units:3},{name:"Lithuania",units:3}] },
    { name:"Rome",         city:"Rome",           tax:4, units:3, adjOptions:[{name:"Lombardy",units:2},{name:"Kingdom of Sicily",units:2}] },
    { name:"Saxony",       city:"Berlin",         tax:4, units:3, adjOptions:[{name:"Pomerania",units:2},{name:"Lorraine",units:2},{name:"Franconia",units:2},{name:"Friesland",units:2}] },
    { name:"Turkey",       city:"Constantinople", tax:3, units:3, adjOptions:[{name:"Bulgaria",units:2},{name:"Greece",units:2}] },
];

const DECK_BASE = [
    "TAX OR SPEND","TAX OR SPEND",
    "SPLIT EXPAND OR MANEUVER","SPLIT EXPAND OR MANEUVER",
    "KING ME / TAX OR SPEND",
    "SIEGE ASSAULT / EXPAND OR MANEUVER",
    "FORTIFY / EXPAND OR MANEUVER","FORTIFY / EXPAND OR MANEUVER"
]; // 8 cards: 2×Tax, 2×SplitExpand, KingMe/Tax, SiegeAssault, 2×Fortify

const SPEND_TABLE = {
    5:"2 Footmen + 1 Cavalry", 6:"1 Footman + 1 Archer + 1 Cavalry",
    7:"2 Footmen + 1 Archer + 1 Cavalry", 8:"2 Footmen + 2 Cavalry",
    9:"2 Footmen + 2 Archers + 1 Cavalry", 10:"1 Siege Engine",
    11:"1 Footman + 1 Siege Engine", 12:"1 Castle",
    13:"1 Cavalry + 1 Siege Engine", 14:"2 Footmen + 1 Castle",
    15:"2 Footmen + 1 Cavalry + 1 Siege Engine", 16:"2 Footmen + 1 Archer + 1 Castle",
    17:"2 Footmen + 1 Archer + 1 Cavalry + 1 Siege Engine", 18:"2 Footmen + 1 Cavalry + 1 Castle",
    19:"2 Footmen + 2 Archers + 1 Cavalry + 1 Siege Engine", 20:"3 Footmen + 1 Archer + 1 Cavalry + 1 Castle"
};
const COLOR_HEX = { orange:'#f97316', green:'#4db847', purple:'#3b0764', blue:'#5bb8f5' };

// ================================================================
// TERRITORY MAP  (62 territories, verified from board image)
// ================================================================
const T = {
  // Cities are embedded in their territory. T[terr].city = city name (for shields/display).
  // T[terr].tax > 0 means that territory contains a city.
  // Adjacencies verified by user against physical map.

  // --- BRITISH ISLES ---
  "Scotland":          { tax:0, adj:["England","Ireland","Norway"] },
  "England":           { tax:3, city:"London",        adj:["Scotland","Wales","Normandy","Lorraine"] },
  "Wales":             { tax:0, adj:["Ireland","England"] },
  "Ireland":           { tax:2, city:"Dublin",        adj:["Scotland","Wales","Brittany"] },
  // --- SCANDINAVIA ---
  "Norway":            { tax:0, adj:["Scotland","Sweden","Denmark"] },
  "Sweden":            { tax:3, city:"Stockholm",     adj:["Norway","Finland","Denmark"] },
  "Finland":           { tax:0, adj:["Sweden","Estonia","Rep. Novgorod"] },
  "Denmark":           { tax:0, adj:["Norway","Sweden","Friesland","Pomerania","Saxony","Bohemia","Poland"] },
  // --- FRANCE / IBERIA ---
  "Brittany":          { tax:0, adj:["Ireland","Normandy","France","León Castile"] },
  "Normandy":          { tax:0, adj:["England","Brittany","France"] },
  "France":            { tax:3, city:"Paris",         adj:["Brittany","Normandy","Lorraine","Burgundy","Navarre","Barcelona"] },
  "Burgundy":          { tax:0, adj:["France","Lorraine","Swabia","Lombardy","Barcelona"] },
  "Navarre":           { tax:0, adj:["France","Barcelona","León Castile","Valencia"] },
  "León Castile":      { tax:3, city:"Madrid",        adj:["Navarre","Portugal","Valencia","Granada","Morocco","Brittany"] },
  "Portugal":          { tax:0, adj:["León Castile"] },
  "Valencia":          { tax:0, adj:["León Castile","Barcelona","Granada","Navarre","Algeria"] },
  "Barcelona":         { tax:0, adj:["Navarre","Burgundy","Valencia","France"] },
  "Granada":           { tax:0, adj:["León Castile","Valencia"] },
  "Morocco":           { tax:0, adj:["León Castile","Algeria"] },
  // --- HOLY ROMAN EMPIRE ---
  "Friesland":         { tax:0, adj:["Denmark","Saxony","Lorraine"] },
  "Saxony":            { tax:4, city:"Berlin",        adj:["Friesland","Lorraine","Franconia","Bohemia","Denmark"] },
  "Lorraine":          { tax:0, adj:["England","Friesland","Saxony","Franconia","Swabia","Burgundy","France"] },
  "Franconia":         { tax:0, adj:["Saxony","Lorraine","Bohemia","Bavaria","Swabia"] },
  "Swabia":            { tax:2, city:"Zurich",        adj:["Lorraine","Franconia","Bavaria","Burgundy","Lombardy"] },
  "Bavaria":           { tax:0, adj:["Franconia","Swabia","Bohemia","Highlands","Venice","Hungary","Lombardy"] },
  "Bohemia":           { tax:0, adj:["Saxony","Franconia","Bavaria","Highlands","Poland","Denmark"] },
  // --- EASTERN EUROPE ---
  "Pomerania":         { tax:0, adj:["Denmark","Poland","Prussia","Lithuania"] },
  "Prussia":           { tax:0, adj:["Pomerania","Poland","Lithuania","Polotsk"] },
  "Poland":            { tax:2, city:"Warsaw",        adj:["Pomerania","Prussia","Bohemia","Highlands","Galicia","Hungary","Polotsk","Rusland","Denmark"] },
  "Highlands":         { tax:0, adj:["Bohemia","Bavaria","Poland","Hungary","Galicia"] },
  "Hungary":           { tax:3, city:"Buda",          adj:["Highlands","Venice","Galicia","Serbia","Bulgaria","Bavaria","Poland"] },
  "Galicia":           { tax:0, adj:["Poland","Highlands","Hungary","Rusland","Bulgaria"] },
  "Rusland":           { tax:2, city:"Kiev",          adj:["Galicia","Polotsk","Smolensk","Poland"] },
  "Lithuania":         { tax:0, adj:["Prussia","Polotsk","Estonia","Smolensk","Pomerania"] },
  "Estonia":           { tax:0, adj:["Finland","Lithuania","Rep. Novgorod","Smolensk"] },
  "Polotsk":           { tax:0, adj:["Lithuania","Rusland","Smolensk","Poland","Prussia"] },
  "Smolensk":          { tax:0, adj:["Rusland","Polotsk","Rep. Novgorod","Estonia","Lithuania"] },
  "Rep. Novgorod":     { tax:4, city:"Novgorod",      adj:["Finland","Estonia","Smolensk"] },
  // --- ITALY ---
  "Lombardy":          { tax:0, adj:["Burgundy","Swabia","Rome","Bavaria"] },
  "Venice":            { tax:0, adj:["Bavaria","Hungary","Kingdom of Sicily","Serbia"] },
  "Rome":              { tax:4, city:"Rome",           adj:["Lombardy","Kingdom of Sicily","Sardinia"] },
  "Kingdom of Sicily": { tax:0, adj:["Rome","Venice"] },
  "Sardinia":          { tax:0, adj:["Tunisia","Rome"] },
  // --- BALKANS ---
  "Serbia":            { tax:0, adj:["Hungary","Venice","Bulgaria","Greece"] },
  "Bulgaria":          { tax:0, adj:["Serbia","Greece","Turkey","Hungary","Galicia"] },
  "Greece":            { tax:2, city:"Athens",        adj:["Serbia","Bulgaria","Turkey","Tunisia"] },
  "Turkey":            { tax:3, city:"Constantinople", adj:["Greece","Bulgaria"] },
  // --- NORTH AFRICA ---
  "Algeria":           { tax:3, city:"Bejaia",        adj:["Morocco","Tunisia","Valencia"] },
  "Tunisia":           { tax:0, adj:["Algeria","Sardinia","Greece"] },
};

// ── Shield key lookup by territory name ─────────────────────────
// CITY_SHIELDS keys are city names; board keys are territory names.
// Use these helpers everywhere a shield needs to be looked up by territory.
function shieldKeyForTerr(terrName) {
    // Returns the CITY_SHIELDS key (city name) for a given territory, or null
    if (!terrName) return null;
    // Direct match (Rome is both territory and city)
    if (CITY_SHIELDS[terrName]) return terrName;
    // Look up by terr property
    const entry = Object.entries(CITY_SHIELDS).find(([,v]) => v.terr === terrName);
    return entry ? entry[0] : null;
}
function shieldForTerr(terrName) {
    const k = shieldKeyForTerr(terrName);
    return k ? CITY_SHIELDS[k] : null;
}

// cityOf(terrName): returns the city name for a territory, or the territory name if it IS a city (Rome)
function cityOf(terrName) { return T[terrName]?.city || terrName; }

// terrLabel(name): display label for a territory, annotating city and shield status.
// e.g. "Saxony (Berlin 🛡)" with golden shield city colored yellow.
// shieldOwner: if provided, only highlight when that color owns the shield.
function terrLabel(name, shieldOwner) {
    if (!name) return name;
    const city = T[name]?.city;
    const sk   = shieldKeyForTerr(name);
    const hasShield = !!sk;
    // If no city annotation needed, just return plain name
    if (!city || city === name) {
        if (!hasShield) return name;
        return name + ' <span style="color:#c8960c;font-size:0.82em;">🛡</span>';
    }
    // Has a separate city name
    const shieldSpan = hasShield
        ? ` <span style="color:#c8960c;font-weight:700;font-size:0.82em;">🛡</span>`
        : '';
    const citySpan = hasShield
        ? ` <span style="color:#c8960c;font-size:0.82em;">(${city}${shieldSpan})</span>`
        : ` <span style="font-size:0.82em;color:var(--ink-light);">(${city})</span>`;
    return name + citySpan;
}
// terrOf(cityOrTerrName): given a city name from CITY_SHIELDS, returns the territory name
function terrOf(cityName) {
    if (T[cityName]) return cityName; // it's already a territory name (Rome, or non-city)
    const found = Object.keys(T).find(k => T[k].city === cityName);
    return found || cityName;
}
// cityLabel(terrName): display string, e.g. "France (Paris)" or just "Rome"
function cityLabel(terrName) {
    const city = T[terrName]?.city;
    return city && city !== terrName ? `${terrName} (${city})` : terrName;
}

// Helper: list all city territory names (territories that contain a city)
const ALL_CITIES = Object.keys(T).filter(n => T[n].tax > 0);

// ================================================================
// BOARD STATE HELPERS
// ================================================================
// Normalize a territory name to match a T key (case-insensitive fallback)
function normTerrName(name) {
    if (!name) return null;
    if (T[name]) return name; // exact match
    const lower = name.toLowerCase();
    const found = Object.keys(T).find(k => k.toLowerCase() === lower);
    return found || null;
}

// Safe board set: only sets if the name resolves to a valid T key
function setBoardTerr(name, owner, units, castle) {
    const n = normTerrName(name);
    if (!n) { console.warn('Unknown territory:', name); return; }
    G.board[n] = { owner, units, castle };
}

function initBoard() {
    G.board = {};
    // Init all territories as neutral/empty
    for (const name of Object.keys(T)) {
        G.board[name] = { owner:'neutral', units:{F:0,A:0,C:0,S:0}, castle:false };
    }
    // Populate automaton territories from wizard data
    const autos = autoColors_g();
    autos.forEach(color => {
        const primary   = S.autoCapitals[color];
        const secondary = S.autoSecondary[color];
        if (primary) {
            setBoardTerr(primary.name, color, {F:primary.units,A:0,C:0,S:0}, true);
            if (primary._adj) {
                setBoardTerr(primary._adj.name, color, {F:primary._adj.units,A:0,C:0,S:0}, false);
            }
        }
        if (secondary) {
            setBoardTerr(secondary.name, color, {F:secondary.units,A:0,C:0,S:0}, false);
        }
    });
    // Player territories
    const pc = S.playerCapital;
    const ps = S.playerSecondary;
    if (pc) {
        setBoardTerr(pc.name, S.playerColor, {F: S.playerPrimaryUnits||3, A:0,C:0,S:0}, true);
        if (pc._adj) {
            const adjU = Math.max(0, 5 - (S.playerPrimaryUnits||3));
            setBoardTerr(pc._adj.name, S.playerColor, {F:adjU,A:0,C:0,S:0}, false);
        }
    }
    if (ps) {
        setBoardTerr(ps.name, S.playerColor, {F:ps.units,A:0,C:0,S:0}, false);
    }
    console.log('Board initialized:', Object.keys(G.board).length, 'territories,',
        Object.values(G.board).filter(b=>b.owner!=='neutral').length, 'owned.');
}

function totalUnitCount(name) {
    const u = G.board[name]?.units || {F:0,A:0,C:0,S:0};
    return u.F + u.A + u.C + u.S;
}

function unitStr(u, short=false) {
    const parts = [];
    if (u.C > 0) parts.push(`${u.C} Cavalry`);
    if (u.A > 0) parts.push(`${u.A} Archer${u.A>1?'s':''}`);
    if (u.F > 0) parts.push(`${u.F} Footm${u.F>1?'en':'an'}`);
    if (u.S > 0) parts.push(`${u.S} Siege`);
    return parts.length ? parts.join(' + ') : 'no units';
}

function unitTotal(u) { return u.F + u.A + u.C + u.S; }

function leaveBehindCount(name) {
    // Automaton rule: must leave Tax-value units in a city, 1 in non-urban
    return T[name]?.tax > 0 ? T[name].tax : 1;
}

function leaveBehindPlayer(_name) {
    // Human rule: always leave at least 1 unit behind
    return 1;
}

function movableCount(name, color) {
    if (G.board[name]?.owner !== color) return 0;
    return Math.max(0, totalUnitCount(name) - leaveBehindCount(name));
}

function movableCountPlayer(name) {
    return Math.max(0, totalUnitCount(name) - leaveBehindPlayer(name));
}

// Which units to MOVE (best quality first; keep siege if need it for castle attack)
function unitsToMove(name, count, needsSiege) {
    const u = {...G.board[name].units};
    const mv = {F:0,A:0,C:0,S:0};
    let rem = count;
    if (needsSiege && u.S > 0) { mv.S = 1; u.S--; rem--; }
    const take = (k) => { const n=Math.min(u[k],rem); mv[k]+=n; u[k]-=n; rem-=n; };
    take('C'); take('A'); take('F'); take('S');
    return mv;
}

// Units to LEAVE (worst first: F, A, S, C)
function unitsToLeave(name, count) {
    const u = {...G.board[name].units};
    const lv = {F:0,A:0,C:0,S:0};
    let rem = count;
    const keep = (k) => { const n=Math.min(u[k],rem); lv[k]+=n; rem-=n; };
    keep('F'); keep('A'); keep('S'); keep('C');
    return lv;
}

function canAttack(arriving, defending) {
    if (arriving >= 21) return true;
    if (arriving >= 16) return defending <= arriving + 5;
    if (arriving >= 11) return defending <= arriving + 4;
    if (arriving >= 6)  return defending <= arriving + 3;
    return arriving >= defending;
}

function ownedBy(color) {
    return Object.keys(G.board).filter(n => G.board[n].owner === color && T[n]);
}

// Flood-fill from city through OWN territories to calculate tax yield
function isContested(name) {
    // A territory is contested if it has an unresolved queued battle attacking INTO it
    return (G.roundCombats||[]).some(b => b.to === name && !b._resolved);
}

function taxYield(color, cityName) {
    // Flood-fill from cityName through connected own territories.
    // Rules:
    //   - Start at cityName (must be owned by color, must be a city)
    //   - Each connected own territory adds: its tax value (if city) or 1 (if non-city)
    //   - Contested territories (active battle queued into them) BREAK the supply line —
    //     they do not add income and cannot be traversed to reach further territories
    if (!T[cityName] || T[cityName].tax === 0) return 0;
    if (!G.board[cityName]) return 0;
    if (G.board[cityName]?.owner !== color) return 0;
    if (isContested(cityName)) return 0; // contested city: no income at all
    let yield_ = T[cityName].tax;
    const visited = new Set([cityName]);
    const queue = [cityName];
    while (queue.length) {
        const cur = queue.shift();
        for (const adj of T[cur].adj) {
            if (visited.has(adj)) continue;
            if (G.board[adj]?.owner !== color) continue;
            if (isContested(adj)) { visited.add(adj); continue; } // contested: yields nothing, blocks supply line
            visited.add(adj);
            queue.push(adj);
            yield_ += T[adj].tax > 0 ? T[adj].tax : 1;
        }
    }
    return yield_;
}

// ================================================================
// DECISION ENGINE
// ================================================================

function decideTax(color) {
    const cities = ownedBy(color).filter(n => T[n].tax > 0);
    if (!cities.length) return null;
    const scored = cities.map(c => ({ city:c, yield:taxYield(color,c), hasTaxBonus: false }));
    scored.sort((a,b) => b.yield - a.yield);
    return scored[0];
}

function decideSpendPlacements(color, purchase) {
    // Returns array of {territory, units} placement instructions
    const owned = ownedBy(color).filter(n => T[n].tax > 0)
        .sort((a,b) => T[b].tax - T[a].tax || totalUnitCount(a) - totalUnitCount(b));
    
    const placements = [];
    const unitsToPlace = { C: purchase.C||0, A: purchase.A||0, F: purchase.F||0 };
    
    // Castle placement
    if (purchase.castle) {
        const castleDest = ownedBy(color).filter(n => T[n].tax > 0 && !G.board[n].castle)
            .sort((a,b) => T[b].tax - T[a].tax || totalUnitCount(a) - totalUnitCount(b))[0];
        if (castleDest) placements.push({ territory: castleDest, type:'castle', detail:'Place Castle here' });
    }
    
    // Unit placement — 1 at a time, best quality first to highest-tax city
    let cityIdx = 0;
    const unitOrder = [
        ...Array(unitsToPlace.C).fill('C'),
        ...Array(unitsToPlace.A).fill('A'),
        ...Array(unitsToPlace.F).fill('F'),
    ];
    unitOrder.forEach(type => {
        const city = owned[cityIdx % owned.length];
        if (!city) return;
        // Only merge if same city AND same unit type
        const existing = placements.find(p => p.territory === city && p.type === 'units' && p.unitType === type);
        if (existing) existing.count++;
        else placements.push({ territory: city, type:'units', unitType: type, count: 1 });
        cityIdx++;
    });
    
    // Siege Engine
    if (purchase.S) {
        // Find own territory closest to enemy castle
        const enemyCastles = Object.keys(G.board).filter(n => G.board[n].castle && G.board[n].owner !== color && G.board[n].owner !== 'neutral');
        let bestSiegeDest = null, bestDist = 999;
        for (const ec of enemyCastles) {
            for (const t of ownedBy(color)) {
                if (T[t].adj.includes(ec) || t === ec) { // adjacent
                    const d = 1;
                    if (d < bestDist || (d === bestDist && T[t].tax > (T[bestSiegeDest]?.tax||0))) {
                        bestDist = d; bestSiegeDest = t;
                    }
                }
            }
        }
        if (!bestSiegeDest) bestSiegeDest = owned[0] || ownedBy(color)[0];
        if (bestSiegeDest) placements.push({ territory: bestSiegeDest, type:'siege', detail:'Place Siege Engine here' });
    }
    return placements;
}

function decideExpand(color) {
    const candidates = [];
    for (const t of ownedBy(color)) {
        const movable = movableCount(t, color);
        if (movable <= 0) continue;
        for (const adj of (T[t]?.adj || [])) {
            if (!T[adj] || T[adj].tax === 0) continue; // not a city
            const adjB = G.board[adj];
            if (adjB.owner === color) continue;
            const defenders = totalUnitCount(adj);
            const isEnemy = adjB.owner !== 'neutral';
            const hasCastle = adjB.castle;
            const hasSiege = G.board[t].units.S > 0;
            if (hasCastle && !hasSiege) continue; // need siege engine
            if (isEnemy && !canAttack(movable, defenders)) continue;
            candidates.push({ from:t, to:adj, movable, defenders, isEnemy,
                tax:T[adj].tax, hasCastle });
        }
    }
    if (!candidates.length) return null;
    candidates.sort((a,b) => b.tax-a.tax || b.movable-a.movable || a.defenders-b.defenders);
    return candidates[0];
}

function decideSplitExpand(color) {
    const candidates = [];
    for (const t of ownedBy(color)) {
        const movable = movableCount(t, color);
        if (movable <= 0) continue;
        // 1-step cities
        for (const adj of T[t].adj) {
            if (!T[adj] || T[adj].tax === 0) continue;
            const adjB = G.board[adj];
            if (adjB.owner === color) continue;
            const defenders = totalUnitCount(adj);
            const isEnemy = adjB.owner !== 'neutral';
            const hasCastle = adjB.castle;
            const hasSiege = G.board[t].units.S > 0;
            if (hasCastle && !hasSiege) continue;
            if (isEnemy && !canAttack(movable, defenders)) continue;
            candidates.push({ from:t, via:null, to:adj, movable, defenders, isEnemy, tax:T[adj].tax, hasCastle });
        }
        // 2-step cities — can only pass through own territories (not neutral, not enemy)
        for (const mid of T[t].adj) {
            const midB = G.board[mid];
            // Must pass through own territory (Risk Europe rule: supply line movement only)
            if (midB.owner !== color) continue;
            for (const dest of T[mid].adj) {
                if (dest === t) continue;
                if (!T[dest] || T[dest].tax === 0) continue;
                const destB = G.board[dest];
                if (destB.owner === color) continue;
                const defenders = totalUnitCount(dest);
                const isEnemy = destB.owner !== 'neutral';
                const hasCastle = destB.castle;
                const hasSiege = G.board[t].units.S > 0;
                if (hasCastle && !hasSiege) continue;
                if (isEnemy && !canAttack(movable, defenders)) continue;
                candidates.push({ from:t, via:mid, to:dest, movable, defenders, isEnemy, tax:T[dest].tax, hasCastle });
            }
        }
    }
    if (!candidates.length) return null;
    // Priority: highest tax → 1-step preferred over 2-step → fewest defenders → most units arriving
    candidates.sort((a,b) =>
        (b.tax - a.tax) ||
        ((a.via ? 1 : 0) - (b.via ? 1 : 0)) ||   // null via = 1-step = better
        (a.defenders - b.defenders) ||              // fewest defenders
        (b.movable - a.movable)                     // most units
    );
    return candidates[0];
}

function decidePosition(color) {
    // Move LARGEST possible army one step so it ends up ADJACENT to a non-owned city.
    // "Position" never moves INTO a city — that is always EXPAND.
    // The destination must be own or neutral (enemy territories require combat).
    // Primary sort: most movable units. Tiebreaker: highest-tax target city.
    const candidates = [];
    for (const t of ownedBy(color)) {
        const movable = movableCount(t, color);
        if (movable <= 0) continue;
        for (const adj of (T[t]?.adj || [])) {
            // Skip cities entirely — moving into a city is EXPAND, not POSITION
            if (T[adj]?.tax > 0) continue;
            // Skip enemy territories — moving there requires combat
            const adjOwner = G.board[adj]?.owner;
            if (adjOwner && adjOwner !== color && adjOwner !== 'neutral') continue;
            // adj is a valid destination (own non-city, or neutral non-city)
            // Add a candidate for each non-owned city adjacent to adj
            for (const city of (T[adj]?.adj || [])) {
                if (!T[city] || T[city].tax === 0) continue;
                if (G.board[city]?.owner === color) continue; // already own it
                candidates.push({ from:t, to:adj, toward:city, targetTax:T[city].tax, movable });
            }
        }
    }
    if (!candidates.length) return null;
    // Sort: largest army first, highest-tax target city second
    // Deduplicate by (from,to) — pick the best target city for each from→to pair
    candidates.sort((a,b) => b.movable - a.movable || b.targetTax - a.targetTax);
    const seen = new Set();
    for (const c of candidates) {
        const key = c.from + '|' + c.to;
        if (!seen.has(key)) { seen.add(key); return c; }
    }
    return candidates[0];
}

function decideFortify(color) {
    const opts = ownedBy(color).filter(n => T[n].tax > 0 || G.board[n].castle);
    if (!opts.length) return null;
    // Capitals = starting cities (any city in CAPITALS list)
    const capitalNames = new Set(CAPITALS.map(c => c.name));
    opts.sort((a,b) => {
        const ta = totalUnitCount(a), tb = totalUnitCount(b);
        if (ta !== tb) return ta - tb;                        // fewest units first
        const taxA = T[a].tax||0, taxB = T[b].tax||0;
        if (taxA !== taxB) return taxB - taxA;               // highest tax first
        const capA = capitalNames.has(a) ? 1 : 0;
        const capB = capitalNames.has(b) ? 1 : 0;
        if (capA !== capB) return capB - capA;               // capital beats regular city
        return 0;                                             // random (caller rolls die)
    });
    const t = opts[0];
    const addCount = G.board[t].castle ? 4 : 3;
    return { territory:t, count:addCount, hasCastle: G.board[t].castle };
}

function decideSiege(color) {
    // Must have at least 1 siege engine
    const withSiege = ownedBy(color).filter(n => G.board[n].units.S > 0);
    if (!withSiege.length) return null;
    let candidates = [];
    for (const t of withSiege) {
        for (const adj of T[t].adj) {
            // Siege Assault only targets enemy-held castles (neutral castles can be entered without siege)
            if (G.board[adj]?.owner && G.board[adj].owner !== color && G.board[adj].owner !== 'neutral'
                    && G.board[adj].castle) {
                candidates.push({ from:t, to:adj, defenders: totalUnitCount(adj), defOwner: G.board[adj].owner });
            }
        }
    }
    if (!candidates.length) return null;
    // Sort by most defenders, then by color with most total units
    const totals = {};
    ['orange','green','purple','blue'].forEach(c => {
        totals[c] = ownedBy(c).reduce((s,n)=>s+totalUnitCount(n),0);
    });
    candidates.sort((a,b) => b.defenders-a.defenders || totals[b.defOwner]-totals[a.defOwner]);
    return candidates[0];
}

// Build all valid MANEUVER moves for a color.
// Rules: move from one OWN territory to another OWN or DISPUTED territory,
// up to 2 steps away, travelling only through OWN territories.
// Cannot move out of a disputed territory. Stop immediately upon entering disputed.
// "Disputed" = a pending battle queued in G.roundCombats for that territory.
function getManeuverMoves(color) {
    const owned = ownedBy(color);
    const isDisputed = (name) => (G.roundCombats||[]).some(b => b.to === name && !b._resolved);

    const moves = []; // { from, to, hops, movable }

    for (const from of owned) {
        // Cannot maneuver OUT of a disputed territory
        if (isDisputed(from)) continue;
        const movable = movableCount(from, color);
        if (movable <= 0) continue;

        // BFS up to 2 hops through own territories only
        // Each node: { name, hops }
        const visited = new Set([from]);
        const queue = [{ name: from, hops: 0 }];

        while (queue.length) {
            const { name: cur, hops } = queue.shift();
            if (hops >= 2) continue; // can't go further

            for (const adj of (T[cur]?.adj || [])) {
                if (visited.has(adj)) continue;
                const adjOwner = G.board[adj]?.owner;
                // Can only travel through own territories (or land in disputed)
                if (adjOwner !== color) {
                    // Can we land here? Only if it's own or disputed own territory
                    // (neutral/enemy are not valid maneuver destinations)
                    continue;
                }
                visited.add(adj);
                const dest = adj;
                const destHops = hops + 1;
                if (dest !== from) {
                    moves.push({ from, to: dest, hops: destHops, movable });
                    // If disputed, stop here (can't pass through)
                    if (!isDisputed(dest)) {
                        queue.push({ name: dest, hops: destHops });
                    }
                }
            }
        }
    }
    return moves;
}

function decideManeuver(color) {
    const moves = getManeuverMoves(color);
    if (!moves.length) return null;

    // Priority 1: reinforce a threatened territory
    // Rule: "choisissez son terrain qui peut apporter le plus de renfort"
    // — pick the source that brings the MOST units to the best threatened destination.
    // Threatened territory priority: 1. highest tax  2. most reinforcement available  3. most attackers
    const isDisputed = (name) => (G.roundCombats||[]).some(b => b.to === name && !b._resolved);
    const threatenedTerrs = new Set();
    for (const t of ownedBy(color)) {
        for (const adj of T[t].adj) {
            const b = G.board[adj];
            if (b?.owner && b.owner !== color && b.owner !== 'neutral') {
                threatenedTerrs.add(t);
            }
        }
    }
    if (threatenedTerrs.size > 0) {
        // Sort threatened territories by priority: tax → most reinforcement reachable → most attackers nearby
        const threatenedList = [...threatenedTerrs].map(terr => {
            const movesToHere = moves.filter(m => m.to === terr);
            const maxReinforcement = movesToHere.reduce((mx, m) => Math.max(mx, m.movable), 0);
            const attackerCount = T[terr].adj.reduce((sum, adj) => {
                const b = G.board[adj];
                return (b?.owner && b.owner !== color && b.owner !== 'neutral')
                    ? sum + totalUnitCount(adj) : sum;
            }, 0);
            return { terr, tax: T[terr].tax||0, maxReinforcement, attackerCount, movesToHere };
        }).filter(t => t.movesToHere.length > 0); // only if reachable
        if (threatenedList.length > 0) {
            threatenedList.sort((a,b) =>
                b.tax - a.tax ||                          // highest tax first
                b.maxReinforcement - a.maxReinforcement || // most reinforcement available
                b.attackerCount - a.attackerCount          // most attackers (most urgent)
            );
            const best = threatenedList[0];
            // Among moves to this territory, pick the one that delivers the most units
            best.movesToHere.sort((a,b) => b.movable - a.movable);
            const m = best.movesToHere[0];
            return { from:m.from, to:m.to, movable:m.movable,
                reason:`Reinforce threatened ${m.to} (Tax ${T[m.to].tax||0}, ${best.attackerCount} attackers nearby)${m.hops===2?' — 2-step':''}` };
        }
    }

    // Priority 2: reinforce territory adjacent to highest-tax enemy city
    const enemyCities = ALL_CITIES
        .filter(c => G.board[c]?.owner && G.board[c].owner !== color && G.board[c].owner !== 'neutral')
        .sort((a,b) => T[b].tax - T[a].tax);

    for (const city of enemyCities) {
        // Moves that land adjacent to this city
        const frontlineMoves = moves.filter(m => T[city].adj.includes(m.to));
        if (!frontlineMoves.length) continue;
        frontlineMoves.sort((a,b) => b.movable - a.movable);
        const m = frontlineMoves[0];
        return { from:m.from, to:m.to, movable:m.movable,
            reason:`Reinforce near ${city} (Tax ${T[city].tax})${m.hops===2?' — 2-step maneuver':''}` };
    }

    // Priority 3: any legal maneuver (largest army to most useful position)
    moves.sort((a,b) => b.movable - a.movable);
    const m = moves[0];
    return { from:m.from, to:m.to, movable:m.movable,
        reason:`Reposition army${m.hops===2?' — 2-step maneuver':''}` };
}

// ================================================================
// BOARD UPDATES (called when turn is completed)
// ================================================================
function applyFortify(territory, count) {
    if (!G.board[territory]) return;
    G.board[territory].units.F += count;
    addLog(`FORTIFY: +${count} Footman placed at ${territory} (${count===4?'castle grants +4':'city grants +3'} free Footmen from reserve).`);
}

function applySpend(color, purchase, placements) {
    G.coins[color] = Math.max(0, G.coins[color] - purchase.cost);
    if (purchase.crownCard) {
        // Buying a Crown Card: track it separately, add 1 crown
        G.crownCards[color] = (G.crownCards[color]||0) + 1;
        addCrown(color, 1);
        addLog(`SPEND: ${cName(color)} purchased a Crown Card (+1 Crown, now ${G.crowns[color]||0} total). Crown Card held in reserve.`);
    }
    placements.forEach(p => {
        if (!G.board[p.territory]) return;
        if (p.type === 'castle') {
            G.board[p.territory].castle = true;
        } else if (p.type === 'siege') {
            G.board[p.territory].units.S++;
        } else if (p.type === 'units') {
            G.board[p.territory].units[p.unitType] = (G.board[p.territory].units[p.unitType]||0) + p.count;
        }
    });
}


function applyNonCombatMove(mv) {
    if (!mv || !G.board[mv.from] || !G.board[mv.to]) return;
    const mu = mv.movingUnits || {};
    const destOwner = G.board[mv.to].owner;
    const destUnits = unitTotal(G.board[mv.to].units);
    // Safety: if destination has enemy units, don't merge — this should have been queued as combat
    if (destOwner !== mv.color && destOwner !== 'neutral' && destUnits > 0) {
        addLog(`⚠ ${mv.color} tried to move into enemy ${mv.to} (${destOwner}) without combat — skipped. Check combat phase.`);
        return;
    }
    ['F','A','C','S'].forEach(k => {
        G.board[mv.from].units[k] = Math.max(0, (G.board[mv.from].units[k]||0) - (mu[k]||0));
    });
    const wasNeutral = (G.board[mv.to].owner === 'neutral');
    G.board[mv.to].owner = mv.color;
    ['F','A','C','S'].forEach(k => {
        G.board[mv.to].units[k] = (G.board[mv.to].units[k]||0) + (mu[k]||0);
    });
    // Award crown for capturing a city (any non-combat move into a neutral city)
    if (wasNeutral && (T[mv.to]?.tax||0) > 0) {
        const cv = crownValueOfCity(mv.to);
        if (cv > 0) {
            G.crowns[mv.color] = (G.crowns[mv.color]||0) + cv;
            addLog(`${cName(mv.color)} moves ${unitStr(mu)} from ${mv.from} to ${cityLabel(mv.to)}. ${cityLabel(mv.to)} is captured and ${cName(mv.color)} gains ${cv} Crown${cv>1?'s':''} (banner now at ${G.crowns[mv.color]}).`);
            checkWin(mv.color);
        } else {
            addLog(`${cName(mv.color)} moves ${unitStr(mu)} from ${mv.from} to ${mv.to}. ${mv.to} is now owned by ${cName(mv.color)}.`);
        }
        // Assign shield token for new city owner
        const sk = shieldKeyForTerr(mv.to);
        if (sk) {
            G.shields = G.shields || {};
            G.shields[sk] = mv.color;
            applyShieldBonus(sk, mv.color, 'capture');
        }
    } else {
        addLog(`${cName(mv.color)} moves ${unitStr(mu)} from ${mv.from} to ${mv.to} (${mv.type||'move'}).`);
    }
}
function applyMove(from, to, movingUnits, attackerWon, survivorCount, survivingColor) {
    if (!G.board[from] || !G.board[to]) return;
    // Subtract moving units from origin
    ['F','A','C','S'].forEach(k => {
        G.board[from].units[k] = Math.max(0, G.board[from].units[k] - (movingUnits[k]||0));
    });
    if (!attackerWon) {
        // Defender held — attacker units destroyed
        addLog(`COMBAT RESULT: Defender holds ${to} — all attacking units from ${from} eliminated.`);
        return;
    }
    // Attacker won — take territory
    G.board[to].owner = survivingColor;
    G.board[to].units = {F:0,A:0,C:0,S:0};
    // Place survivors (we don't know breakdown, so put them as footmen for now)
    G.board[to].units.F = survivorCount;
    addLog(`COMBAT RESULT: ${cName(survivingColor)} captures ${to} with ${survivorCount} surviving unit${survivorCount!==1?'s':''}.`);
}


function getBestSpend(coins, color) {
    // Berlin shield: castles cost 3 fewer coins — simulate by adding 3 to purchasing power
    // so the automa can access castle purchases it otherwise couldn't afford
    const berlinBonus = (color && G.shields?.['Berlin'] === color && color !== S.playerColor) ? 3 : 0;
    const effectiveCoins = coins + berlinBonus;
    const keys = Object.keys(SPEND_TABLE).map(Number).sort((a,b)=>b-a);
    const k = keys.find(k => k <= effectiveCoins);
    const result = k ? { cost:k, items:SPEND_TABLE[k] } : { cost:5, items:SPEND_TABLE[5] };
    // Adjust actual cost if a castle was in the purchase and Berlin discount applies
    if (berlinBonus > 0 && result.items.includes('Castle')) {
        result.cost = Math.max(result.cost - 3, 0);
        result._berlinDiscount = true;
    }
    return result;
}

// ================================================================
// SETUP STATE
// ================================================================
const S = {
    step:0, playerColor:null, firstAuto:null,
    autoCapitals:{}, playerCapital:null,
    autoSecondary:{}, playerSecondary:null,
    takenAdj:new Set(), shuffledCaps:[], coinsData:[]
};

function autoColors() { return ['orange','green','purple','blue'].filter(c=>c!==S.playerColor); }

// ================================================================
// SETUP WIZARD
// ================================================================
const TOTAL_STEPS = 7;

function showStep(n) {
    S.step = n;
    document.getElementById('wiz-step-label').textContent = `Step ${n+1} of ${TOTAL_STEPS}`;
    document.getElementById('wiz-progress').style.width = `${Math.round(((n+1)/TOTAL_STEPS)*100)}%`;
    const b = document.getElementById('wiz-body');
    [renderWelcome, renderChooseColor, renderAssignCapitals, renderPlaceAutos,
     renderPlayerCapital, renderSecondary, renderReady][n](b);
}

function wizNext() { showStep(S.step+1); }
function wizBack() { if(S.step>0) showStep(S.step-1); }

function renderWelcome(el) {
    el.innerHTML = `
        <div class="setup-title">Welcome, Commander</div>
        <div class="setup-sub">This app runs the <b>3 Automaton players</b> so you can play Risk Europe solo. It draws their cards and tells you exactly what to do on the board each turn.</div>
        <div class="info-box"><b>How it works:</b><br>
        • You play your own turns normally using the base game rules you already know.<br>
        • For each automaton turn, this app reveals their card and shows a <b>numbered checklist</b> of exactly what to move.<br>
        • Tap each step as you carry it out on the board. When all steps are done, tap <b>Complete Turn</b>.<br>
        • The app handles turn order, coin tracking, and deck reshuffling automatically.</div>
        <div class="info-box"><b>You win</b> by reaching 7 Crowns first. There are two crown components on the board:<br>• <b>Crown miniatures</b> — placed inside cities on the map. They mark that city as a crown city (worth 1 Crown when captured). They stay in the city permanently.<br>• <b>Colored banners on the Crown Track</b> — track your total crown score. Move your banner up when you capture a crown city or buy a Crown Card. This app tracks your banner position in the player bar.</div>
        <div class="info-box" style="border-color:var(--gold);background:rgba(200,149,42,0.08);">
            <b>⚠ Before you begin:</b><br>
            • <b>Kingdom Missions variant is NOT used.</b> Crown Cards stay in the deck face-down — when purchased they give 1 Crown exactly as printed. Do NOT use the mission side.<br>
            • Each player starts with their banner at <b>2 on the Crown Track</b> and places <b>1 Crown miniature in each of their 2 starting cities</b>. (Exception: if you start with Rome, your banner starts at 3 — the extra Crown comes from Rome's Shield token, not an extra miniature on the board.)
        </div>
        <button class="btn-primary" onclick="wizNext()">BEGIN SETUP →</button>
        ${renderWelcomeLoadSlots()}`;
}

function renderWelcomeLoadSlots() {
    const slots = ['Slot 1','Slot 2','Slot 3'];
    const saves = slots.map(s => {
        const raw = localStorage.getItem('riskEurope_save_' + s.replace(' ','_'));
        return raw ? { slot:s, ...JSON.parse(raw) } : null;
    }).filter(Boolean);
    if (!saves.length) return '';
    const cards = saves.map(d => `
        <div class="save-slot" style="margin-bottom:8px;">
            <div class="save-slot-info">
                <div class="slot-name">${d.slot}</div>
                <div class="slot-meta">Round ${d.round} · ${d.playerColor?.toUpperCase()} · ${d.savedAt}</div>
            </div>
            <div class="save-slot-btns">
                <button class="sl-btn load" onclick="slLoadFromWelcome('${d.slot}')">Load</button>
            </div>
        </div>`).join('');
    return `<div style="margin-top:18px;border-top:2px solid var(--border);padding-top:14px;">
        <div style="font-family:'Cinzel',serif;font-size:0.85em;font-weight:700;color:var(--ink);margin-bottom:10px;">&#x1F4BE; Continue a Previous Game</div>
        ${cards}
    </div>`;
}

function slLoadFromWelcome(slot) {
    const raw = localStorage.getItem('riskEurope_save_' + slot.replace(' ','_'));
    if (!raw) { alert('Save not found.'); return; }
    try {
        const data = JSON.parse(raw);
        const { G: savedG, S: savedS } = deserialiseState(data.state);
        Object.assign(G, savedG);
        Object.assign(S, savedS);
        document.getElementById('setup-screen').style.display = 'none';
        document.getElementById('game-screen').style.display  = 'block';
        document.getElementById('board-btn').style.display    = 'block';
        render();
        addLog('Game loaded from ' + slot + ' (Round ' + G.round + ').');
    } catch(e) {
        alert('Failed to load: ' + e.message);
    }
}

function renderChooseColor(el) {
    el.innerHTML = `
        <div class="setup-title">Choose Your Colour</div>
        <div class="setup-sub">Pick the colour you'll play. The other three become automatons.</div>
        <div class="color-grid">
            ${['orange','green','purple','blue'].map(c=>`
                <div class="color-choice ${S.playerColor===c?'selected':''}"
                     style="background:${COLOR_HEX[c]}" onclick="selectColor('${c}')">
                    ${c.toUpperCase()}
                </div>`).join('')}
        </div>
        <div id="col-confirm" style="${S.playerColor?'':'display:none'}">
            <div class="info-box">You are <b>${(S.playerColor||'').toUpperCase()}</b>. Automatons: <b>${autoColors().map(c=>c.toUpperCase()).join(', ')}</b>. You go <b>last</b> in Round 1.</div>
            <button class="btn-primary" onclick="wizNext()">CONFIRM →</button>
        </div>
        <button class="btn-secondary" onclick="wizBack()">← Back</button>`;
}

function selectColor(c) {
    S.playerColor = c;
    renderChooseColor(document.getElementById('wiz-body'));
}

function resolveAdj(capital) {
    for (const adj of capital.adjOptions) {
        if (!S.takenAdj.has(adj.name)) { S.takenAdj.add(adj.name); capital._adj = adj; return; }
    }
    capital._adj = capital.adjOptions[capital.adjOptions.length-1];
}

function renderCapCard(color, capital, isPrimary) {
    const adj = capital._adj || capital.adjOptions[0];

    const extra = isPrimary
        ? `<br>🏰 <b>1 Castle</b> on ${capital.name}${capital.city && capital.city !== capital.name ? ' (' + capital.city + ')' : ''}<br>👑 Place <b>1 Crown miniature</b> inside ${capital.city || capital.name} on the map<br>📍 Start banner at <b>2</b> on Crown Track (2nd miniature goes in secondary city at next step)`
        : `<br><span style="color:#888;font-style:italic;">No castle on secondary capital.</span>`;
    return `<div class="capital-card">
        <div class="cap-header"><div class="cap-dot" style="background:${COLOR_HEX[color]}"></div>
        <div class="cap-name">${color.toUpperCase()} — ${capital.name}</div></div>
        <div class="cap-body">
            📍 <b>${capital.name}:</b> place <b>${capital.units} Footmen</b><br>
            📍 <b>${adj.name}:</b> place <b>${adj.units} Footmen</b>
            ${extra}
        </div></div>`;
}

function renderAssignCapitals(el) {
    const autos = autoColors();
    if (!S.shuffledCaps.length) S.shuffledCaps = shuffle([...CAPITALS]);
    S.takenAdj = new Set();
    autos.forEach((color, i) => {
        S.autoCapitals[color] = S.shuffledCaps[i];
        resolveAdj(S.shuffledCaps[i]);
    });
    el.innerHTML = `
        <div class="setup-title">Automaton Capitals</div>
        <div class="setup-sub">Capitals have been randomly assigned. Place each automaton's starting forces on the board now.</div>
        ${autos.map(c => renderCapCard(c, S.autoCapitals[c], true)).join('')}
        <div class="info-box">Each automaton also receives <b>5 starting coins</b> (plus tax income — we'll calculate the total in a later step).</div>
        <button class="btn-primary" onclick="wizNext()">UNITS PLACED ON BOARD →</button>
        <button class="btn-secondary" onclick="reshuffleCapitals()">🔀 Re-Randomise Capitals</button>
        <button class="btn-secondary" onclick="wizBack()">← Back</button>`;
}

function reshuffleCapitals() {
    S.shuffledCaps = shuffle([...CAPITALS]);
    renderAssignCapitals(document.getElementById('wiz-body'));
}

function renderPlaceAutos(el) {
    const autos = autoColors();
    el.innerHTML = `
        <div class="setup-title">Who Goes First?</div>
        <div class="setup-sub">In Round 1 you go last. Which automaton is sitting to your <b>left</b>? They take the First Player marker and go first.</div>
        <div class="cap-chooser" id="first-picker">
            ${autos.map(c=>`<div class="cap-btn ${S.firstAuto===c?'selected':''}" onclick="pickFirst('${c}')">
                ${c.toUpperCase()}<div class="cap-tax">to your left</div></div>`).join('')}
        </div>
        <div id="first-confirm" style="${S.firstAuto?'':'display:none'}">
            <div class="info-box"><b>${(S.firstAuto||'').toUpperCase()}</b> holds the First Player marker and goes first each round (until a KING ME card transfers it).</div>
            <button class="btn-primary" onclick="wizNext()">CONTINUE →</button>
        </div>
        <button class="btn-secondary" onclick="wizBack()">← Back</button>`;
}

function pickFirst(c) {
    S.firstAuto = c;
    renderPlaceAutos(document.getElementById('wiz-body'));
}

function renderPlayerCapital(el) {
    const taken = new Set(autoColors().map(c=>S.autoCapitals[c].name));
    const available = CAPITALS.filter(c=>!taken.has(c.name));
    el.innerHTML = `
        <div class="setup-title">Your Capital</div>
        <div class="setup-sub">Choose one of the remaining capitals for <b>${(S.playerColor||'').toUpperCase()}</b>. Place your units and Castle, then place <b>1 Crown miniature</b> inside this city on the map.</div>
        <div class="cap-chooser">
            ${available.map(cap=>{
                const sk_ = shieldKeyForTerr(cap.name);
                const citySpan_ = cap.city && cap.city !== cap.name
                    ? '<br><span style="font-size:0.72em;font-weight:400;' + (sk_ ? 'color:#c8960c;font-weight:700;' : 'color:var(--ink-light);') + '">' + cap.city + (sk_ ? ' 🛡' : '') + '</span>'
                    : '';
                const label = cap.name + citySpan_;
                const sel = S.playerCapital && S.playerCapital.name === cap.name ? 'selected' : '';
                return `<div class="cap-btn ${sel}" onclick="pickPlayerCap('${cap.name}')">${label}<div class="cap-tax">Tax: ${cap.tax}</div></div>`;
            }).join('')}
        </div>
        <div id="player-cap-detail">${S.playerCapital ? renderPlayerCapDetail() : ''}</div>
        <button class="btn-secondary" onclick="wizBack()">← Back</button>`;
}

function renderPlayerCapDetail() {
    const cap = S.playerCapital; if (!cap) return '';
    const adj = cap._adj || cap.adjOptions[0];
    const primary = S.playerPrimaryUnits !== undefined ? S.playerPrimaryUnits : 3;
    const adjUnits = Math.max(0, 5 - primary);
    return `<div class="capital-card">
        <div class="cap-header"><div class="cap-dot" style="background:${COLOR_HEX[S.playerColor]}"></div>
        <div class="cap-name">${(S.playerColor||'').toUpperCase()} — ${cap.name}</div></div>
        <div class="cap-body">
            🏰 <b>1 Castle</b> on ${cap.name}${cap.city && cap.city !== cap.name ? ' (' + cap.city + ')' : ''}<br>👑 Place <b>1 Crown miniature</b> inside ${cap.city || cap.name} on the map — your 2nd miniature goes in your secondary city (assigned next step)<br>🏅 Start your banner at <b>2 on the Crown Track</b><br><br>
            <b>How many Footmen at ${cap.name}?</b><br>
            <div style="display:flex;align-items:center;gap:10px;margin:8px 0;">
                <button class="ub" style="width:28px;height:28px;font-size:16px" onclick="changePlayerUnits(-1)">−</button>
                <span style="font-family:Cinzel,serif;font-size:1.4em;font-weight:700;min-width:30px;text-align:center">${primary}</span>
                <button class="ub" style="width:28px;height:28px;font-size:16px" onclick="changePlayerUnits(1)">+</button>
                <span style="color:var(--ink-light);font-size:0.9em;">at ${cap.name}</span>
            </div>
            <div style="color:var(--ink-light);font-size:0.88em;">Remaining <b>${adjUnits}</b> Footmen → ${adj.name}</div>
            <span class="cap-note">Total = 5 Footmen across both territories.</span>
        </div></div>
        <button class="btn-primary" onclick="wizNext()">UNITS PLACED →</button>`;
}
function changePlayerUnits(v) {
    S.playerPrimaryUnits = Math.max(0, Math.min(5, (S.playerPrimaryUnits||3) + v));
    renderPlayerCapital(document.getElementById('wiz-body'));
}

function pickPlayerCap(name) {
    S.playerCapital = CAPITALS.find(c=>c.name===name);
    resolveAdj(S.playerCapital);
    renderPlayerCapital(document.getElementById('wiz-body'));
}

function renderSecondary(el) {
    const autos = autoColors();
    const fi = S.firstAuto || autos[0];
    const orderedAutos = [fi, ...autos.filter(c=>c!==fi)];
    const takenNames = new Set([...autos.map(c=>S.autoCapitals[c].name), S.playerCapital?.name].filter(Boolean));
    const remaining = CAPITALS.filter(c=>!takenNames.has(c.name));
    const assignOrder = [...orderedAutos, S.playerColor];
    S.autoSecondary = {}; S.playerSecondary = null;
    assignOrder.forEach((color, i) => {
        const cap = remaining[i];
        if (!cap) return;
        if (color === S.playerColor) S.playerSecondary = cap;
        else S.autoSecondary[color] = cap;
    });
    const coinsData = [...autos, S.playerColor].map(color => {
        const primary   = color === S.playerColor ? S.playerCapital     : S.autoCapitals[color];
        const secondary = color === S.playerColor ? S.playerSecondary   : S.autoSecondary[color];
        return { color, primary, secondary, total: 5+(primary?.tax||0)+(secondary?.tax||0) };
    });
    S.coinsData = coinsData;
    el.innerHTML = `
        <div class="setup-title">Secondary Capitals & Starting Coins</div>
        <div class="setup-sub">The remaining ${remaining.length} capitals are now distributed — same unit placement, but <b>no castle</b>. Each player's coin total is shown below.</div>
        ${coinsData.map(d=>`<div class="capital-card">
            <div class="cap-header"><div class="cap-dot" style="background:${COLOR_HEX[d.color]}"></div>
            <div class="cap-name">${d.color.toUpperCase()}</div></div>
            <div class="cap-body">
                🏛 <b>Primary:</b> ${d.primary?.name||'?'} (Tax ${d.primary?.tax||'?'})<br>
                🏛 <b>Secondary:</b> ${d.secondary?.name||'?'} (Tax ${d.secondary?.tax||'?'}) <i>— no castle</i><br>
                💰 <b>Starting coins: 5 + ${d.primary?.tax||0} + ${d.secondary?.tax||0} = <span style="color:var(--accent);font-size:1.1em;">${d.total}</span></b>
            </div></div>`).join('')}
        <div class="info-box">
            <b>For each player's secondary city:</b><br>
            • Place <b>3 Footmen</b> in the secondary capital territory (no castle)<br>
            • Place <b>2 Footmen</b> in the one adjacent territory shown above for each player<br>
            • Place <b>1 Crown miniature</b> inside the secondary city on the map<br><br>
            <b>Crown Track banners:</b> Set each player's banner to <b>2</b>. Exception: the player whose <em>primary</em> capital is <b>Rome</b> starts at <b>3</b> (Rome's Shield token grants +1 Crown).<br><br>
            <b>Reserves (keep off-board):</b> Give each player 10 Footmen, 4 Archers, 4 Cavalry, 2 Siege Engines.<br>
            <b>Starting coins:</b> Set each player's coins as shown above.
        </div>
        <button class="btn-primary" onclick="launchGame()">✓ SETUP COMPLETE — START GAME →</button>
        <button class="btn-secondary" onclick="wizBack()">← Back</button>`;
}

function renderReady(el) { launchGame(); }

// ================================================================
// GAME STATE & INIT
// ================================================================

// ── Gold City Shield Abilities ──────────────────────────────────
// These are the special abilities granted by Tax-4 cities' shields
// City Shield abilities — each starting city has a shield token with a special ability.
// trigger: 'tax'|'spend'|'battle_win'|'expand'|'always'|'expand_spend'
// crownBonus: extra crowns when captured (Rome only)
const CITY_SHIELDS = {
    // Keys are CITY names (for G.shields lookups and display)
    // terr: corresponding territory key in T[] and G.board
    "Paris":          { terr:"France",        trigger:'tax',          crownBonus:0, reminder:"🛡 PARIS SHIELD: You taxed Paris — place 1 Cavalry + 1 Footman in France (Paris) for FREE." },
    "Stockholm":      { terr:"Sweden",        trigger:'battle_win',   crownBonus:0, reminder:"🛡 STOCKHOLM SHIELD: You won as attacker — collect 4 silver coins from the reserve." },
    "Rome":           { terr:"Rome",          trigger:'always',       crownBonus:1, reminder:"🛡 ROME SHIELD: Rome is worth 2 crowns (already applied)." },
    "Berlin":         { terr:"Saxony",        trigger:'expand_spend', crownBonus:0, reminder:"🛡 BERLIN SHIELD: After Expanding, you may also Maneuver this action. Also: Castles cost 3 fewer coins." },
    "Constantinople": { terr:"Turkey",        trigger:'spend',        crownBonus:0, reminder:"🛡 CONSTANTINOPLE SHIELD: You recruited a Siege Engine — place 4 Footmen with it for FREE." },
    "Kiev":           { terr:"Rusland",       trigger:'spend',        crownBonus:0, reminder:"🛡 KIEV SHIELD: You may recruit army units into any non-city territory connected to Kiev by a supply line." },
    "Madrid":         { terr:"León Castile",  trigger:'tax',          crownBonus:0, reminder:"🛡 MADRID SHIELD: You taxed Madrid — place 4 Footmen in León Castile (Madrid) for FREE." },
    "London":         { terr:"England",       trigger:'tax',          crownBonus:0, reminder:"🛡 LONDON SHIELD: You taxed London — place 2 Archers in England (London) for FREE." },
};

function showShieldReminder(city, color) {
    const sh = CITY_SHIELDS[city];
    if (!sh || !sh.reminder) return;
    if (!G.shields || G.shields[city] !== color) return;
    if (color === S.playerColor) {
        addLog(sh.reminder);
        const toast = document.createElement('div');
        toast.style.cssText = 'position:fixed;bottom:80px;left:50%;transform:translateX(-50%);background:#8b1a1a;color:white;padding:12px 18px;border-radius:8px;font-family:Cinzel,serif;font-size:0.82em;font-weight:700;z-index:500;max-width:340px;text-align:center;box-shadow:0 4px 20px rgba(0,0,0,0.6);';
        toast.textContent = sh.reminder;
        document.body.appendChild(toast);
        setTimeout(()=>toast.remove(), 6000);
    }
    // Automa: no reminder needed — effect applied automatically by applyShieldBonus
}

// Apply city shield bonus automatically for an automa (no-op for human — they get a reminder instead)
function applyShieldBonus(city, color, context) {
    if (!G.shields || G.shields[city] !== color) return;
    if (color === S.playerColor) return; // human handles manually via reminder
    const sh = CITY_SHIELDS[city];
    if (!sh) return;

    // Look up territory for this city (shield key → territory board key)
    const _sh = CITY_SHIELDS[city];
    const _terr = _sh?.terr || city; // "France" for Paris, "Turkey" for Constantinople, etc.

    if (city === 'Paris' && context === 'tax') {
        G.board[_terr].units.C = (G.board[_terr].units.C||0) + 1;
        G.board[_terr].units.F = (G.board[_terr].units.F||0) + 1;
        addLog(`🛡 Paris shield: ${cName(color)} receives 1 free Cavalry + 1 Footman in France (Paris).`);
    } else if (city === 'Madrid' && context === 'tax') {
        G.board[_terr].units.F = (G.board[_terr].units.F||0) + 4;
        addLog(`🛡 Madrid shield: ${cName(color)} receives 4 free Footmen in León Castile (Madrid).`);
    } else if (city === 'London' && context === 'tax') {
        G.board[_terr].units.A = (G.board[_terr].units.A||0) + 2;
        addLog(`🛡 London shield: ${cName(color)} receives 2 free Archers in England (London).`);
    } else if (city === 'Constantinople' && context === 'siege_buy') {
        // Free 4 Footmen placed with the siege engine (find territory with freshest siege engine)
        const siegeTerr = ownedBy(color).filter(n => G.board[n].units.S > 0)
            .sort((a,b) => G.board[b].units.S - G.board[a].units.S)[0];
        if (siegeTerr) {
            G.board[siegeTerr].units.F = (G.board[siegeTerr].units.F||0) + 4;
            addLog(`🛡 Constantinople shield: ${cName(color)} receives 4 free Footmen at ${cityLabel(siegeTerr)}.`);
        }
    } else if (city === 'Kiev' && context === 'spend') {
        // Automa: place 2 extra Footmen in highest-unit non-city territory connected to Rusland (Kiev)
        if (G.board[_terr]?.owner !== color) return;
        const visited = new Set([_terr]);
        const queue = [_terr];
        let bestNonCity = null, bestCount = -1;
        while (queue.length) {
            const cur = queue.shift();
            for (const adj of (T[cur]?.adj || [])) {
                if (!visited.has(adj) && G.board[adj]?.owner === color) {
                    visited.add(adj); queue.push(adj);
                    if (T[adj].tax === 0) {
                        const cnt = totalUnitCount(adj);
                        if (cnt > bestCount) { bestCount = cnt; bestNonCity = adj; }
                    }
                }
            }
        }
        if (bestNonCity) {
            G.board[bestNonCity].units.F = (G.board[bestNonCity].units.F||0) + 2;
            addLog(`🛡 Kiev shield: ${cName(color)} places 2 extra Footmen at ${bestNonCity} (supply line).`);
        }
    } else if (city === 'Stockholm' && context === 'battle_win') {
        // 4 free coins
        G.coins[color] = (G.coins[color]||0) + 4;
        addLog(`🛡 Stockholm shield: ${cName(color)} collects 4 coins from the reserve.`);
        render();
    }
    // Berlin: extra maneuver after expand — handled in generateSteps / advanceTurn
    // Rome: crown bonus already handled in crownValueOfCity / applyBattleResult
}

function crownValueOfCity(name) {
    // Rome is worth 2 crowns (1 regular + 1 bonus from shield)
    return CITY_SHIELDS[name]?.crownBonus ? 1 + CITY_SHIELDS[name].crownBonus : (T[name]?.tax > 0 ? 1 : 0);
}

let G = {};

function launchGame() {
    const autos = autoColors();
    const fi = S.firstAuto || autos[0];
    const seating = [fi, ...autos.filter(c=>c!==fi), S.playerColor];
    const coins = {};
    S.coinsData.forEach(d => { coins[d.color] = d.total; });
    const crowns = {};
    const shields = {}; // shields[cityName] = color that owns it
    ['orange','green','purple','blue'].forEach(c => { crowns[c] = 2; }); // all start with 2 crowns
    // Apply shield ownership and crown bonuses for starting capitals
    const allCaps = { ...Object.fromEntries(autos.map(a=>[a, S.autoCapitals[a]?.name])), [S.playerColor]: S.playerCapital?.name };
    Object.entries(allCaps).forEach(([c, terrName]) => {
        const sk = shieldKeyForTerr(terrName);
        if (sk) {
            shields[sk] = c;                         // key is always city name
            if (CITY_SHIELDS[sk].crownBonus) {
                crowns[c] += CITY_SHIELDS[sk].crownBonus;
            }
        }
    });
    G = {
        round:1, step:1, slot:0,
        firstPlayer:fi, pendingFirst:null,
        seating, decks:{}, hand:{}, coins, crowns, shields,
        crownCards:   Object.fromEntries(seating.map(c=>[c,0])),  // purchased Crown Cards held
        eliminated:   new Set(),   // colors permanently out of the game
        savedByCrown: new Set(),   // colors on their one-round grace period
        revealed:false, pendingMoves:[], currentSteps:[], checkedSteps:new Set(),
        humanTurnChecks:new Set(), humanBoardUpdated:false, humanSpendCart:{F:0,A:0,C:0,S:0,Castle:0},
        humanDeck:[], humanDiscard:[], humanCard:null, humanVariant:null, humanFlow:[], _humanCardPending:null, _humanVariantPending:null,
        roundCombats:[],
        logHistory:[]
    };
    autos.forEach(c => { G.decks[c]=[]; G.hand[c]=[]; });
    G.humanDeck = shuffle([...DECK_BASE]);
    G.humanDiscard = [];
    G.humanCard = null;
    initBoard();
    prepareRound(true);
    addLog('=== GAME STARTED — Round 1 begins. Good luck! ===');
    document.getElementById('setup-screen').style.display = 'none';
    document.getElementById('game-screen').style.display  = 'block';
    document.getElementById('board-btn').style.display = 'block';
    render();
}

function shuffle(arr) {
    const a=[...arr];
    for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}
    return a;
}
function autoColors_g() { return G.seating.filter(c=>c!==S.playerColor && !(G.eliminated||new Set()).has(c)); }
function cName(c) { return c===S.playerColor ? 'You' : c.charAt(0).toUpperCase()+c.slice(1); }
function cAttacks(c) { return c===S.playerColor ? 'You attack' : cName(c)+' attacks'; }

function refillDeck(c) { G.decks[c]=shuffle([...DECK_BASE]); addLog(`DECK: ${cName(c)} card deck exhausted and reshuffled.`); }

function prepareRound(silent=false) {
    G.roundCombats = []; // fresh each round
    if (G.pendingFirst !== null) {
        G.firstPlayer = G.pendingFirst; G.pendingFirst = null;
        const fi = G.firstPlayer;
        G.seating = [fi, ...G.seating.filter(c=>c!==fi)];
        G.slot = 0;
        if(!silent) addLog(`ROUND START: ${cName(fi)} is now First Player — turn order updated.`);
    }
    autoColors_g().forEach(c => {
        // Draw 2 cards — reshuffle mid-draw if deck runs out (don't discard remaining card)
        const card1 = G.decks[c].length > 0 ? G.decks[c].pop() : (refillDeck(c), G.decks[c].pop());
        if (G.decks[c].length === 0) refillDeck(c);
        const card2 = G.decks[c].pop();
        G.hand[c] = [card1, card2];
    });
    if(!silent) addLog(`--- Round ${G.round} begins. Cards dealt to all automatons. ---`);
}

function getTurnOrder() {
    const si = G.seating.indexOf(G.firstPlayer);
    const all = [0,1,2,3].map(i=>G.seating[(si+i)%4]);
    return all.filter(c => !(G.eliminated||new Set()).has(c));
}
function activeColor() {
    const order = getTurnOrder();
    return order[G.slot % order.length];
}

function addLog(msg) {
    G.logHistory.unshift(msg);
    const el = document.getElementById('action-log');
    if(el) el.innerHTML = G.logHistory.slice(0,3).map((m,i)=>
        `<div class="log-entry ${i>0?'old':''}">${i===0?'▶ ':'  '}${m}</div>`).join('');
}

function addCoin(c, v) {
    G.coins[c] = Math.max(0, G.coins[c]+v);
    render();
    // Never regenerate steps mid-turn — steps are locked once revealed
}

// Remove all units from board for a color
function eliminatePlayer(color) {
    if (G.eliminated.has(color)) return;
    G.eliminated.add(color);
    G.savedByCrown.delete(color);
    // Wipe all units and ownership
    for (const name of Object.keys(G.board)) {
        if (G.board[name].owner === color) {
            G.board[name].owner = 'neutral';
            G.board[name].units = {F:0,A:0,C:0,S:0};
            // Castle stays — rule says return "City Bonus Tiles and coins", not castles explicitly;
            // but to keep board clean, remove the castle too
            G.board[name].castle = false;
        }
    }
    // Return coins to reserve (just zero out)
    G.coins[color] = 0;
    // Crown Cards are removed from game (NOT returned to reserve) — remove them from crownCards
    // but crowns from city captures stay removed (crowns are never returned)
    const cards = G.crownCards[color] || 0;
    if (cards > 0) {
        G.crownCards[color] = 0;
        // The crown tracker stays where it is — the banner just stays at that value, representing removed cards
        addLog(`${cName(color)}'s ${cards} Crown Card${cards>1?'s':''} removed from game.`);
    }
    const isHuman = color === S.playerColor;
    const who = isHuman ? 'YOU are' : cName(color) + ' is';
    addLog(`💀 ${who} ELIMINATED — no cities and no crowns remaining.`);
    if (isHuman) {
        setTimeout(() => {
            const el = document.getElementById('winner-overlay') || (() => {
                const d = document.createElement('div'); d.id = 'winner-overlay';
                d.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;z-index:1000;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.88);';
                document.body.appendChild(d); return d;
            })();
            el.innerHTML = `<div style="background:var(--parchment);border:4px solid #8b1a1a;border-radius:12px;
                padding:36px 28px;max-width:360px;width:90%;text-align:center;">
                <div style="font-size:3em;margin-bottom:8px;">💀</div>
                <div style="font-family:Cinzel,serif;font-size:1.4em;font-weight:700;color:#8b1a1a;margin-bottom:8px;">YOU HAVE BEEN ELIMINATED</div>
                <div style="font-size:0.9em;color:var(--ink-light);margin-bottom:24px;">No cities and no crowns remaining.</div>
                <button onclick="confirmReset()" style="background:#8b1a1a;color:#fff;border:none;border-radius:8px;
                    padding:13px 28px;font-family:Cinzel,serif;font-size:1em;font-weight:700;cursor:pointer;width:100%;">
                    ↺ New Game
                </button>
            </div>`;
            el.style.display = 'flex';
        }, 200);
    }
    render();
}

// Check all players for elimination at end of round
function checkElimination() {
    const allColors = G.seating;
    for (const c of allColors) {
        if (G.eliminated.has(c)) continue;
        const cities = ownedBy(c).filter(n => T[n].tax > 0);
        if (cities.length > 0) {
            // Has cities — safe. Clear any grace period.
            if (G.savedByCrown.has(c)) {
                G.savedByCrown.delete(c);
                addLog(`SAVED BY THE CROWN: ${cName(c)} reclaimed ${ownedBy(c).filter(n=>T[n].tax>0).map(cityLabel).join(', ')} — grace period ended.`);
            }
            continue;
        }
        // No cities
        const crowns = G.crowns[c] || 0;
        const cards  = G.crownCards[c] || 0;
        if (G.savedByCrown.has(c)) {
            // Already had grace period — now eliminate
            eliminatePlayer(c);
        } else if (crowns === 0) {
            // No cities, no crowns — immediate elimination
            eliminatePlayer(c);
        } else if (cards > 0) {
            // No cities but has Crown Card(s) — Saved by the Crown (one more round)
            G.savedByCrown.add(c);
            addLog(`🛡 SAVED BY THE CROWN: ${cName(c)} has no cities but holds ${cards} Crown Card${cards>1?'s':''}. One more round to reclaim a city!`);
        } else {
            // No cities, has crowns from captures but no crown cards — eliminate
            // (Saved by the Crown specifically requires owning a Crown Card tile)
            eliminatePlayer(c);
        }
    }
}
function checkWin(c) {
    if (!G.crowns) return;
    if ((G.crowns[c]||0) >= 7 && !G.winner) {
        G.winner = c;
        // Show winner banner — defer slightly so any current render finishes first
        setTimeout(showWinnerScreen, 50);
    }
}

function showWinnerScreen() {
    const c = G.winner;
    if (!c) return;
    const isHuman = c === S.playerColor;
    const hex = COLOR_HEX[c] || '#888';
    const light = ['orange','green','blue'].includes(c);
    const txt = light ? '#000' : '#fff';
    const who = isHuman ? 'YOU WIN!' : cName(c).toUpperCase() + ' WINS!';
    const sub = isHuman
        ? `You reached ${G.crowns[c]} crowns. Congratulations!`
        : `${cName(c)} reached ${G.crowns[c]} crowns.`;

    // Overlay the entire screen
    let el = document.getElementById('winner-overlay');
    if (!el) {
        el = document.createElement('div');
        el.id = 'winner-overlay';
        el.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;z-index:1000;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.88);';
        document.body.appendChild(el);
    }
    el.innerHTML = `<div style="background:var(--parchment);border:4px solid ${hex};border-radius:12px;
        padding:36px 28px;max-width:360px;width:90%;text-align:center;box-shadow:0 0 60px ${hex}88;">
        <div style="font-size:3em;margin-bottom:8px;">👑</div>
        <div style="font-family:Cinzel,serif;font-size:1.6em;font-weight:700;color:${hex};margin-bottom:8px;">${who}</div>
        <div style="font-size:1em;color:var(--ink-light);margin-bottom:24px;">${sub}</div>
        <button onclick="confirmReset()" style="background:${hex};color:${txt};border:none;border-radius:8px;
            padding:13px 28px;font-family:Cinzel,serif;font-size:1em;font-weight:700;cursor:pointer;width:100%;">
            ↺ New Game
        </button>
    </div>`;
    el.style.display = 'flex';
}
function addCrown(c, v) {
    if (!G.crowns) G.crowns = {};
    G.crowns[c] = Math.max(0, (G.crowns[c]||0) + v);
    checkWin(c);
    render();
}

function setFirst(c) {
    G.pendingFirst = c;
    addLog(`${cName(c)} will be First Player next round (KING ME pending).`);
    render();
}



function toggleRef(id) {
    const body=document.getElementById(id);
    const btn=body.previousElementSibling;
    body.classList.toggle('open'); btn.classList.toggle('open');
}

// ================================================================
// REVEAL & STEPS
// ================================================================
function revealAction() {
    if (G.winner) { showWinnerScreen(); return; }
    const color = activeColor();
    const card  = G.hand[color]?.[G.step-1];
    if(!card) { addLog('No card available.'); return; }
    const cardEl = document.getElementById('card-display');
    cardEl.className = 'action-card revealed';
    cardEl.innerHTML = card+`<div class="card-sub">${cName(color)} · ${G.coins[color]} coins</div>`;
    G.revealed = true;
    document.getElementById('reveal-btn').style.display = 'none';
    addLog(`${cName(color)}: "${card}" (${G.coins[color]} coins)`);
    regenerateSteps(card, color);
}

function regenerateSteps(card, color) {
    G._stepCoinEffects = {};
    resetStuckTimer();
    try {
        G.currentSteps = generateSteps(card, color, G.coins[color]);
    } catch(e) {
        console.error('generateSteps crashed:', e);
        G.currentSteps = [
            `<b>⚠ Step generation error for "${card}".</b> You can still complete this turn manually. Error: ${e.message}`
        ];
    }
    if (!G.currentSteps || !G.currentSteps.length) {
        G.currentSteps = [`<b>${card}</b> — no specific steps generated. Resolve per rulebook, then complete turn.`];
    }
    G.checkedSteps = new Set();
    try { renderSteps(); } catch(e) { console.error('renderSteps crashed:', e); }
    const btn = document.getElementById('complete-btn');
    if (btn) btn.disabled = true;
}

function toggleStep(i) {
    if(G.currentSteps[i] === null) return; // divider — not toggleable
    const wasChecked = G.checkedSteps.has(i);
    if(wasChecked) G.checkedSteps.delete(i); else G.checkedSteps.add(i);

    // Auto-apply effects when step is checked/unchecked
    if(G._stepCoinEffects && G._stepCoinEffects[i] !== undefined) {
        const effect = G._stepCoinEffects[i];
        const color = activeColor();
        if(typeof effect === 'string' && effect.startsWith('kingme:')) {
            // KING ME: queue or unqueue first player change
            const kingColor = effect.split(':')[1];
            if(!wasChecked) {
                G.pendingFirst = kingColor;
                addLog(`${cName(kingColor)} will be First Player next round.`);
            } else {
                G.pendingFirst = null;
            }
        } else {
            const delta = Number(effect);
            if(!wasChecked) {
                G.coins[color] = Math.max(0, G.coins[color] + delta);
                // Tax shield: fires when tax step is checked (delta > 0 = we just collected tax)
                if (delta > 0) {
                    const taxCity = G.pendingMoves?.find(m=>m.type==='tax')?.city;
                    if (taxCity) applyShieldBonus(shieldKeyForTerr(taxCity) || taxCity, color, 'tax');
                }
            } else {
                G.coins[color] = Math.max(0, G.coins[color] - delta);
            }
        }
        render();
    }

    renderSteps();
    const checkableCount = G.currentSteps.filter(s=>s!==null).length;
    const _cb1 = document.getElementById('complete-btn');
    if(_cb1) _cb1.disabled = (G.checkedSteps.size < checkableCount);
}

function renderSteps() {
    const panel=document.getElementById('steps-panel');
    const list=document.getElementById('steps-list');
    if(!panel || !list) return; // DOM not ready
    if(!G.currentSteps || !G.currentSteps.length) { panel.style.display='none'; return; }
    panel.style.display='block';
    const color=activeColor();
    const header=document.getElementById('steps-header');
    header.textContent=`STEPS TO PERFORM — ${color.toUpperCase()}`;
    header.style.background=COLOR_HEX[color]||'var(--accent)';
    const checkable = G.currentSteps.filter(s=>s!==null).length;
    const pct = checkable ? Math.round((G.checkedSteps.size/checkable)*100) : 0;
    document.getElementById('steps-progress-fill').style.width = pct+'%';
    let stepNum = 0;
    list.innerHTML = G.currentSteps.map((s,i)=>{
        if(s === null) {
            return `<div class="step-divider">2nd Action — Expand or Maneuver</div>`;
        }
        stepNum++;
        const checked=G.checkedSteps.has(i);
        return `<div class="step-item ${checked?'checked':''}" onclick="toggleStep(${i})">
            <div class="step-checkbox">${checked?'✓':''}</div>
            <div class="step-num">${stepNum}</div>
            <div class="step-text">${s}</div>
        </div>`;
    }).join('');
}

// ================================================================
// STEP GENERATOR
// ================================================================
function generateSteps(card, color, coins) {
    const C = cName(color);
    const steps = [];
    // Reset pending move queue and coin effects for this turn
    G.pendingMoves = [];
    G.pendingMove = null; // legacy — points to last move for combat dialog use
    G._stepCoinEffects = {};

    // EXPAND block is only built for cards that include a movement action.
    // TAX OR SPEND and KING ME / TAX OR SPEND never move — building it early
    // was causing phantom moves to be queued in pendingMoves and applied silently.
    function buildExpandBlock() {
        const expandDec  = decideExpand(color);
        const maneuverDec = decideManeuver(color);
        const posDec     = decidePosition(color);
        let EXPAND;
        if (expandDec) {
            const leave = leaveBehindCount(expandDec.from);
            const moving = unitsToMove(expandDec.from, expandDec.movable, expandDec.hasCastle);
            const leaveUnits = unitsToLeave(expandDec.from, leave);
            G.pendingMove = { type:'expand', color, from:expandDec.from, to:expandDec.to,
                movingUnits:moving, movable:expandDec.movable, isEnemy:expandDec.isEnemy };
            G.pendingMoves.push(G.pendingMove);
            const moveDetail = `Move <b>${unitStr(moving)}</b> from <b>${expandDec.from}</b> → <b>${expandDec.to}</b>`;
            const leaveDetail = `Leave <b>${unitStr(leaveUnits)}</b> at ${expandDec.from}`;
            const combatStep = expandDec.isEnemy ? renderCombatDialog(G.pendingMove) : null;
            const hasBerlinShield = CITY_SHIELDS['Berlin']?.trigger === 'expand_spend' && G.shields?.['Berlin'] === color;
            const berlinReminder = hasBerlinShield
                ? `<div class="shield-reminder">${color === S.playerColor ? CITY_SHIELDS['Berlin'].reminder : '🛡 BERLIN SHIELD: ' + cName(color) + ' expands then also maneuvers (bonus action). Castles cost 3 fewer coins.'}</div>`
                : null;
            if (hasBerlinShield && color !== S.playerColor) {
                const bonusManeuver = decideManeuver(color);
                if (bonusManeuver) {
                    const bmMoving = unitsToMove(bonusManeuver.from, bonusManeuver.movable, false);
                    G.pendingMoves.push({ type:'maneuver', color, from:bonusManeuver.from, to:bonusManeuver.to, movingUnits:bmMoving, _berlinBonus:true });
                }
            }
            EXPAND = [
                `<b>EXPAND:</b> ${moveDetail}.<br>${leaveDetail} (leave-behind rule: ${T[expandDec.from].tax>0?'Tax value '+T[expandDec.from].tax:'1 unit for non-urban'}).
                 <span class="rule-note">Target: ${expandDec.to} (Tax ${expandDec.tax}${expandDec.isEnemy?', ENEMY: '+expandDec.defenders+' defenders':', '+(G.board[expandDec.to].owner==='neutral'?'neutral':'friendly')+'.'})${expandDec.hasCastle?' ⚠ Has castle — Siege Engine required.':''}</span>`,
                ...(berlinReminder ? [berlinReminder] : []),
                ...(combatStep ? [combatStep] : []),
            ];
        } else if (posDec) {
            const posMoving = unitsToMove(posDec.from, posDec.movable, false);
            G.pendingMove = { type:'position', color, from:posDec.from, to:posDec.to, movingUnits:posMoving };
            G.pendingMoves.push(G.pendingMove);
            EXPAND = [
                `<b>NO DIRECT CITY ENTRY POSSIBLE — POSITION:</b> Move <b>${unitStr(posMoving)}</b> from <b>${posDec.from}</b> → <b>${posDec.to}</b> (moving toward <b>${posDec.toward}</b>).
                <span class="rule-note">Leave-behind: ${T[posDec.from].tax>0?'Tax value '+T[posDec.from].tax+' units':'1 unit'} at ${posDec.from}.</span>`,
            ];
        } else if (maneuverDec) {
            const moving = unitsToMove(maneuverDec.from, maneuverDec.movable, false);
            G.pendingMove = { type:'maneuver', color, from:maneuverDec.from, to:maneuverDec.to, movingUnits:moving };
            G.pendingMoves.push(G.pendingMove);
            const hopsNote = maneuverDec.reason?.includes('2-step') ? ' (2-step move through own territory)' : '';
            EXPAND = [
                `<b>MANEUVER:</b> Move <b>${unitStr(moving)}</b> from <b>${maneuverDec.from}</b> → <b>${maneuverDec.to}</b>${hopsNote}.
                <span class="rule-note">${maneuverDec.reason}</span>`,
            ];
        } else {
            G.pendingMove = { type:'none' };
            G.pendingMoves.push(G.pendingMove);
            EXPAND = [`<b>NO MOVE POSSIBLE</b> — ${C} cannot Expand, Position, or Maneuver this action. No pieces to move. ✓ and continue.`];
        }
        return EXPAND;
    }

    if (card === "TAX OR SPEND") {
        // Saved by the Crown restriction: no cities → cannot tax; can spend only if has castle
        const _hasCities  = ownedBy(color).filter(n => T[n].tax > 0).length > 0;
        const _hasCastle  = ownedBy(color).some(n => G.board[n].castle);
        const _savedGrace = G.savedByCrown?.has(color) && !_hasCities;
        if (_savedGrace && !_hasCastle) {
            steps.push(`<b>NO ACTION — SAVED BY THE CROWN:</b> ${C} has no cities and no castle. Cannot tax or spend. ✓ Skip this action.`);
            return steps;
        }
        if (_savedGrace) {
            steps.push(`<div class="shield-reminder">⚠ SAVED BY THE CROWN: ${C} has no cities — cannot tax. May spend only because ${C} controls a castle.</div>`);
            // Force spend regardless of coin count
            const { cost, items } = getBestSpend(coins, color);
            const hasCastle2 = items.includes("Castle");
            const hasSiege2  = items.includes("Siege Engine");
            const purchase2  = { cost, items,
                F:(items.match(/(\d+) Footm/)||[0,0])[1]|0,
                A:(items.match(/(\d+) Archer/)||[0,0])[1]|0,
                C:(items.match(/(\d+) Cavalry/)||[0,0])[1]|0,
                S:hasSiege2?1:0, castle:hasCastle2 };
            const placements2 = decideSpendPlacements(color, purchase2);
            G.pendingMove = { type:'spend', color, purchase:purchase2, placements:placements2 };
            G.pendingMoves.push(G.pendingMove);
            G._stepCoinEffects[0] = -cost;
            if (coins < cost) {
                steps.push(`<b>INSUFFICIENT COINS</b> — ${C} cannot afford any purchase. ✓ Skip.`);
            } else {
                steps.push(`<b>MODE: SPEND (castle only)</b> — Purchase: <span class="buy-highlight">${items}</span> Cost: <b>${cost} coins.</b>`);
            }
            return steps;
        }
        if (coins <= 4) {
            const taxDec = decideTax(color);
            const taxCity = taxDec ? taxDec.city : '(highest-yield city)';
            const taxAmt  = taxDec ? taxDec.yield : '?';
            G.pendingMove = { type:'tax', color, city: taxCity, amount: taxAmt };
            G.pendingMoves.push(G.pendingMove);
            steps.push(`<b>MODE: TAX</b> — ${C} has ${coins} coins (≤ 4).`);
            // Register coin effect: checking step 1 (index 1) adds taxAmt coins
            G._stepCoinEffects[1] = taxAmt;
            steps.push(`Tax <b>${taxCity}</b> — yield is <b>${taxAmt} coins</b>. ✓ Check this step to automatically add ${taxAmt} coins to ${C}'s total.
                <span class="rule-note">Yield = city's own Tax value + 1 per connected non-urban territory + Tax value of connected cities ${C} owns (all connected through ${C}'s own supply line).</span>`);
            // Shield reminders for tax-trigger cities
            const _taxSK1 = shieldKeyForTerr(taxCity);
            if (_taxSK1 && CITY_SHIELDS[_taxSK1]?.trigger === 'tax' && G.shields?.[_taxSK1] === color) {
                steps.push(`<div class="shield-reminder">${CITY_SHIELDS[_taxSK1].reminder}</div>`);
            }
        } else {
            const { cost, items } = getBestSpend(coins, color);
            const hasCastle = items.includes("Castle");
            const hasSiege  = items.includes("Siege Engine");
            // Parse purchase into unit counts
            const purchase = { cost, items,
                F: (items.match(/(\d+) Footm/)||[0,0])[1]|0,
                A: (items.match(/(\d+) Archer/)||[0,0])[1]|0,
                C: (items.match(/(\d+) Cavalry/)||[0,0])[1]|0,
                S: hasSiege ? 1 : 0,
                castle: hasCastle
            };
            const placements = decideSpendPlacements(color, purchase);
            G.pendingMove = { type:'spend', color, purchase, placements };
            G.pendingMoves.push(G.pendingMove);
            // Register coin effect: checking step 0 deducts cost coins
            G._stepCoinEffects[0] = -cost;
            // Track crown card flag on purchase
            if (purchase.crownCard) G._pendingCrownCard = color;
            steps.push(`<b>MODE: SPEND</b> — ${C} has ${coins} coins (≥ 5). Purchase:<span class="buy-highlight">${items}</span>Cost: <b>${cost} coins.</b> ✓ Check this step to automatically deduct the cost.
                <span class="rule-note">If a figure type runs out: substitute 2 Footmen ↔ 1 Archer. Never buy Crown Cards unless no Castles remain in supply.</span>`);
            placements.forEach((p,i) => {
                const curr = totalUnitCount(p.territory);
                if (p.type === 'castle') {
                    steps.push(`<b>Place Castle</b> at <b>${p.territory}</b> (Tax ${T[p.territory]?.tax||'?'}, currently ${curr} units).`);
                } else if (p.type === 'siege') {
                    steps.push(`<b>Place Siege Engine</b> at <b>${p.territory}</b> — closest territory to an enemy castle.`);
                    if (CITY_SHIELDS["Constantinople"]?.trigger === 'spend' && G.shields?.["Constantinople"] === color) {
                        steps.push(`<div class="shield-reminder">${CITY_SHIELDS["Constantinople"].reminder}</div>`);
                    }
                } else {
                    const qname = p.unitType==='C'?'Cavalry':p.unitType==='A'?'Archer':'Footman';
                    steps.push(`<b>Place ${p.count} ${qname}${p.count>1?'s':''}</b> at <b>${p.territory}</b> (Tax ${T[p.territory]?.tax||'?'}, currently ${curr} units).`);
                }
            });
            // Kiev shield — remind player they can place in non-city supply territories
            if (CITY_SHIELDS["Kiev"]?.trigger === 'spend' && G.shields?.["Kiev"] === color) {
                steps.push(`<div class="shield-reminder">${CITY_SHIELDS["Kiev"].reminder}</div>`);
            }
        }
        return steps;
    }


    if (card === "SPLIT EXPAND OR MANEUVER") {
        const splitDec = decideSplitExpand(color);
        if (splitDec) {
            const moving = unitsToMove(splitDec.from, splitDec.movable, splitDec.hasCastle);
            G.pendingMove = { type:'expand', color, from:splitDec.from, to:splitDec.to,
                movingUnits:moving, movable:splitDec.movable, isEnemy:splitDec.isEnemy };
            G.pendingMoves.push(G.pendingMove);
            const route = splitDec.via ? `${splitDec.from} → ${splitDec.via} → ${splitDec.to}` : `${splitDec.from} → ${splitDec.to}`;
            steps.push(`<b>SPLIT EXPAND:</b> Move <b>${unitStr(moving)}</b> along route: <b>${route}</b>.
                <span class="rule-note">Leave ${T[splitDec.from].tax>0?'Tax value '+T[splitDec.from].tax:'1'} unit(s) at ${splitDec.from}. Target ${splitDec.to}: Tax ${splitDec.tax}${splitDec.isEnemy?', ENEMY: '+splitDec.defenders+' defenders':''}${splitDec.hasCastle?' — has castle (Siege Engine required)':''}</span>`);
            if (splitDec.isEnemy) steps.push(renderCombatDialog(G.pendingMove));
        } else {
            // Rule: if no city can be entered, MANEUVER only — not expand or position
            const _manDec = decideManeuver(color);
            if (_manDec) {
                const mMov = unitsToMove(_manDec.from, _manDec.movable, false);
                G.pendingMove = { type:'maneuver', color, from:_manDec.from, to:_manDec.to, movingUnits:mMov };
                G.pendingMoves.push(G.pendingMove);
                const hNote = _manDec.reason?.includes('2-step') ? ' (2-step)' : '';
                steps.push(`<b>NO CITY REACHABLE — MANEUVER:</b> Move <b>${unitStr(mMov)}</b> from <b>${_manDec.from}</b> → <b>${_manDec.to}</b>${hNote}.
                <span class="rule-note">${_manDec.reason}</span>`);
            } else {
                G.pendingMove = { type:'none' }; G.pendingMoves.push(G.pendingMove);
                steps.push(`<b>NO MOVE POSSIBLE</b> — ${C} cannot Split Expand or Maneuver. ✓ and continue.`);
            }
        }
        return steps;
    }

    if (card === "FORTIFY / EXPAND OR MANEUVER") {
        const fortDec = decideFortify(color);
        const fortTerr = fortDec ? fortDec.territory : '(city with fewest units)';
        const fortCount = fortDec ? fortDec.count : 3;
        const currCount = fortDec ? totalUnitCount(fortDec.territory) : '?';
        // Store fortify as a proper move entry
        if (fortDec) G.pendingMoves.push({ type:'fortify', territory:fortDec.territory, count:fortDec.count });
        G.pendingFortify = fortDec; // legacy
        steps.push(`<b>FORTIFY:</b> Add <b>+${fortCount} Footmen</b> to <b>${fortTerr}</b> (currently ${currCount} units${fortDec&&G.board[fortTerr]?.castle?' — has castle':''}). Take them from the supply.
            <span class="rule-note">${fortDec&&fortDec.hasCastle?'+4 Footmen because this location has a castle.':'+3 Footmen to a city.'} Priority: fewest units → highest Tax → Capital beats city → roll die.</span>`);
        steps.push(null); // ── section divider ──

        // ── CRITICAL: recompute expand/position/maneuver AFTER applying fortify ──
        // The fortify hasn't hit G.board yet (it applies in advanceTurn), so we
        // temporarily apply it now, recompute, then undo.
        // This ensures the expand picks up the newly fortified army if it's now largest.
        if (fortDec && G.board[fortDec.territory]) {
            G.board[fortDec.territory].units.F = (G.board[fortDec.territory].units.F||0) + fortDec.count;
        }
        // Remove the EXPAND steps we pushed earlier (they used stale board state)
        // and recompute with the updated board
        // First, remove the stale pendingMove that EXPAND pushed (if any)
        G.pendingMoves = G.pendingMoves.filter(m => m._berlinBonus || m.type === 'fortify');
        G.pendingMove = null;
        const postFortExpandDec  = decideExpand(color);
        const postFortManDec     = decideManeuver(color);
        const postFortPosDec     = decidePosition(color);
        // Undo the temporary fortify
        if (fortDec && G.board[fortDec.territory]) {
            G.board[fortDec.territory].units.F = Math.max(0, (G.board[fortDec.territory].units.F||0) - fortDec.count);
        }
        // Rebuild EXPAND block with post-fortify decisions
        let EXPAND_POST;
        if (postFortExpandDec) {
            const pLeave = leaveBehindCount(postFortExpandDec.from);
            const pMoving = unitsToMove(postFortExpandDec.from, postFortExpandDec.movable, postFortExpandDec.hasCastle);
            const pLeaveUnits = unitsToLeave(postFortExpandDec.from, pLeave);
            G.pendingMove = { type:'expand', color, from:postFortExpandDec.from, to:postFortExpandDec.to,
                movingUnits:pMoving, movable:postFortExpandDec.movable, isEnemy:postFortExpandDec.isEnemy };
            G.pendingMoves.push(G.pendingMove);
            const pMoveDetail  = `Move <b>${unitStr(pMoving)}</b> from <b>${postFortExpandDec.from}</b> → <b>${postFortExpandDec.to}</b>`;
            const pLeaveDetail = `Leave <b>${unitStr(pLeaveUnits)}</b> at ${postFortExpandDec.from}`;
            const pCombatStep  = postFortExpandDec.isEnemy ? renderCombatDialog(G.pendingMove) : null;
            const pHasBerlin   = CITY_SHIELDS['Berlin']?.trigger === 'expand_spend' && G.shields?.['Berlin'] === color;
            const pBerlinNote  = pHasBerlin
                ? `<div class="shield-reminder">${color===S.playerColor?CITY_SHIELDS['Berlin'].reminder:'🛡 BERLIN SHIELD: '+cName(color)+' expands then also maneuvers. Castles cost 3 fewer coins.'}</div>`
                : null;
            if (pHasBerlin && color !== S.playerColor) {
                const bm = decideManeuver(color);
                if (bm) { const bmMv = unitsToMove(bm.from,bm.movable,false); G.pendingMoves.push({type:'maneuver',color,from:bm.from,to:bm.to,movingUnits:bmMv,_berlinBonus:true}); }
            }
            EXPAND_POST = [
                `<b>EXPAND:</b> ${pMoveDetail}.<br>${pLeaveDetail} (leave-behind: ${T[postFortExpandDec.from].tax>0?'Tax value '+T[postFortExpandDec.from].tax:'1 unit for non-urban'}).
                 <span class="rule-note">Target: ${postFortExpandDec.to} (Tax ${postFortExpandDec.tax}${postFortExpandDec.isEnemy?', ENEMY: '+postFortExpandDec.defenders+' defenders':', '+(G.board[postFortExpandDec.to].owner==='neutral'?'neutral':'friendly')+'.'}).${postFortExpandDec.hasCastle?' ⚠ Has castle — Siege Engine required.':''}</span>`,
                ...(pBerlinNote ? [pBerlinNote] : []),
                ...(pCombatStep ? [pCombatStep] : []),
            ];
        } else if (postFortPosDec) {
            const pPosMoving = unitsToMove(postFortPosDec.from, postFortPosDec.movable, false);
            G.pendingMove = { type:'position', color, from:postFortPosDec.from, to:postFortPosDec.to, movingUnits:pPosMoving };
            G.pendingMoves.push(G.pendingMove);
            EXPAND_POST = [
                `<b>NO DIRECT CITY ENTRY POSSIBLE — POSITION:</b> Move <b>${unitStr(pPosMoving)}</b> from <b>${postFortPosDec.from}</b> → <b>${postFortPosDec.to}</b> (moving toward <b>${postFortPosDec.toward}</b>).
                <span class="rule-note">Leave-behind: ${T[postFortPosDec.from].tax>0?'Tax value '+T[postFortPosDec.from].tax+' units':'1 unit'} at ${postFortPosDec.from}.</span>`,
            ];
        } else if (postFortManDec) {
            const pManMoving = unitsToMove(postFortManDec.from, postFortManDec.movable, false);
            G.pendingMove = { type:'maneuver', color, from:postFortManDec.from, to:postFortManDec.to, movingUnits:pManMoving };
            G.pendingMoves.push(G.pendingMove);
            EXPAND_POST = [
                `<b>MANEUVER:</b> Move <b>${unitStr(pManMoving)}</b> from <b>${postFortManDec.from}</b> → <b>${postFortManDec.to}</b>.
                <span class="rule-note">${postFortManDec.reason}</span>`,
            ];
        } else {
            G.pendingMove = { type:'none' };
            G.pendingMoves.push(G.pendingMove);
            EXPAND_POST = [`<b>NO MOVE POSSIBLE</b> — ${C} cannot Expand, Position, or Maneuver. ✓ and continue.`];
        }
        steps.push(...EXPAND_POST);
        return steps;
    }

    if (card === "SIEGE ASSAULT / EXPAND OR MANEUVER") {
        const siegeDec = decideSiege(color);
        if (siegeDec) {
            const siegeMovable = movableCount(siegeDec.from, color);
            const siegeMovingUnits = unitsToMove(siegeDec.from, siegeMovable, true); // true = keep siege engine
            G.pendingMove = { type:'expand', color, from:siegeDec.from, to:siegeDec.to,
                movingUnits: siegeMovingUnits, movable: siegeMovable, isEnemy:true };
            G.pendingMoves.push(G.pendingMove);
            steps.push(`<b>SIEGE ASSAULT:</b> Attack <b>${siegeDec.to}</b> from <b>${siegeDec.from}</b> (${siegeDec.defenders} defenders, owned by ${siegeDec.defOwner}).`);
            steps.push(`<b>Resolve siege combat</b> (Siege Engine fires first per base game rules).`);
            steps.push(renderCombatDialog(G.pendingMove));
        } else {
            steps.push(`<b>SIEGE ASSAULT: No Siege Engine available</b> — ${C} has no siege engines on the board. Skip to EXPAND/MANEUVER below.`);
        }
        steps.push(null); // ── section divider ──
        steps.push(...buildExpandBlock());
        return steps;
    }

    if (card === "KING ME / TAX OR SPEND") {
        // BONUS: KING ME — claims first player marker
        G._stepCoinEffects[0] = 'kingme:' + color;
        steps.push(`<b>KING ME (BONUS):</b> ${C} claims the First Player marker. ✓ Check this step to queue the change for next round.`);
        steps.push(`The change takes effect at the <b>start of next round</b>. The first player indicator on ${C}'s tile will pulse.`);
        steps.push(null); // ── section divider ──
        // MAIN: TAX OR SPEND — steps start at index 3 (0=kingme, 1=note, 2=null-divider)
        // _stepCoinEffects must use offset indices: spend at [3], tax-city at [4]
        const _hasCities  = ownedBy(color).filter(n => T[n].tax > 0).length > 0;
        const _hasCastle  = ownedBy(color).some(n => G.board[n].castle);
        const _savedGrace = G.savedByCrown?.has(color) && !_hasCities;
        if (_savedGrace && !_hasCastle) {
            steps.push(`<b>TAX OR SPEND (MAIN): NO ACTION — SAVED BY THE CROWN:</b> ${C} has no cities and no castle. Skip.`);
            return steps;
        }
        steps.push(`<b>TAX OR SPEND (MAIN):</b>`);
        if (coins <= 4) {
            const taxDec = decideTax(color);
            const taxCity = taxDec ? taxDec.city : '(highest-yield city)';
            const taxAmt  = taxDec ? taxDec.yield : '?';
            G.pendingMove = { type:'tax', color, city: taxCity, amount: taxAmt };
            G.pendingMoves.push(G.pendingMove);
            G._stepCoinEffects[4] = taxAmt; // step index 4 (after 0=kingme,1=note,2=divider,3=header)
            steps.push(`Tax <b>${taxCity}</b> — yield is <b>${taxAmt} coins</b>. ✓ Check to automatically add ${taxAmt} coins.
                <span class="rule-note">Yield = Tax value + 1 per connected non-urban territory + Tax of connected owned cities.</span>`);
            const _taxSK2 = shieldKeyForTerr(taxCity);
            if (_taxSK2 && CITY_SHIELDS[_taxSK2]?.trigger === 'tax' && G.shields?.[_taxSK2] === color) {
                steps.push(`<div class="shield-reminder">${CITY_SHIELDS[_taxSK2].reminder}</div>`);
            }
        } else {
            const { cost, items } = getBestSpend(coins, color);
            const hasCastle = items.includes("Castle"), hasSiege = items.includes("Siege Engine");
            const purchase = { cost, items,
                F:(items.match(/(\d+) Footm/)||[0,0])[1]|0,
                A:(items.match(/(\d+) Archer/)||[0,0])[1]|0,
                C:(items.match(/(\d+) Cavalry/)||[0,0])[1]|0,
                S:hasSiege?1:0, castle:hasCastle };
            const placements = decideSpendPlacements(color, purchase);
            G.pendingMove = { type:'spend', color, purchase, placements };
            G.pendingMoves.push(G.pendingMove);
            G._stepCoinEffects[3] = -cost; // step index 3 = header+spend combined
            steps.push(`<b>SPEND</b> — ${C} has ${coins} coins (≥ 5). Purchase: <span class="buy-highlight">${items}</span> Cost: <b>${cost} coins.</b> ✓ Check to deduct.
                <span class="rule-note">If a figure type runs out: substitute 2 Footmen ↔ 1 Archer.</span>`);
            placements.forEach(p => {
                const curr = totalUnitCount(p.territory);
                if (p.type === 'castle') {
                    steps.push(`<b>Place Castle</b> at <b>${p.territory}</b> (Tax ${T[p.territory]?.tax||'?'}, currently ${curr} units).`);
                } else if (p.type === 'siege') {
                    steps.push(`<b>Place Siege Engine</b> at <b>${p.territory}</b> — closest to an enemy castle.`);
                    if (CITY_SHIELDS["Constantinople"]?.trigger === 'spend' && G.shields?.["Constantinople"] === color)
                        steps.push(`<div class="shield-reminder">${CITY_SHIELDS["Constantinople"].reminder}</div>`);
                } else {
                    const qname = p.unitType==='C'?'Cavalry':p.unitType==='A'?'Archer':'Footman';
                    steps.push(`<b>Place ${p.count} ${qname}${p.count>1?'s':''}</b> at <b>${p.territory}</b> (Tax ${T[p.territory]?.tax||'?'}, currently ${curr} units).`);
                }
            });
            if (CITY_SHIELDS["Kiev"]?.trigger === 'spend' && G.shields?.["Kiev"] === color)
                steps.push(`<div class="shield-reminder">${CITY_SHIELDS["Kiev"].reminder}</div>`);
        }
        return steps;
    }

    steps.push(`Unknown card: "${card}". Check the rulebook.`);
    return steps;
}

// Combat-required step — rendered inline in the checklist
function renderCombatDialog(move) {
    if (!move || !move.from || !move.to) return '';
    // Queue this attack for the Combat Phase at end of round
    if (!G.roundCombats) G.roundCombats = [];
    // Avoid duplicates
    const already = G.roundCombats.some(c => c.from===move.from && c.to===move.to && c.color===move.color);
    if (!already) G.roundCombats.push({ ...move });
    const defOwner = G.board[move.to]?.owner || 'neutral';
    const def = totalUnitCount(move.to);
    return `<div style="background:rgba(139,26,26,0.06);border:2px solid rgba(139,26,26,0.3);border-radius:8px;padding:10px 14px;font-size:0.87em;">
        <b style="font-family:Cinzel,serif;color:var(--accent);">⚔ Attack queued for Combat Phase</b><br>
        <span style="color:var(--ink-light);">${move.movable||totalUnitCount(move.from)} units: <b>${move.from} → ${move.to}</b> · ${def} defenders (${defOwner.toUpperCase()})</span>
    </div>`;
}

function findStepIdxContaining(text) {
    return G.currentSteps.findIndex((s, i) => s && s.includes(text) && !G.checkedSteps.has(i));
}

function applyCombatAndCheck() { /* replaced by combat subsystem */ }
function launchCombatFromStep() {} // deprecated — combat is now end-of-round
function skipCombatStep() {}       // deprecated

// ================================================================
// ADVANCE TURN
// ================================================================
function advanceTurn() {
    if (G.winner) return; // game over — don't advance
    // Apply all pending board changes for this turn in order
    for (const mv of (G.pendingMoves || [])) {
        if (!mv || mv.type === 'tax' || mv.type === 'none' || mv._applied) continue;
        if (mv.type === 'spend') {
            applySpend(mv.color, mv.purchase, mv.placements||[]);
            // Constantinople shield: fires if a Siege Engine was purchased
            if (mv.purchase?.S > 0) applyShieldBonus('Constantinople', mv.color, 'siege_buy');
            // Kiev shield: fires on any spend
            applyShieldBonus('Kiev', mv.color, 'spend');
            // Berlin shield (castle cost reduction) already baked into spend table; extra maneuver handled in generateSteps
        } else if (mv.type === 'fortify') {
            applyFortify(mv.territory, mv.count);
        } else if (mv.type === 'expand' || mv.type === 'position' || mv.type === 'maneuver') {
            if (!mv.isEnemy) {
                applyNonCombatMove(mv);
            } else {
                // Queue for end-of-round Combat Phase
                if (!G.roundCombats) G.roundCombats = [];
                const already = G.roundCombats.some(c=>c.from===mv.from&&c.to===mv.to&&c.color===mv.color);
                if (!already) G.roundCombats.push({ ...mv });
            }
        }
    }
    G.pendingMoves = [];
    G.pendingMove = null;
    G.pendingFortify = null;
    G.humanTurnChecks = new Set();
    G.humanBoardUpdated = false;
    G.humanVariant = null;
    G._humanVariantPending = null;
    G.humanFlow = [];
    G.humanSpendCart = {F:0,A:0,C:0,S:0,Castle:0};
    // Discard the human's played card
    if (G.humanCard) {
        G.humanDiscard.push(G.humanCard);
        G.humanCard = null;
        if (G.humanDeck.length === 0) {
            G.humanDeck = shuffle([...G.humanDiscard]);
            G.humanDiscard = [];
            addLog('DECK: Your card deck exhausted and reshuffled.');
        }
    }
    BE.movedFrom = new Set(); // clear crossed-off territories for new turn
    G.revealed = false; G.currentSteps = []; G.checkedSteps = new Set();
    G.slot++;
    if (G.slot >= getTurnOrder().length) {
        G.slot = 0;
        if (G.step === 1) {
            G.step = 2;
            addLog('— All players finished Action 1. Now Action 2. —');
        } else {
            G.step = 1;
            // Launch Combat Phase for the round that just ended, THEN increment
            if (G.roundCombats && G.roundCombats.length > 0) {
                openCombatPhase(G.round);   // pass current round before incrementing
                G.round++;
            } else {
                G.round++;
                checkElimination();
                if (!G.winner) prepareRound(false);
            }
        }
    }
    render();
    resetStuckTimer();
}

function confirmReset() {
    if(!confirm('Reset entire game and return to setup?')) return;
    const wo = document.getElementById('winner-overlay');
    if (wo) wo.style.display = 'none';
    G = {};
    Object.assign(S, { step:0, playerColor:null, firstAuto:null, autoCapitals:{}, playerCapital:null,
                       autoSecondary:{}, playerSecondary:null, takenAdj:new Set(), shuffledCaps:[], coinsData:[] });
    document.getElementById('game-screen').style.display  = 'none';
    document.getElementById('setup-screen').style.display = 'block';
    showStep(0);
}

// ================================================================
// RENDER
// ================================================================
function render() {
    const order  = getTurnOrder();
    const active = activeColor();
    const bar    = document.getElementById('player-bar');
    bar.innerHTML = '';
    order.forEach((c,i) => {
        const isActive  = i===G.slot;
        const isFirst   = c===G.firstPlayer;
        const isPending = c===G.pendingFirst;
        const isHuman   = c===S.playerColor;
        const tile      = document.createElement('div');
        const isSaved = G.savedByCrown?.has(c);
        const isElim  = G.eliminated?.has(c);
        tile.className  = `player-tile ${isActive?'active':''} ${isFirst?'is-first':''} ${isPending?'is-pending':''} ${isSaved?'is-saved':''} ${isElim?'is-eliminated':''}`;
        tile.style.background = `var(--p-${c})`;
        // Light backgrounds need dark text
        const lightColors = ['blue', 'green', 'orange'];
        const textColor = lightColors.includes(c) ? 'rgba(0,0,0,0.85)' : 'rgba(255,255,255,0.95)';
        const subTextColor = lightColors.includes(c) ? 'rgba(0,0,0,0.5)' : 'rgba(255,255,255,0.5)';
        tile.style.color = textColor;
        const used  = isHuman ? `${G.humanDiscard.length}/8` : `${8-G.decks[c].length}/8`;
        const mode  = (!isHuman && G.coins[c]<=4)
            ? '<span class="coin-threshold mode-tax">TAX</span>'
            : '<span class="coin-threshold mode-spend">SPEND</span>';
        tile.innerHTML = `
            <div class="p-name"><span class="crown-badge" onclick="setFirst('${c}')" title="KING ME: set as next First Player">🪙</span>${c.toUpperCase()}${G.savedByCrown?.has(c)?' <span title="Saved by the Crown — must reclaim a city this round" style="font-size:0.75em;color:#b8860b;">⚠ GRACE</span>':''}${G.eliminated?.has(c)?' <span style="font-size:0.75em;color:#8b1a1a;">💀</span>':''}</div>
            <div class="coin-row">
                <button class="coin-btn" onclick="addCoin('${c}',-1)">−</button>
                <span class="coin-count">${G.coins[c]}</span>
                <button class="coin-btn" onclick="addCoin('${c}',+1)">+</button>
            </div>
            <div class="coin-row" style="margin-top:2px;">
                ${isHuman ? `<button class="coin-btn" onclick="addCrown('${c}',-1)">−</button>` : '<span style="width:18px"></span>'}
                <span title="Crowns" style="font-size:0.75em;letter-spacing:0.02em;">👑${G.crowns[c]||0}</span>
                ${isHuman ? `<button class="coin-btn" onclick="addCrown('${c}',+1)">+</button>` : '<span style="width:18px"></span>'}
            </div>
            ${isHuman ? `<span style="font-size:0.58em;color:${subTextColor};">YOU</span>` : mode}
            <div class="deck-pip">${used}</div>`;
        bar.appendChild(tile);
    });

    document.getElementById('round-display').textContent = `ROUND ${G.round}`;
    document.getElementById('step-display').textContent  = `ACTION ${G.step} of 2`;

    const isHuman = active===S.playerColor;
    document.getElementById('ai-view').style.display    = isHuman ? 'none' : 'block';
    document.getElementById('human-view').style.display = isHuman ? 'block' : 'none';

    if (isHuman) {
        renderHumanTurn();
        document.getElementById('steps-panel').style.display = 'none';
    } else if (!G.revealed) {
        const cardEl = document.getElementById('card-display');
        cardEl.className = 'action-card unrevealed';
        cardEl.innerHTML = `Tap button to reveal<br><span class="card-sub">${cName(active)}'s card is face-down</span>`;
        const revBtn = document.getElementById('reveal-btn');
        if(revBtn) revBtn.style.display='block';
        document.getElementById('steps-panel').style.display='none';
        document.getElementById('complete-btn').disabled = true;
    } else {
        // AI turn, card revealed — always re-render steps panel
        // (handles case where render() is called after reveal without re-generating steps)
        if (G.currentSteps && G.currentSteps.length > 0) {
            renderSteps();
        } else {
            // Steps missing entirely — regenerate defensively
            const card = G.hand[active]?.[G.step-1];
            if (card) regenerateSteps(card, active);
        }
    }
}


// ================================================================
// BOARD EDITOR
// ================================================================
let BE = { step:'list', fromTerr:null, destTerr:null, moveCount:1 };

function openBoardEditor(focusColor) {
    BE = { step:'list', fromTerr:null, destTerr:null,
           moveUnits:{F:0,A:0,C:0,S:0},
           movedFrom: BE?.movedFrom || new Set() }; // cleared each turn in advanceTurn()
    const validColors = ['orange','green','purple','blue','neutral'];
    const resolved = (focusColor && validColors.includes(focusColor)) ? focusColor
        : (activeColor ? activeColor() : null) || S.playerColor || 'orange';
    BE.color = resolved;
    document.getElementById('board-overlay').classList.add('open');
    renderBoardEditor();
}

function closeBoardEditor() {
    document.getElementById('board-overlay').classList.remove('open');
    render();
    // Auto-check the board step if opened from human turn
    const isHumanTurn = S.playerColor && activeColor && activeColor() === S.playerColor;
    if (isHumanTurn && G._htBoardStep !== undefined) {
        G.humanBoardUpdated = true;
        G.humanTurnChecks = G.humanTurnChecks || new Set();
        G.humanTurnChecks.add(G._htBoardStep);
        G._htBoardStep = undefined;
        renderHumanTurn();
    }
}

function beUnitStr(u) {
    const p = [];
    if ((u.C||0)>0) p.push(u.C+'C');
    if ((u.A||0)>0) p.push(u.A+'A');
    if ((u.F||0)>0) p.push(u.F+'F');
    if ((u.S||0)>0) p.push(u.S+'S');
    return p.join(' + ') || '—';
}

function renderBoardEditor() {
    const bs = (G.board && Object.keys(G.board).length > 0) ? G.board
        : Object.fromEntries(Object.keys(T).map(n=>[n,{owner:'neutral',units:{F:0,A:0,C:0,S:0},castle:false}]));

    const color = BE.color;
    const isPlayer = color === S.playerColor;
    const colorLabel = isPlayer ? 'YOUR' : color.charAt(0).toUpperCase()+color.slice(1)+"'s";
    document.getElementById('board-modal-title').textContent = colorLabel + ' Territories';

    if (BE.step === 'list') renderBEList(bs, color);
    else if (BE.step === 'move') renderBEMove(bs, color);
    else if (BE.step === 'full') renderBEFull(bs);
}


// ── Supply Line Movement ─────────────────────────────────────────
// Returns all territories reachable through a chain of own territories
// (and one step beyond into enemy/neutral for attack/settle)
// depth: how many hops through own territory are allowed (MANEUVER = unlimited chain)
function getSupplyLineTerritories(fromName, color, includeEnemy=true) {
    const visited = new Set([fromName]);
    const ownChain = new Set([fromName]); // territories in own supply line
    const queue = [fromName];
    // BFS through own territories to find full supply line
    while (queue.length) {
        const cur = queue.shift();
        for (const adj of (T[cur]?.adj || [])) {
            if (!visited.has(adj) && G.board[adj]?.owner === color) {
                visited.add(adj);
                ownChain.add(adj);
                queue.push(adj);
            }
        }
    }
    // Now find all territories adjacent to any node in ownChain that are not own
    const destinations = new Map(); // name -> {type, hops}
    for (const own of ownChain) {
        for (const adj of (T[own]?.adj || [])) {
            if (ownChain.has(adj)) continue; // already own
            if (!T[adj]) continue;
            const owner = G.board[adj]?.owner || 'neutral';
            if (!destinations.has(adj) || true) {
                destinations.set(adj, { name: adj, via: own, type: owner === 'neutral' ? 'neutral' : owner === color ? 'own' : 'enemy' });
            }
        }
    }
    // Also include own chain members that are not the source (for repositioning)
    for (const own of ownChain) {
        if (own === fromName) continue;
        if (!destinations.has(own)) {
            destinations.set(own, { name: own, via: own, type: 'friendly' });
        }
    }
    return Array.from(destinations.values());
}

// ── STEP 1: territory list ────────────────────────────────────────
function renderBEList(bs, color) {
    const owned = Object.keys(bs)
        .filter(n => bs[n].owner === color)
        .sort((a,b) => (T[b]?.tax||0)-(T[a]?.tax||0) || a.localeCompare(b));

    const content = document.getElementById('board-content');

    if (!owned.length) {
        content.innerHTML = `<p style="padding:20px;text-align:center;color:var(--ink-light);">No territories owned yet.</p>
            <button class="btn-full-board" onclick="BE.step='full';renderBoardEditor()">
                🗺 View Entire Board State
            </button>`;
        return;
    }

    const rows = owned.map(name => {
        const b = bs[name];
        const u = b.units;
        const total = unitTotal(u);
        const leaveN = leaveBehindPlayer(name);
        const movable = movableCountPlayer(name);
        const taxStr = T[name]?.tax > 0 ? `Tax ${T[name].tax}  ·  ` : '';
        const castleStr = b.castle ? '🏰  ·  ' : '';
        const unitSummary = beUnitStr(u);
        const canMove = movable > 0;

        const hasMoved = BE.movedFrom && BE.movedFrom.has(name);
        const rowCls = hasMoved ? 'be-moved' : (!canMove ? 'be-terr-dim' : '');
        const clickable = canMove && !hasMoved;
        return `<li class="be-terr-item ${rowCls}" onclick="${clickable?`bePickFrom('${name}')`:''}" >
            <div>
                <div class="bt-name">${terrLabel(name)}</div>
                <div class="bt-sub">${castleStr}${taxStr}${unitSummary}</div>
            </div>
            <div style="text-align:right">
                ${hasMoved
                    ? `<div class="bt-badge" style="color:#aaa">✓ moved</div>`
                    : canMove
                        ? `<div class="bt-badge"><b>${movable}</b> movable</div><div class="bt-arrow">›</div>`
                        : `<div class="bt-badge" style="color:#aaa">must leave ${leaveN}</div>`
                }
            </div>
        </li>`;
    }).join('');

    content.innerHTML = `<ul class="be-terr-list">${rows}</ul>
        <button class="btn-full-board" onclick="BE.step='full';renderBoardEditor()">
            🗺 View Entire Board State
        </button>`;
}

// ── STEP 2: pick destination + count ─────────────────────────────
function renderBEMove(bs, color) {
    const from = BE.fromTerr;
    if (!from || !bs[from]) { BE.step='list'; renderBoardEditor(); return; }

    const b = bs[from];
    const total = unitTotal(b.units);
    const leaveN = leaveBehindPlayer(from);
    const maxMove = movableCountPlayer(from);
    const unitSummary = beUnitStr(b.units);
    const taxStr = T[from]?.tax > 0 ? `Tax ${T[from].tax}  ·  ` : '';
    const castleStr = b.castle ? '🏰  ·  ' : '';

    // Adjacent territories
    const adjs = (T[from]?.adj || []).filter(n => bs[n]);
    const destRows = adjs.map(name => {
        const ab = bs[name];
        const adjTotal = unitTotal(ab.units);
        const isOwn = ab.owner === color;
        const isEnemy = !isOwn && ab.owner !== 'neutral';
        const isNeutral = ab.owner === 'neutral';
        const dotColor = COLOR_HEX[ab.owner] || '#aaa';
        const ownerLabel = isOwn ? 'Friendly' : isEnemy ? ab.owner.charAt(0).toUpperCase()+ab.owner.slice(1) : 'Neutral';
        const taxStr2 = T[name]?.tax > 0 ? ` · Tax ${T[name].tax}` : '';
        const castleIcon = ab.castle ? ' 🏰' : '';
        const cls = isEnemy ? 'is-enemy' : isOwn ? 'is-friendly' : '';
        const selCls = BE.destTerr === name ? 'sel' : '';

        return `<div class="be-dest-item ${cls} ${selCls}" onclick="bePickDest('${name}')">
            <div class="be-dest-dot" style="background:${dotColor}"></div>
            <div class="be-dest-info">
                <div class="be-dest-name">${name}${castleIcon}</div>
                <div class="be-dest-sub">${ownerLabel}${taxStr2} · ${adjTotal} unit${adjTotal!==1?'s':''}</div>
            </div>
            ${BE.destTerr===name ? '<span style="color:var(--accent);font-size:1.2em;font-weight:700;">✓</span>' : ''}
        </div>`;
    }).join('');

    // Per-unit-type picker (only when dest selected)
    let countBox = '';
    if (BE.destTerr) {
        const destB = bs[BE.destTerr];
        const isAttack = destB && destB.owner !== color && destB.owner !== 'neutral';
        const hasCastle = destB?.castle;
        const u = b.units;
        // Available per type = what's in territory minus what must stay (leave 1 total)
        // We enforce: sum of moved ≤ maxMove, and at least 1 unit stays
        const mu = BE.moveUnits;
        const totalMoving = (mu.F||0)+(mu.A||0)+(mu.C||0)+(mu.S||0);
        const attackWarn = isAttack && hasCastle
            ? `<div style="color:var(--accent);font-size:0.8em;margin:6px 0;">⚠ Has castle — you need a Siege Engine to attack.</div>`
            : isAttack
                ? `<div style="color:var(--accent);font-size:0.8em;margin:6px 0;">Attacking — ${totalMoving} unit${totalMoving!==1?'s':''} vs ${unitTotal(destB.units)} defenders.</div>`
                : '';

        const unitNames = {C:'Cavalry',A:'Archer',F:'Footman',S:'Siege'};
        const unitRows = ['C','A','F','S'].map(k => {
            const avail = u[k]||0;
            if (avail === 0) return ''; // hide types with none
            const moving = mu[k]||0;
            // Can add more of this type if: avail remaining > 0 AND total won't exceed maxMove
            const canAdd = moving < avail && totalMoving < maxMove;
            const canSub = moving > 0;
            return `<div class="unit-type-row ${avail===0?'zero':''}">
                <div>
                    <div class="ut-label">${unitNames[k]}</div>
                    <div class="ut-avail">${avail} available</div>
                </div>
                <div class="ut-stepper">
                    <button class="ut-btn" onclick="beAdjUnit('${k}',-1)" ${canSub?'':'disabled'}>−</button>
                    <span class="ut-val">${moving}</span>
                    <button class="ut-btn" onclick="beAdjUnit('${k}',1)" ${canAdd?'':'disabled'}>+</button>
                </div>
            </div>`;
        }).filter(Boolean).join('');

        countBox = `<div class="be-count-box">
            <div class="be-count-label">Choose which units to move from <b>${from}</b><br>
                <span style="font-size:0.85em;">Must leave at least 1 unit behind · max ${maxMove} movable</span>
            </div>
            <div class="unit-type-grid">${unitRows}</div>
            ${attackWarn}
            <button class="be-confirm-btn" onclick="beConfirmMove()" ${totalMoving>0?'':'disabled'}>
                ✓ Move ${totalMoving} unit${totalMoving!==1?'s':''} → ${BE.destTerr}
            </button>
        </div>`;
    }

    // Corrections panel — owner + castle
    const ownerDots = ['orange','green','purple','blue','neutral'].map(c => {
        const bg = COLOR_HEX[c]||'#aaa';
        const sel = b.owner === c ? 'sel' : '';
        return `<button class="be-odot ${sel}" style="background:${bg}" title="${c}"
            onclick="event.stopPropagation();beSetOwner('${from}','${c}')"></button>`;
    }).join('');
    const castleCls = b.castle ? 'be-castle-btn on' : 'be-castle-btn';
    const castleLbl = b.castle ? '🏰 Remove Castle' : '+ Add Castle';

    const corrections = `<div class="be-corrections">
        <div class="be-corr-title">Correct this territory</div>
        <div class="be-owner-row">
            <span>Owner:</span>${ownerDots}
        </div>
        <button class="${castleCls}" onclick="event.stopPropagation();beToggleCastle('${from}')">${castleLbl}</button>
    </div>`;

    document.getElementById('board-content').innerHTML = `
        <button class="be-back-btn" onclick="BE.step='list';BE.fromTerr=null;BE.destTerr=null;renderBoardEditor()">‹ Back to your territories</button>
        <div class="be-from-banner">
            <div class="bfb-name">${from}${b.castle?' 🏰':''}</div>
            <div class="bfb-units">${castleStr}${taxStr}${unitSummary} · ${maxMove} movable</div>
        </div>
        <div class="be-dest-label">Move to which adjacent territory?</div>
        <div class="be-dest-list">${destRows}</div>
        ${countBox}
        ${corrections}
    `;
}

// ── Actions ───────────────────────────────────────────────────────

// ── FULL BOARD VIEW ───────────────────────────────────────────────
function renderBEFull(bs) {
    document.getElementById('board-modal-title').textContent = 'Full Board State';
    const colors = ['orange','green','purple','blue'];
    const allColors = [...colors, 'neutral'];

    function unitStr(u) {
        const p = [];
        if ((u.C||0)>0) p.push(u.C+'C');
        if ((u.A||0)>0) p.push(u.A+'A');
        if ((u.F||0)>0) p.push(u.F+'F');
        if ((u.S||0)>0) p.push(u.S+'S');
        return p.join('+') || '—';
    }

    const sections = allColors.map(c => {
        const territories = Object.keys(bs)
            .filter(n => bs[n].owner === c)
            .sort((a,b) => (T[b]?.tax||0)-(T[a]?.tax||0) || a.localeCompare(b));

        const bg = c === 'neutral' ? '#888' : (COLOR_HEX[c] || '#888');
        const txt = ['orange','green','blue'].includes(c) ? '#000' : '#fff';
        const label = c === S.playerColor ? c.toUpperCase()+' (YOU)' : c.toUpperCase();
        const totalUnits = territories.reduce((sum,n)=>sum+unitTotal(bs[n].units),0);

        const rows = territories.length
            ? territories.map(name => {
                const b = bs[name];
                const tax = T[name]?.tax > 0 ? `Tax ${T[name].tax}` : 'non-urban';
                const castle = b.castle ? ' 🏰' : '';
                const units = unitStr(b.units);
                const total = unitTotal(b.units);
                const pendingBattle = (G.roundCombats||[]).find(b => b.to === name && !b._resolved);
                const pendingTag = pendingBattle
                    ? `<span style="color:#8b1a1a;font-size:0.75em;font-weight:700;margin-left:4px;">⚔ ${pendingBattle.color} attacking</span>`
                    : '';
                return `<div class="fbs-row" onclick="openTerrEdit('${name.replace(/'/g,"\\'")}')" style="cursor:pointer;" title="Click to edit">
                    <div class="fr-name" style="color:var(--accent);text-decoration:underline dotted;">${name}${castle}${pendingTag}</div>
                    <div class="fr-sub">${tax}</div>
                    <div class="fr-units">${units} <span style="color:var(--ink-light)">(${total})</span></div>
                </div>`;
            }).join('')
            : `<div class="fbs-empty">No territories</div>`;

        return `<div class="fbs-section">
            <div class="fbs-section-hdr" style="background:${bg};color:${txt};">
                ${label} &nbsp;·&nbsp; ${territories.length} territories &nbsp;·&nbsp; ${totalUnits} units
            </div>
            ${rows}
        </div>`;
    }).join('');

    document.getElementById('board-content').innerHTML =
        `<button class="fbs-back-btn" onclick="BE.step='list';renderBoardEditor()">‹ Back</button>` +
        sections;
}

function bePickFrom(name) {
    BE.fromTerr = name;
    BE.destTerr = null;
    BE.moveUnits = {F:0,A:0,C:0,S:0};
    BE.step = 'move';
    renderBoardEditor();
}

function bePickDest(name) {
    BE.destTerr = name;
    const bs = G.board;
    const total = unitTotal(bs[BE.fromTerr]?.units || {});
    const leaveN = leaveBehindPlayer(BE.fromTerr);
    const maxMove = Math.max(1, movableCountPlayer(BE.fromTerr));
    BE.moveCount = Math.min(BE.moveCount, maxMove);
    renderBoardEditor();
}

function beAdjUnit(k, v) {
    if (!BE.moveUnits) BE.moveUnits = {F:0,A:0,C:0,S:0};
    const avail = G.board[BE.fromTerr]?.units[k] || 0;
    const maxMove = movableCountPlayer(BE.fromTerr);
    const totalMoving = (BE.moveUnits.F||0)+(BE.moveUnits.A||0)+(BE.moveUnits.C||0)+(BE.moveUnits.S||0);
    if (v > 0) {
        // Adding: check this type has room and total won't exceed max
        if (BE.moveUnits[k] < avail && totalMoving < maxMove) BE.moveUnits[k]++;
    } else {
        if (BE.moveUnits[k] > 0) BE.moveUnits[k]--;
    }
    renderBoardEditor();
}

function beConfirmMove() {
    const from = BE.fromTerr, to = BE.destTerr;
    if (!from || !to || !G.board[from] || !G.board[to]) return;
    const mu = BE.moveUnits || {};
    const count = (mu.F||0)+(mu.A||0)+(mu.C||0)+(mu.S||0);
    if (count <= 0) return;

    const destOwner    = G.board[to].owner;
    const destUnitCnt  = unitTotal(G.board[to].units);
    const isEnemy      = destOwner !== BE.color && destOwner !== 'neutral' && destUnitCnt > 0;

    const desc = ['C','A','F','S']
        .filter(k=>(mu[k]||0)>0)
        .map(k=>mu[k]+({C:'Cav',A:'Arc',F:'Ft',S:'Sie'}[k]))
        .join('+');

    if (isEnemy) {
        // ── ENEMY TERRITORY: queue battle exactly like automaton moves ──
        // Units stay at origin until Combat Phase resolves the fight.
        // roundCombats stores movingUnits so resolveAutoBattle / csFinalize
        // knows exactly which units are committed to the attack.
        if (!G.roundCombats) G.roundCombats = [];
        const already = G.roundCombats.some(c => c.from===from && c.to===to && c.color===BE.color);
        if (!already) {
            G.roundCombats.push({
                color: BE.color,
                from,
                to,
                movingUnits: { ...mu },
                movable: count,
                isEnemy: true,
                _fromEditor: true
            });
        }
        addLog(`⚔ Battle queued: ${BE.color} will attack ${to} (${destOwner}) with ${desc} from ${from} — resolve in Combat Phase.`);
    } else {
        // ── FRIENDLY / NEUTRAL MOVE: apply immediately ──
        for (const k of ['F','A','C','S']) {
            G.board[from].units[k] = Math.max(0, (G.board[from].units[k]||0) - (mu[k]||0));
        }
        for (const k of ['F','A','C','S']) {
            G.board[to].units[k] = (G.board[to].units[k]||0) + (mu[k]||0);
        }
        if (G.board[to].owner === 'neutral') G.board[to].owner = BE.color;
        addLog(`BOARD EDIT: ${cName(BE.color)} moves ${desc} from ${from} to ${to} (manually queued via board editor).`);
    }

    if (!BE.movedFrom) BE.movedFrom = new Set();
    BE.movedFrom.add(from);
    BE.step = 'list'; BE.fromTerr = null; BE.destTerr = null; BE.moveUnits = {F:0,A:0,C:0,S:0};
    renderBoardEditor();
}

function beSetOwner(name, color) {
    // Inline owner correction — same as edit modal, direct update
    if (!G.board[name]) return;
    G.board[name].owner = color;
    if (color === 'neutral') G.board[name].units = {F:0,A:0,C:0,S:0};
    if (CITY_SHIELDS[name]) {
        if (!G.shields) G.shields = {};
        if (color !== 'neutral') G.shields[name] = color;
        else delete G.shields[name];
    }
    renderBoardEditor();
}
function beToggleCastle(name) {
    if (G.board[name]) { G.board[name].castle = !G.board[name].castle; renderBoardEditor(); }
}
// ================================================================
// COMBAT SUBSYSTEM
// ================================================================
const DFACES = ['⚀','⚁','⚂','⚃','⚄','⚅'];

// CS = Combat State
let CS = {};

function csReset() {
    CS = {
        active:false, attackerColor:null, defenderColor:null,
        fromTerr:null, toTerr:null,
        attUnits:null, defUnits:null,   // {F,A,C,S} — updated each phase
        phase:null,     // 'siege'|'archer'|'main'|'result'
        log:[],         // round history strings
        humanAtt:false, humanDef:false,
        humanHits:0, humanReady:false,
        autoRollsAtt:null, autoRollsDef:null,
        pendingStepIdx:-1,
        retreated:false,
    };
}
csReset();

// ── helpers ──────────────────────────────────────────────────────
function csTotal(u){ return (u.F||0)+(u.A||0)+(u.C||0)+(u.S||0); }
function csStr(u){
    const p=[];
    if(u.C>0) p.push(u.C+'Cav');
    if(u.A>0) p.push(u.A+'Arc');
    if(u.F>0) p.push(u.F+'Ft');
    if(u.S>0) p.push(u.S+'Sie');
    return p.length?p.join('+'):'0';
}
function csDice(u,phase){
    if(phase==='siege')  return (u.S||0)*2;           // 2 dice per siege engine (attacker only, vs castle)
    if(phase==='archer') return (u.A||0);              // 1 die per archer
    if(phase==='main')   return (u.C||0)*2+(u.F||0)+(u.A||0)+(u.S||0); // Cav=2, all others=1
    return 0;
}
function csRollN(n){ return Array.from({length:n},()=>{ const v=Math.floor(Math.random()*6)+1; return {v,hit:v>=4,f:DFACES[v-1]}; }); }
function csRemove(u,hits){
    const r={...u}; let rem=hits;
    for(const k of ['F','A','S','C']){ const t=Math.min(r[k]||0,rem); r[k]=(r[k]||0)-t; rem-=t; }
    return r;
}
function csDiff(before,after){
    const d={};
    for(const k of ['F','A','C','S']) d[k]=(before[k]||0)-(after[k]||0);
    return d;
}
function csDescLost(d){
    const p=[];
    if(d.C>0) p.push(d.C+' Cavalry');
    if(d.A>0) p.push(d.A+' Archer'+(d.A>1?'s':''));
    if(d.F>0) p.push(d.F+' Footm'+(d.F>1?'en':'an'));
    if(d.S>0) p.push(d.S+' Siege Engine'+(d.S>1?'s':''));
    return p.length?p.join(', '):'none';
}
function sideColor(color){ return color===S.playerColor?'You ('+color.toUpperCase()+')':color.toUpperCase(); }
function tileStyle(color){
    const bg=COLOR_HEX[color]||'#777';
    const txt=(color==='blue'||color==='green')?'#000':'#fff';
    return 'background:'+bg+';color:'+txt;
}

// ── OPEN COMBAT ──────────────────────────────────────────────────
function openCombat(attackerColor, defenderColor, fromTerr, toTerr, stepIdx){
    // Allow __editor__ as a valid "from" — it means the attacker has no origin territory
    const isEditorBattle = (fromTerr === '__editor__');
    if((!isEditorBattle && !G.board[fromTerr]) || !G.board[toTerr]){
        console.warn('openCombat: territory not found in board state', fromTerr, toTerr);
        if(stepIdx >= 0) G.checkedSteps.add(stepIdx);
        const total = G.currentSteps.filter(s=>s!==null).length;
        document.getElementById('complete-btn').disabled = (G.checkedSteps.size < total);
        renderSteps();
        return;
    }
    csReset();
    CS.active=true;
    CS.attackerColor=attackerColor; CS.defenderColor=defenderColor;
    CS.fromTerr=fromTerr; CS.toTerr=toTerr;
    // '__editor__' battles: attacker units come from the roundCombats entry, not a territory
    if (isEditorBattle) {
        const entry = (G.roundCombats||[]).find(b => b._fromEditor && b.to===toTerr && b.color===attackerColor && !b._resolved);
        CS.attUnits = entry?.movingUnits ? {...entry.movingUnits} : {F:1,A:0,C:0,S:0};
        CS._fromEditor = true;
        // Friendly label shown wherever fromTerr would be displayed
        CS._attLabel = cName(attackerColor) + ' (manually placed)';
    } else {
        CS.attUnits={...G.board[fromTerr].units};
        CS._attLabel = fromTerr;
    }
    CS.defUnits={...G.board[toTerr].units};
    CS.humanAtt=(attackerColor===S.playerColor);
    CS.humanDef=(defenderColor===S.playerColor);
    CS.pendingStepIdx=stepIdx;
    document.getElementById('combat-title').textContent='COMBAT: '+CS._attLabel+' → '+toTerr;

    // Determine starting phase
    const hasCastle=G.board[toTerr].castle;
    const hasSiege=(CS.attUnits.S||0)>0;
    const hasArchers=(CS.attUnits.A||0)>0||(CS.defUnits.A||0)>0;
    if(hasCastle && hasSiege) CS.phase='siege';
    else if(hasArchers) CS.phase='archer';
    else CS.phase='main';

    const autoOnly=!CS.humanAtt && !CS.humanDef;
    if(autoOnly){
        runAutoCombat();
    } else {
        document.getElementById('combat-overlay').classList.add('open');
        preparePhase();
        renderCombatUI();
    }
}

// ── AUTO-ONLY (automa vs automa) ──────────────────────────────────
function runAutoCombat(){
    const log=[];
    let att={...CS.attUnits}, def={...CS.defUnits};
    log.push('Att: '+sideColor(CS.attackerColor)+' ['+csStr(att)+'] vs Def: '+sideColor(CS.defenderColor)+' ['+csStr(def)+']');

    // Siege
    if(CS.phase==='siege'){
        const r=csRollN(csDice(att,'siege'));
        const h=r.filter(d=>d.hit).length;
        const b={...def}; def=csRemove(def,h);
        log.push('⚙ SIEGE: '+r.map(d=>d.f).join('')+' → '+h+' hits → defender loses '+csDescLost(csDiff(b,def)));
        const hasArch=(att.A||0)>0||(def.A||0)>0;
        CS.phase=hasArch?'archer':'main';
    }
    // Archers
    if(CS.phase==='archer'){
        const ra=csRollN(csDice(att,'archer')), rd=csRollN(csDice(def,'archer'));
        const ha=ra.filter(d=>d.hit).length, hd=rd.filter(d=>d.hit).length;
        const ba={...att}, bd={...def};
        def=csRemove(def,ha); att=csRemove(att,hd);
        log.push('🏹 ARCHERS: Att '+ra.map(d=>d.f).join('')+'='+ha+'h | Def '+rd.map(d=>d.f).join('')+'='+hd+'h');
        if(ha>0) log.push('  Def loses: '+csDescLost(csDiff(bd,def)));
        if(hd>0) log.push('  Att loses: '+csDescLost(csDiff(ba,att)));
        CS.phase='main';
    }
    // Main rounds
    let rnd=0;
    while(csTotal(att)>0 && csTotal(def)>0 && rnd<12){
        rnd++;
        const ra=csRollN(csDice(att,'main')), rd=csRollN(csDice(def,'main'));
        const ha=ra.filter(d=>d.hit).length, hd=rd.filter(d=>d.hit).length;
        const ba={...att}, bd={...def};
        def=csRemove(def,ha); att=csRemove(att,hd);
        log.push('⚔ R'+rnd+': Att ['+ra.map(d=>d.f).join('')+']='+ha+'h→Def loses '+csDescLost(csDiff(bd,def))+
                 ' | Def ['+rd.map(d=>d.f).join('')+']='+hd+'h→Att loses '+csDescLost(csDiff(ba,att)));
        log.push('  Remaining — Att:'+csStr(att)+' Def:'+csStr(def));
    }

    const won=csTotal(att)>0 && csTotal(def)===0;
    log.push(won
        ? '✓ '+CS.attackerColor.toUpperCase()+' captures '+CS.toTerr+'! ('+csStr(att)+' remain)'
        : '✗ Defender holds '+CS.toTerr+' ('+csStr(def)+' remain)');

    // Apply board
    csFinalize(won, att, def);
    addLog('Auto-combat: '+(won?CS.attackerColor+' captures '+CS.toTerr:CS.defenderColor+' holds '+CS.toTerr));

    // Show result overlay
    document.getElementById('combat-overlay').classList.add('open');
    document.getElementById('combat-phase-label').textContent='AUTO-RESOLVED';
    document.getElementById('combat-body').innerHTML=
        '<div class="result-banner '+(won?'win':'loss')+'">'+log[log.length-1]+'</div>'+
        '<div class="auto-log" id="alog">'+log.map(l=>'<div class="al">'+l+'</div>').join('')+'</div>'+
        '<button class="btn-fight" onclick="closeCombat()">✓ CLOSE — Continue Turn</button>';
    setTimeout(()=>{ const e=document.getElementById('alog'); if(e) e.scrollTop=e.scrollHeight; },50);
}

// ── INTERACTIVE COMBAT ────────────────────────────────────────────
function preparePhase(){
    CS.autoRollsAtt=null; CS.autoRollsDef=null; CS.humanHits=0; CS.humanReady=false;
    if(CS.phase==='siege'){
        if(!CS.humanAtt) CS.autoRollsAtt=csRollN(csDice(CS.attUnits,'siege'));
        // Human attacker with 0 siege engines: no dice to roll, pre-ready
        if(CS.humanAtt && csDice(CS.attUnits,'siege')===0) CS.humanReady=true;
    } else if(CS.phase==='archer'){
        if(!CS.humanAtt && (CS.attUnits.A||0)>0) CS.autoRollsAtt=csRollN(csDice(CS.attUnits,'archer'));
        if(!CS.humanDef && (CS.defUnits.A||0)>0) CS.autoRollsDef=csRollN(csDice(CS.defUnits,'archer'));
        // Human side with 0 archers: pre-ready (other side's archers may still fire)
        if(CS.humanAtt && csDice(CS.attUnits,'archer')===0) CS.humanReady=true;
        if(CS.humanDef && csDice(CS.defUnits,'archer')===0) CS.humanReady=true;
    } else if(CS.phase==='main'){
        if(!CS.humanAtt) CS.autoRollsAtt=csRollN(csDice(CS.attUnits,'main'));
        if(!CS.humanDef) CS.autoRollsDef=csRollN(csDice(CS.defUnits,'main'));
        // Human side with 0 combat units: pre-ready (they're about to lose)
        if(CS.humanAtt && csDice(CS.attUnits,'main')===0) CS.humanReady=true;
        if(CS.humanDef && csDice(CS.defUnits,'main')===0) CS.humanReady=true;
    }
}

function renderCombatUI(){
    const phaseNames={siege:'SIEGE PRE-BATTLE',archer:'ARCHER VOLLEY',main:'MAIN COMBAT — ROUND '+(CS.log.filter(l=>l.startsWith('⚔')).length+1),result:'RESULT'};
    document.getElementById('combat-phase-label').textContent=phaseNames[CS.phase]||CS.phase.toUpperCase();

    if(CS.phase==='result'){ renderResult(); return; }

    const attTotal=csTotal(CS.attUnits), defTotal=csTotal(CS.defUnits);
    const castleIcon=G.board[CS.toTerr]?.castle?' 🏰':'';

    // Sides header
    const sidesHTML=
        '<div class="combat-sides-row">'+
            '<div class="combat-side" style="'+tileStyle(CS.attackerColor)+'">'+
                '<div class="sl">ATTACKER</div>'+
                '<div class="sn">'+sideColor(CS.attackerColor)+'<br><span style="font-weight:400;font-size:0.85em;">'+(CS._attLabel||CS.fromTerr)+'</span></div>'+
                '<div class="su">'+csStr(CS.attUnits)+' ('+attTotal+' total)</div>'+
            '</div>'+
            '<div class="combat-vs">⚔</div>'+
            '<div class="combat-side" style="'+tileStyle(CS.defenderColor)+'">'+
                '<div class="sl">DEFENDER'+castleIcon+'</div>'+
                '<div class="sn">'+sideColor(CS.defenderColor)+'<br><span style="font-weight:400;font-size:0.85em;">'+CS.toTerr+'</span></div>'+
                '<div class="su">'+csStr(CS.defUnits)+' ('+defTotal+' total)</div>'+
            '</div>'+
        '</div>';

    // Phase explanation
    const explainMap={
        siege:'<b>SIEGE PRE-BATTLE:</b> Siege Engines fire first. Each Siege Engine rolls 2 dice (hit on 4+). Only the defender takes hits — archers and main combat come after.',
        archer:'<b>ARCHER VOLLEY:</b> Both sides\' archers fire simultaneously before main combat. Each archer rolls 1 die (hit on 4+). Both sides remove casualties at the same time.',
        main:'<b>MAIN COMBAT:</b> Both sides fight simultaneously. Each Cavalry unit rolls 2 dice, each Footman rolls 1 die. Hit on 4+. Both sides apply hits simultaneously.',
    };
    const explainHTML='<div class="info-box" style="margin-bottom:10px;">'+explainMap[CS.phase]+'</div>';

    // Round log
    const logHTML=CS.log.length?
        '<div class="round-log">'+CS.log.map(l=>'<div class="round-log-entry">'+l+'</div>').join('')+'</div>':'';

    // Dice sections
    function diceHTML(rolls, label){
        if(!rolls||!rolls.length) return '';
        const hits=rolls.filter(d=>d.hit).length;
        return '<div class="dice-section"><h5>'+label+'</h5>'+
            '<div class="dice-row">'+
            rolls.map(d=>'<div class="die-face '+(d.hit?'hit':'miss')+'">'+d.f+'</div>').join('')+
            '&nbsp;<span class="hits-summary '+(hits>0?'some':'none')+'">= '+hits+' hit'+(hits!==1?'s':'')+'</span>'+
            '</div></div>';
    }
    function humanHTML(diceCount, label){
        if(!diceCount) return '';
        return '<div class="human-roll-box"><h5>⚔ YOUR ROLL — '+label+'</h5>'+
            '<div>Roll <span class="dice-count-big">'+diceCount+'</span> dice &nbsp;&nbsp;<b>Hit on 4, 5, or 6</b></div>'+
            '<div class="hit-input-row">'+
                '<span>Your hits:</span>'+
                '<button class="hs-btn" onclick="csAdjHits(-1)">−</button>'+
                '<span class="hs-val" id="hs-val">'+CS.humanHits+'</span>'+
                '<button class="hs-btn" onclick="csAdjHits(1)">+</button>'+
                '<span style="color:var(--ink-light);font-size:0.85em;">(max '+diceCount+')</span>'+
            '</div>'+
            (CS.humanReady?'<div style="color:#1e7e44;font-size:0.85em;margin-top:6px;">✓ '+CS.humanHits+' hit'+(CS.humanHits!==1?'s':'')+'  recorded — tap Apply Hits to continue.</div>':'')+
        '</div>';
    }

    // Determine what to show per side per phase
    let attSection='', defSection='';
    if(CS.phase==='siege'){
        attSection=CS.humanAtt?humanHTML(csDice(CS.attUnits,'siege'),'Siege Engine (attacker)'):diceHTML(CS.autoRollsAtt,CS.attackerColor.toUpperCase()+' Siege Engine rolls');
        // No defender dice in siege phase
    } else if(CS.phase==='archer'){
        if((CS.attUnits.A||0)>0) attSection=CS.humanAtt?humanHTML(csDice(CS.attUnits,'archer'),'Archers (attacker)'):diceHTML(CS.autoRollsAtt,CS.attackerColor.toUpperCase()+' Archers roll');
        if((CS.defUnits.A||0)>0) defSection=CS.humanDef?humanHTML(csDice(CS.defUnits,'archer'),'Archers (defender)'):diceHTML(CS.autoRollsDef,CS.defenderColor.toUpperCase()+' Archers roll');
    } else if(CS.phase==='main'){
        attSection=CS.humanAtt?humanHTML(csDice(CS.attUnits,'main'),'Main combat (attacker)'):diceHTML(CS.autoRollsAtt,CS.attackerColor.toUpperCase()+' rolls');
        defSection=CS.humanDef?humanHTML(csDice(CS.defUnits,'main'),'Main combat (defender)'):diceHTML(CS.autoRollsDef,CS.defenderColor.toUpperCase()+' rolls');
    }

    // Only block if human has dice to roll this specific phase
    const humanDiceAtt = CS.humanAtt ? csDice(CS.attUnits, CS.phase==='siege'?'siege':CS.phase==='archer'?'archer':'main') : 0;
    const humanDiceDef = CS.humanDef ? csDice(CS.defUnits, CS.phase==='archer'?'archer':CS.phase==='main'?'main':0) : 0;
    const needsInput = (humanDiceAtt > 0 || humanDiceDef > 0);
    const btnLabel=CS.phase==='main'?'APPLY HITS — NEXT ROUND':'APPLY HITS — CONTINUE';
    const canApply=!needsInput||CS.humanReady;

    const btnsHTML='<div class="combat-btn-row">'+
        '<button class="btn-fight" id="cs-apply-btn" onclick="csApply()" '+(canApply?'':'disabled')+'>'+
            (canApply?btnLabel:'Enter your hits above first →')+
        '</button>'+
        (CS.phase==='main'?'<button class="btn-retreat" onclick="csRetreat()">↩ Retreat</button>':'')+
    '</div>';

    document.getElementById('combat-body').innerHTML=
        sidesHTML+explainHTML+logHTML+attSection+defSection+btnsHTML;
}

function csAdjHits(v){
    const phase=CS.phase;
    const isAtt=CS.humanAtt;
    const u=isAtt?CS.attUnits:CS.defUnits;
    const maxDice=csDice(u,phase);
    CS.humanHits=Math.max(0,Math.min(maxDice,CS.humanHits+v));
    CS.humanReady=true;
    const el=document.getElementById('hs-val');
    if(el) el.textContent=CS.humanHits;
    const btn=document.getElementById('cs-apply-btn');
    if(btn){ btn.disabled=false; btn.textContent='APPLY HITS — '+(phase==='main'?'NEXT ROUND':'CONTINUE'); }
}

function csApply(){
    const attHits=CS.humanAtt?CS.humanHits:(CS.autoRollsAtt?CS.autoRollsAtt.filter(d=>d.hit).length:0);
    const defHits=CS.humanDef?CS.humanHits:(CS.autoRollsDef?CS.autoRollsDef.filter(d=>d.hit).length:0);
    const ba={...CS.attUnits}, bd={...CS.defUnits};

    if(CS.phase==='siege'){
        CS.defUnits=csRemove(CS.defUnits,attHits);
        const lost=csDescLost(csDiff(bd,CS.defUnits));
        CS.log.push('⚙ SIEGE: '+attHits+' hits → defender loses '+lost);
        // tell player what to remove
        if(attHits>0) showCasualtyReport('Defender ('+CS.defenderColor.toUpperCase()+') removes from '+CS.toTerr+': '+lost);
        const hasArch=(CS.attUnits.A||0)>0||(CS.defUnits.A||0)>0;
        CS.phase=hasArch?'archer':'main';

    } else if(CS.phase==='archer'){
        CS.defUnits=csRemove(CS.defUnits,attHits);
        CS.attUnits=csRemove(CS.attUnits,defHits);
        const attLost=csDescLost(csDiff(ba,CS.attUnits));
        const defLost=csDescLost(csDiff(bd,CS.defUnits));
        CS.log.push('🏹 ARCHERS: Att '+attHits+'h → Def loses '+defLost+' | Def '+defHits+'h → Att loses '+attLost);
        const msgs=[];
        if(attHits>0) msgs.push('Defender ('+CS.defenderColor.toUpperCase()+') removes '+defLost+' from '+CS.toTerr);
        if(defHits>0) msgs.push('Attacker ('+CS.attackerColor.toUpperCase()+') removes '+attLost+' from '+CS.fromTerr);
        if(msgs.length) showCasualtyReport(msgs.join('<br>'));
        CS.phase='main';

    } else if(CS.phase==='main'){
        CS.defUnits=csRemove(CS.defUnits,attHits);
        CS.attUnits=csRemove(CS.attUnits,defHits);
        const attLost=csDescLost(csDiff(ba,CS.attUnits));
        const defLost=csDescLost(csDiff(bd,CS.defUnits));
        const rndNum=CS.log.filter(l=>l.startsWith('⚔')).length+1;
        CS.log.push('⚔ R'+rndNum+': Att '+attHits+'h → Def loses '+defLost+' | Def '+defHits+'h → Att loses '+attLost);
        const msgs=[];
        if(attHits>0) msgs.push('<b>Remove from '+CS.toTerr+':</b> '+defLost);
        if(defHits>0) msgs.push('<b>Remove from '+CS.fromTerr+':</b> '+attLost);
        if(msgs.length) showCasualtyReport(msgs.join('<br>'));
    }

    CS.humanHits=0; CS.humanReady=false;
    const attAlive=csTotal(CS.attUnits)>0, defAlive=csTotal(CS.defUnits)>0;
    if(!attAlive||!defAlive) CS.phase='result';
    preparePhase();
    renderCombatUI();
}

function showCasualtyReport(msg){
    // Prepend a casualty instruction box — called before renderCombatUI overwrites body
    // Store for rendering
    CS._casualtyMsg=msg;
}

function csRetreat(){
    const retLabel = CS._fromEditor ? 'off the board' : 'back to '+CS.fromTerr;
    if(!confirm('Retreat '+CS.attackerColor.toUpperCase()+' '+retLabel+'?')) return;
    CS.retreated=true;
    CS.log.push('↩ Attacker retreats '+(CS._fromEditor ? '(removed from board)' : 'to '+CS.fromTerr));
    CS.phase='result';
    renderCombatUI();
}

function renderResult(){
    const attAlive=csTotal(CS.attUnits)>0, defAlive=csTotal(CS.defUnits)>0;
    const won=attAlive&&!defAlive&&!CS.retreated;
    const held=CS.retreated||(!attAlive&&defAlive);

    let msg='', cls='';
    if(CS.retreated){
        msg='↩ '+CS.attackerColor.toUpperCase()+' retreats. '+CS.defenderColor.toUpperCase()+' holds '+CS.toTerr+'.';
        if(CS._fromEditor) msg='↩ '+CS.attackerColor.toUpperCase()+' retreats (units removed). '+CS.defenderColor.toUpperCase()+' holds '+CS.toTerr+'.';
        cls='draw';
    } else if(won){
        msg='✓ '+CS.attackerColor.toUpperCase()+' captures '+CS.toTerr+'! ('+csStr(CS.attUnits)+' remain)';
        cls='win';
    } else {
        msg='✗ Attacker eliminated. '+CS.defenderColor.toUpperCase()+' holds '+CS.toTerr+' ('+csStr(CS.defUnits)+' remain)';
        cls='loss';
    }

    csFinalize(won, CS.attUnits, CS.defUnits);

    document.getElementById('combat-phase-label').textContent='RESULT';
    document.getElementById('combat-body').innerHTML=
        '<div class="result-banner '+cls+'">'+msg+'</div>'+
        '<div class="round-log" style="max-height:200px;">'+
            CS.log.map(l=>'<div class="round-log-entry">'+l+'</div>').join('')+
        '</div>'+
        '<button class="btn-fight" style="margin-top:12px;" onclick="closeCombat()">✓ CLOSE — Continue Turn</button>';
}

function csFinalize(attackerWon, finalAtt, finalDef){
    const from=CS.fromTerr, to=CS.toTerr;
    const isEditor = (from === '__editor__');
    if((!isEditor && !G.board[from]) || !G.board[to]) return;

    // Normal path
    if (from !== '__editor__') {
        const leaveN = leaveBehindCount(from);
        G.board[from].units=unitsToLeave(from,leaveN);
    }
    if(attackerWon){
        G.board[to].owner=CS.attackerColor;
        G.board[to].units={F:finalAtt.F||0,A:finalAtt.A||0,C:finalAtt.C||0,S:finalAtt.S||0};
    } else {
        G.board[to].units={F:finalDef.F||0,A:finalDef.A||0,C:finalDef.C||0,S:finalDef.S||0};
        if(CS.retreated && csTotal(finalAtt)>0){
            G.board[from].units.F=(G.board[from].units.F||0)+(finalAtt.F||0);
            G.board[from].units.A=(G.board[from].units.A||0)+(finalAtt.A||0);
            G.board[from].units.C=(G.board[from].units.C||0)+(finalAtt.C||0);
            G.board[from].units.S=(G.board[from].units.S||0)+(finalAtt.S||0);
        }
    }
    for(const mv of G.pendingMoves||[]){
        if(mv&&mv.from===from&&mv.to===to) mv._applied=true;
    }
    render();
}

function closeCombat(){
    document.getElementById('combat-overlay').classList.remove('open');

    // If we came from the Combat Phase, mark battle resolved and re-render CP
    if (CP.returnToCombatPhase) {
        CP.returnToCombatPhase = false;
        const idx = CP.activeBattleIdx;
        const b = G.roundCombats[idx];
        if (b) {
            const attackerWon = csTotal(CS.attUnits) > 0 && csTotal(CS.defUnits) === 0 && !CS.retreated;
            const defHeld     = CS.retreated || csTotal(CS.defUnits) > 0;
            b._resolved = true;
            b._result   = attackerWon ? 'Attacker won' : defHeld ? 'Defender held' : 'Both eliminated';
            b._log      = CS.log.join('<br>');
            // Award crowns + shield if attacker captured a city
            if (attackerWon) {
                const defColor = G.board[b.to]?.owner; // already updated by csFinalize
                const cv = crownValueOfCity(b.to);
                if (cv > 0) {
                    if (!G.crowns) G.crowns = {};
                    G.crowns[b.color] = (G.crowns[b.color]||0) + cv;
                    addLog(`${cName(b.color)} moves ${unitStr(b.movingUnits||{})} from ${b.from} to ${cityLabel(b.to)}. ${cityLabel(b.to)} is captured and ${cName(b.color)} gains ${cv} Crown${cv>1?'s':''} (banner now at ${G.crowns[b.color]}).`);
                    checkWin(b.color);
                }
                if (CITY_SHIELDS[b.to]) {
                    if (!G.shields) G.shields = {};
                    G.shields[b.to] = b.color;
                    addLog('🛡 ' + cName(b.color) + ' gains the ' + b.to + ' shield.');
                    showShieldReminder(b.to, b.color);
                }
                showShieldReminder('Stockholm', b.color);
                applyShieldBonus('Stockholm', b.color, 'battle_win');
            }
        }
        CP.idx = (idx || 0) + 1;
        csReset();
        renderCombatPhase();
        return;
    }

    // Normal in-turn combat close
    let stepIdx = CS.pendingStepIdx;
    if (stepIdx < 0) stepIdx = findStepIdxContaining('START COMBAT');
    if (stepIdx >= 0) G.checkedSteps.add(stepIdx);
    const total = G.currentSteps.filter(s=>s!==null).length;
    const _cb2 = document.getElementById('complete-btn');
    if(_cb2) _cb2.disabled = (G.checkedSteps.size < total);
    renderSteps();
    csReset();
    render();
}


// ================================================================
// HUMAN TURN
// ================================================================

// ── Shield helper ──────────────────────────────────────────────
function humanShieldBox(city) {
    const sh = CITY_SHIELDS[city];
    if (!sh || !G.shields || G.shields[city] !== S.playerColor) return '';
    return '<div class="shield-reminder">' + sh.reminder + '</div>';
}

// ── Which cards require a variant choice? ──────────────────────
// Returns array of {value, label} objects, or [] if no choice needed.
// Structure of the 8 cards:
//   No-bonus cards (4):  TAX OR SPEND (×2), SPLIT EXPAND OR MANEUVER (×2)
//   Bonus cards (4):     KING ME / TAX OR SPEND,
//                        SIEGE ASSAULT / EXPAND OR MANEUVER,
//                        FORTIFY / EXPAND OR MANEUVER (×2)
//
// For bonus cards the bonus action is OPTIONAL — the player picks their combination.
function humanCardVariants(card) {
    const hasBerlin = !!(G.shields && G.shields['Berlin'] === S.playerColor);
    const bExpand   = hasBerlin ? 'EXPAND (+ Berlin bonus Maneuver)' : 'EXPAND';

    // ── No-bonus cards ────────────────────────────────────────
    if (card === 'TAX OR SPEND') return [
        { value:'TAX',   label:'TAX — collect from a city' },
        { value:'SPEND', label:'SPEND — buy units' },
    ];

    if (card === 'SPLIT EXPAND OR MANEUVER') return [
        { value:'SPLIT_EXPAND', label: hasBerlin
            ? 'SPLIT EXPAND (+ Berlin bonus Maneuver)'
            : 'SPLIT EXPAND — up to 2 territories into a city' },
        { value:'MANEUVER', label:'MANEUVER — move up to 2 territories' },
    ];

    // ── Bonus cards — bonus is OPTIONAL ──────────────────────
    if (card === 'KING ME / TAX OR SPEND') return [
        { value:'KINGME_TAX',   label:'KING ME (bonus) + TAX — claim First Player, then tax a city' },
        { value:'KINGME_SPEND', label:'KING ME (bonus) + SPEND — claim First Player, then buy units' },
        { value:'TAX',          label:'Skip King Me — TAX only' },
        { value:'SPEND',        label:'Skip King Me — SPEND only' },
    ];

    if (card === 'FORTIFY / EXPAND OR MANEUVER') return [
        { value:'FORTIFY_EXPAND',   label:'FORTIFY (bonus) + ' + bExpand },
        { value:'FORTIFY_MANEUVER', label:'FORTIFY (bonus) + MANEUVER' },
        { value:'EXPAND',           label:'Skip Fortify — ' + bExpand + ' only' },
        { value:'MANEUVER',         label:'Skip Fortify — MANEUVER only' },
    ];

    if (card === 'SIEGE ASSAULT / EXPAND OR MANEUVER') return [
        { value:'SIEGE_EXPAND',   label:'SIEGE ASSAULT (bonus) + ' + bExpand },
        { value:'SIEGE_MANEUVER', label:'SIEGE ASSAULT (bonus) + MANEUVER' },
        { value:'EXPAND',         label:'Skip Siege — ' + bExpand + ' only' },
        { value:'MANEUVER',       label:'Skip Siege — MANEUVER only' },
    ];

    return []; // shouldn't happen with 8 correct cards
}

// ── Build checklist steps for card + chosen variant ────────────
// variant string encodes the full combination, e.g. 'KINGME_TAX', 'FORTIFY_EXPAND', 'MANEUVER'
function generateHumanSteps(card, variant) {
    const pc    = S.playerColor;
    const coins = G.coins[pc] || 0;
    const steps = [];

    const taxShields   = humanShieldBox('Paris') + humanShieldBox('Madrid') + humanShieldBox('London');
    const spendShields = humanShieldBox('Constantinople') + humanShieldBox('Kiev');
    const berlinShield = humanShieldBox('Berlin');
    const stockholmNote = (G.shields && G.shields['Stockholm'] === pc)
        ? '<div class="shield-reminder">' + CITY_SHIELDS['Stockholm'].reminder + '</div>' : '';

    const leaveRule   = '<span class="rule-note">Leave-behind: <b>Tax value</b> in units at cities, <b>1 unit</b> at non-urban territories.</span>';
    const manRule     = '<span class="rule-note">Maneuver: up to 2 territories through your <b>own</b> territories. Cannot leave a disputed territory.</span>';
    const berlinBonus = berlinShield
        ? berlinShield + '<b>BERLIN BONUS — MANEUVER:</b> You may also Maneuver one army up to 2 territories.<br>' + manRule
        : null;

    // ── Helpers ───────────────────────────────────────────────
    function pushTax() {
        steps.push({ id:'check', text:
            '<b>TAX:</b> Choose one of your cities and collect its yield.<br>'
            + 'Yield = city Tax value + 1 per connected non-urban territory + Tax of connected owned cities.<br>'
            + taxShields
            + '<span class="rule-note">Add coins with the [+] button in your tile.</span>' });
        steps.push({ id:'board', text:'<b>Apply any free units</b> from shield bonuses (Paris, Madrid, London) to the board then update board state.' });
    }
    function pushSpend() {
        steps.push({ id:'check', text:
            '<b>SPEND:</b> You have <b>' + coins + ' coins</b> — buy from the Spend Table and place units.<br>'
            + spendShields
            + '<span class="rule-note">Remove coins with the [−] button.</span>' });
        steps.push({ id:'board', text:'<b>Update board state</b> — place the units you purchased.' });
    }
    function pushExpand(qualifier) {
        const q = qualifier ? qualifier + ' ' : '';
        steps.push({ id:'check', text:
            '<b>EXPAND:</b> Choose your ' + q + 'largest army adjacent to a city you don\'t own. Move all but the leave-behind into that city.<br>' + leaveRule });
        steps.push({ id:'board', text:'<b>Update board state.</b> If the city is enemy-held, use the Board Editor to queue the battle for the Combat Phase.' });
        if (berlinBonus) {
            steps.push({ id:'check', text: berlinBonus });
            steps.push({ id:'board', text:'<b>Update board state</b> for the Berlin bonus Maneuver.' });
        }
    }
    function pushManeuver() {
        steps.push({ id:'check', text:
            '<b>MANEUVER:</b> Move one of your armies up to 2 territories through your own territories.<br>' + leaveRule + manRule });
        steps.push({ id:'board', text:'<b>Update board state</b> — record your maneuver.' });
    }
    function pushCrowns() {
        steps.push({ id:'check', text:'<b>Check Crown points</b> — did you capture a city? Update your crown total.' + stockholmNote });
    }

    // ═══════════════════════════════════════════════════════════
    // TAX OR SPEND  (plain card — no bonus)
    // ═══════════════════════════════════════════════════════════
    if (card === 'TAX OR SPEND') {
        if (variant === 'TAX')   pushTax();
        else                     pushSpend();
        steps.push({ id:'check', text:'<b>Coins updated?</b> Confirm your coin total is correct.' + stockholmNote });
        return steps;
    }

    // ═══════════════════════════════════════════════════════════
    // SPLIT EXPAND OR MANEUVER  (plain card — no bonus)
    // ═══════════════════════════════════════════════════════════
    if (card === 'SPLIT EXPAND OR MANEUVER') {
        if (variant === 'SPLIT_EXPAND') {
            steps.push({ id:'check', text:
                '<b>SPLIT EXPAND:</b> Move an army up to 2 territories into a city — you may pass through one of your own territories en route.<br>' + leaveRule
                + '<span class="rule-note">Only pass through <b>own</b> territories. 1-step entries are also valid. Need a Siege Engine to enter a castle city.</span>' });
            steps.push({ id:'board', text:'<b>Update board state.</b> If the destination is enemy-held, use the Board Editor to queue the battle.' });
            if (berlinBonus) {
                steps.push({ id:'check', text: berlinBonus });
                steps.push({ id:'board', text:'<b>Update board state</b> for the Berlin bonus Maneuver.' });
            }
        } else {
            pushManeuver();
        }
        pushCrowns();
        return steps;
    }

    // ═══════════════════════════════════════════════════════════
    // KING ME / TAX OR SPEND  (bonus = KING ME, optional)
    // ═══════════════════════════════════════════════════════════
    if (card === 'KING ME / TAX OR SPEND') {
        const doKingMe = variant === 'KINGME_TAX' || variant === 'KINGME_SPEND';
        if (doKingMe) {
            steps.push({ id:'check', text:
                '<b>KING ME (BONUS):</b> Claim the First Player marker — you go first next round.<br>'
                + '<span class="rule-note">Tap the 🪙 coin icon on your player tile to mark this. The change takes effect at the start of the next round.</span>' });
        }
        if (variant === 'KINGME_TAX' || variant === 'TAX')   pushTax();
        else                                                   pushSpend();
        steps.push({ id:'check', text:'<b>Coins updated?</b> Confirm your coin total is correct.' + stockholmNote });
        return steps;
    }

    // ═══════════════════════════════════════════════════════════
    // FORTIFY / EXPAND OR MANEUVER  (bonus = FORTIFY, optional)
    // ═══════════════════════════════════════════════════════════
    if (card === 'FORTIFY / EXPAND OR MANEUVER') {
        const doFortify = variant === 'FORTIFY_EXPAND' || variant === 'FORTIFY_MANEUVER';
        if (doFortify) {
            steps.push({ id:'board', text:
                '<b>FORTIFY (BONUS):</b> Place <b>+3 Footmen</b> (or <b>+4</b> if the chosen city has a castle) in one of your cities.<br>'
                + '<span class="rule-note">Priority: fewest units → highest Tax value → Capital beats regular city → roll a die on a tie. Update board state.</span>' });
        }
        const doExpand = variant === 'FORTIFY_EXPAND' || variant === 'EXPAND';
        if (doExpand) pushExpand(doFortify ? 'remaining' : null);
        else          pushManeuver();
        pushCrowns();
        return steps;
    }

    // ═══════════════════════════════════════════════════════════
    // SIEGE ASSAULT / EXPAND OR MANEUVER  (bonus = SIEGE ASSAULT, optional)
    // ═══════════════════════════════════════════════════════════
    if (card === 'SIEGE ASSAULT / EXPAND OR MANEUVER') {
        const doSiege  = variant === 'SIEGE_EXPAND' || variant === 'SIEGE_MANEUVER';
        const doExpand = variant === 'SIEGE_EXPAND'  || variant === 'EXPAND';
        if (doSiege) {
            steps.push({ id:'check', text:
                '<b>SIEGE ASSAULT (BONUS):</b> Move an army that includes a Siege Engine into an adjacent enemy city with a castle.<br>'
                + '<span class="rule-note">Siege Engines fire first: each rolls 2 dice (hit on 4+), defender removes casualties before main combat begins.</span>' });
            steps.push({ id:'board', text:'<b>Queue the siege battle</b> — open the Board Editor, record your attacking army at the target city. It resolves in the Combat Phase.' });
        }
        if (doExpand) pushExpand(doSiege ? 'separate' : null);
        else          pushManeuver();
        pushCrowns();
        return steps;
    }

    // Fallback
    steps.push({ id:'check', text:'<b>' + card + '</b> — resolve per rulebook. ✓ when done.' });
    steps.push({ id:'board', text:'<b>Update board state</b> if anything changed.' });
    return steps;
}


// ================================================================
// HUMAN INTERACTIVE TURN FLOW
// ================================================================
// leaveBehindPlayer: human rule is always 1 unit (not tax-value)
function leaveBehindPlayer(_name) { return 1; }

// ── Board query helpers ────────────────────────────────────────
function humanIsDisputed(name) {
    return (G.roundCombats||[]).some(b => b.to === name && !b._resolved);
}
function humanOwnedCities() {
    const pc = S.playerColor;
    return Object.keys(G.board).filter(n => G.board[n].owner === pc && (T[n]?.tax||0) > 0)
        .map(n => ({ name:n, tax:T[n].tax, units:totalUnitCount(n), hasCastle:!!G.board[n].castle }));
}
function humanMoveFromOpts() {
    const pc = S.playerColor;
    return Object.keys(G.board).filter(n =>
        G.board[n].owner === pc && !humanIsDisputed(n) && totalUnitCount(n) > 1
    ).map(n => ({ name:n, tax:T[n]?.tax||0, units:totalUnitCount(n), movable:totalUnitCount(n)-1 }));
}
function humanExpandToOpts(from) {
    const pc = S.playerColor;
    const hasSiege = (G.board[from]?.units?.S||0) > 0;
    return (T[from]?.adj||[]).filter(n => {
        if (!G.board[n]) return false;
        if (G.board[n].owner === pc) return false;          // can't expand into own territory
        // Enemy-held castles require siege engine to attack
        if (G.board[n].owner !== 'neutral' && G.board[n].castle && !hasSiege) return false;
        return true;
    }).map(n => ({
        name:n, owner:G.board[n].owner||'neutral', tax:T[n]?.tax||0,
        isCity: (T[n]?.tax||0) > 0,
        units:totalUnitCount(n), hasCastle:!!G.board[n].castle, via:null,
        needsSiege: G.board[n].owner !== 'neutral' && G.board[n].castle && !hasSiege
    }));
}
function humanSplitExpandToOpts(from, excludedDests=[]) {
    const pc = S.playerColor, seen = new Set(excludedDests), results = [];
    const hasSiege = (G.board[from]?.units?.S||0) > 0;
    function canTarget(n) {
        if (!G.board[n]) return false;
        if (G.board[n].owner === pc) return false;                         // not own territory
        if (G.board[n].owner !== 'neutral' && G.board[n].castle && !hasSiege) return false; // enemy castle needs siege
        return true;
    }
    for (const adj of (T[from]?.adj||[])) {
        if (!canTarget(adj)||seen.has(adj)) continue;
        seen.add(adj); results.push({name:adj,via:null,owner:G.board[adj].owner,tax:T[adj].tax,hasCastle:!!G.board[adj].castle,units:totalUnitCount(adj)});
    }
    for (const mid of (T[from]?.adj||[])) {
        if (!G.board[mid]||G.board[mid].owner!==pc) continue;
        for (const dest of (T[mid]?.adj||[])) {
            if (dest===from||seen.has(dest)||!canTarget(dest)) continue;
            seen.add(dest); results.push({name:dest,via:mid,owner:G.board[dest].owner,tax:T[dest].tax,hasCastle:!!G.board[dest].castle,units:totalUnitCount(dest)});
        }
    }
    return results;
}
function humanManeuverToOpts(from) {
    const pc = S.playerColor, results = [], visited = new Set([from]);
    const queue = [{name:from,hops:0,via:null}];
    while (queue.length) {
        const {name:cur,hops,via:prevVia} = queue.shift();
        if (hops>=2) continue;
        for (const adj of (T[cur]?.adj||[])) {
            if (visited.has(adj)||!G.board[adj]||G.board[adj].owner!==pc) continue;
            visited.add(adj);
            const via = hops===1 ? prevVia||cur : null;
            results.push({name:adj,hops:hops+1,disputed:humanIsDisputed(adj),units:totalUnitCount(adj),via});
            if (!humanIsDisputed(adj)) queue.push({name:adj,hops:hops+1,via:via||cur});
        }
    }
    return results;
}
function humanSiegeFromOpts() {
    const pc = S.playerColor;
    return Object.keys(G.board).filter(n =>
        G.board[n].owner===pc && !humanIsDisputed(n) && (G.board[n].units?.S||0)>0 && totalUnitCount(n)>1
    ).map(n => ({name:n, units:totalUnitCount(n)}));
}
function humanSiegeToOpts(from) {
    const pc = S.playerColor;
    return (T[from]?.adj||[]).filter(n => G.board[n]&&G.board[n].castle&&G.board[n].owner!==pc)
        .map(n => ({name:n, owner:G.board[n].owner||'neutral', tax:T[n]?.tax||0, units:totalUnitCount(n)}));
}
function humanSpendOpts() {
    const coins = G.coins[S.playerColor]||0;
    return Object.keys(SPEND_TABLE).map(Number).filter(k=>k<=coins).sort((a,b)=>b-a)
        .map(k => ({cost:k, items:SPEND_TABLE[k]}));
}
// Moving units: leave 1 weakest unit behind
function humanMovingUnits(from) {
    const u = Object.assign({F:0,A:0,C:0,S:0}, G.board[from]?.units);
    for (const k of ['F','A','C','S']) { if (u[k]>0) { u[k]--; break; } }
    return u;
}
// Siege: must include Siege Engine; leave 1 non-siege behind
function humanSiegeMovingUnits(from) {
    const u = Object.assign({F:0,A:0,C:0,S:0}, G.board[from]?.units);
    let leftOne=false;
    for (const k of ['F','A','C']) { if(!leftOne&&u[k]>0){u[k]--;leftOne=true;break;} }
    if (!leftOne&&u.S>0) { u.S--; }
    return u;
}
// Apply a move to G.board; returns result object
function applyHumanMove(from, to, moving) {
    const pc = S.playerColor;
    const defOwner = G.board[to]?.owner || 'neutral';
    // Deduct from source
    ['F','A','C','S'].forEach(k => { G.board[from].units[k]=Math.max(0,(G.board[from].units[k]||0)-(moving[k]||0)); });
    if (defOwner === pc) {
        ['F','A','C','S'].forEach(k => { G.board[to].units[k]=(G.board[to].units[k]||0)+(moving[k]||0); });
        return {type:'friendly', outcome:`Moved to ${to}.`, boardReminder:`Move <b>${unitStr(moving)}</b> from ${from} to <b>${to}</b> on your board.`};
    } else if (defOwner === 'neutral') {
        G.board[to].owner = pc;
        G.board[to].units = {F:moving.F||0,A:moving.A||0,C:moving.C||0,S:moving.S||0};
        const cv = crownValueOfCity(to);
        if (cv>0) { G.crowns[pc]=(G.crowns[pc]||0)+cv; checkWin(pc); }
        const crownNote = cv>0 ? ` +${cv} Crown${cv>1?'s':''}! (now ${G.crowns[pc]} total)` : '';
        const _sk = shieldKeyForTerr(to);
        if (_sk) { G.shields=G.shields||{}; G.shields[_sk]=pc; }
        return {type:cv>0?'capture_crown':'capture', crowns:cv, outcome:`Captured ${to}!${crownNote}`, boardReminder:`Move <b>${unitStr(moving)}</b> to <b>${to}</b>. Change ownership flag to yours.${crownNote}`};
    } else {
        if (!G.roundCombats) G.roundCombats=[];
        const already=G.roundCombats.some(c=>c.from===from&&c.to===to&&c.color===pc);
        if (!already) G.roundCombats.push({color:pc,from,to,movingUnits:{...moving},movable:Object.values(moving).reduce((a,b)=>a+b,0),isEnemy:true,_prededucted:true});
        return {type:'combat', outcome:`⚔ Battle queued vs ${defOwner}.`, boardReminder:`Move <b>${unitStr(moving)}</b> from <b>${from}</b>. Note the pending attack on <b>${to}</b> — it resolves in the Combat Phase.`};
    }
}

// ── Flow construction ──────────────────────────────────────────
function buildHumanFlow(card, variant) {
    const pc = S.playerColor;
    const hasBerlin = !!(G.shields && G.shields['Berlin'] === pc);
    const steps = [];
    function mk(type, label, optional=false) {
        const compound = ['expand','split_expand','split_expand_1','split_expand_2','maneuver','siege'].includes(type);
        return {type, label, optional, state: compound ? 'pick_from' : 'pending', from:null, to:null, summary:null, boardReminder:null};
    }
    function addExpand(lbl) { steps.push(mk('expand', lbl||'EXPAND — choose your move')); }
    function addManeuver(lbl, opt=false) { steps.push(mk('maneuver', lbl||'MANEUVER — choose your move', opt)); }
    function addBerlinBonus() { if (hasBerlin) steps.push(mk('maneuver', 'BERLIN BONUS — MANEUVER (optional)', true)); }

    if (card === 'TAX OR SPEND') {
        if (variant==='TAX') steps.push(mk('tax_city','TAX — choose a city to tax'));
        else                  steps.push(mk('spend','SPEND — choose a purchase'));
    }
    else if (card === 'SPLIT EXPAND OR MANEUVER') {
        if (variant==='SPLIT_EXPAND') {
            steps.push(mk('split_expand_1','SPLIT EXPAND — Destination 1 (choose territory and units)'));
            steps.push(mk('split_expand_2','SPLIT EXPAND — Destination 2 (choose territory and units)'));
            addBerlinBonus();
        }
        else addManeuver();
    }
    else if (card === 'KING ME / TAX OR SPEND') {
        const doKM = variant==='KINGME_TAX'||variant==='KINGME_SPEND';
        if (doKM) steps.push(mk('kingme','KING ME (BONUS) — claim First Player'));
        if (variant==='KINGME_TAX'||variant==='TAX') steps.push(mk('tax_city','TAX — choose a city to tax'));
        else                                          steps.push(mk('spend','SPEND — choose a purchase'));
    }
    else if (card === 'FORTIFY / EXPAND OR MANEUVER') {
        const doFort = variant==='FORTIFY_EXPAND'||variant==='FORTIFY_MANEUVER';
        if (doFort) steps.push(mk('fortify_city','FORTIFY (BONUS) — choose a city'));
        if (variant==='FORTIFY_EXPAND'||variant==='EXPAND') { addExpand(); addBerlinBonus(); }
        else addManeuver();
    }
    else if (card === 'SIEGE ASSAULT / EXPAND OR MANEUVER') {
        const doSiege = variant==='SIEGE_EXPAND'||variant==='SIEGE_MANEUVER';
        if (doSiege) steps.push(mk('siege','SIEGE ASSAULT (BONUS) — choose target'));
        if (variant==='SIEGE_EXPAND'||variant==='EXPAND') { addExpand(); addBerlinBonus(); }
        else addManeuver();
    }
    return steps;
}

// ── Action handlers ────────────────────────────────────────────
// Unit costs for free-form spend builder
const UNIT_COSTS = { F:1, A:2, C:3, S:10, Castle:12 };
function humanCastleCost() {
    // Berlin shield: castles cost 3 fewer coins for the castle-holder
    const hasBerlin = !!(G.shields && G.shields['Berlin'] === S.playerColor);
    return hasBerlin ? 9 : 12;
}
const UNIT_NAMES = { F:'Footman', A:'Archer', C:'Cavalry', S:'Siege Engine', Castle:'Castle' };
const UNIT_PLURAL= { F:'Footmen', A:'Archers', C:'Cavalry', S:'Siege Engines', Castle:'Castles' };
const MIN_SPEND  = 5;

function spendCartTotal() {
    const cart = G.humanSpendCart || {};
    return Object.entries(cart).reduce((s,[k,n]) => {
        const cost = k==='Castle' ? humanCastleCost() : (UNIT_COSTS[k]||0);
        return s + cost*n;
    }, 0);
}
function spendCartSummary(cart) {
    return Object.entries(cart).filter(([,n])=>n>0)
        .map(([k,n]) => `${n} ${n===1?UNIT_NAMES[k]:UNIT_PLURAL[k]}`).join(' + ') || '—';
}
function hfSpendAdjust(k, delta) {
    if (!G.humanSpendCart) G.humanSpendCart = {F:0,A:0,C:0,S:0,Castle:0};
    const coins   = G.coins[S.playerColor]||0;
    const current = G.humanSpendCart[k]||0;
    const cost    = UNIT_COSTS[k]||1;
    const newVal  = current + delta;
    if (newVal < 0) return;
    const newTotal = spendCartTotal() - current*cost + newVal*cost;
    if (newTotal > coins) return;        // can't exceed budget
    G.humanSpendCart[k] = newVal;
    renderHumanTurn();
}
function hfSpendApply(idx) {
    const pc   = S.playerColor;
    const cart = G.humanSpendCart || {};
    const total= spendCartTotal();
    if (total < MIN_SPEND) return;
    const step = G.humanFlow[idx];
    if (!step) return;
    // Deduct coins immediately
    G.coins[pc] = Math.max(0, (G.coins[pc]||0) - total);
    // Constantinople shield: bonus 4 Footmen to place alongside Siege Engine
    const hasCon = (cart.S>0) && CITY_SHIELDS['Constantinople']?.trigger==='spend' && G.shields?.['Constantinople']===pc;
    const toPlace = {
        F: (cart.F||0) + (hasCon ? 4 : 0),
        A: cart.A||0, C: cart.C||0, S: cart.S||0, Castle: cart.Castle||0
    };
    step.toPlace     = {...toPlace};       // original totals
    step.remaining   = {...toPlace};       // countdown as player allocates
    step.placements  = {};                 // { terrName: {F,A,C,S,Castle} }
    step.kievShield  = !!(CITY_SHIELDS['Kiev']?.trigger==='spend' && G.shields?.['Kiev']===pc);
    step.conShield   = hasCon;
    step.spentCoins  = total;
    step.spentSummary= spendCartSummary(cart);
    step.state       = 'place_units';
    G.humanSpendCart = {F:0,A:0,C:0,S:0,Castle:0};
    render();
    renderHumanTurn();
}

function hfPlaceAdjust(idx, terr, k, delta) {
    const step = G.humanFlow[idx];
    if (!step || step.state !== 'place_units') return;
    if (!step.placements[terr]) step.placements[terr] = {F:0,A:0,C:0,S:0,Castle:0};
    const cur = step.placements[terr][k]||0;
    const rem = step.remaining[k]||0;
    if (delta > 0 && rem <= 0) return;
    if (delta < 0 && cur <= 0) return;
    step.placements[terr][k] = cur + delta;
    step.remaining[k]        = rem - delta;
    renderHumanTurn();
}

function hfPlaceConfirm(idx) {
    const pc   = S.playerColor;
    const step = G.humanFlow[idx];
    if (!step || step.state !== 'place_units') return;
    // Apply placements to G.board
    for (const [terr, units] of Object.entries(step.placements)) {
        if (!G.board[terr]) continue;
        for (const k of ['F','A','C','S']) {
            G.board[terr].units[k] = (G.board[terr].units[k]||0) + (units[k]||0);
        }
        if (units.Castle && !G.board[terr].castle) G.board[terr].castle = true;
    }
    // Build placement summary for board reminder
    const placeSummary = Object.entries(step.placements)
        .filter(([,u]) => Object.values(u).some(n=>n>0))
        .map(([terr,u]) => {
            const s = ['F','A','C','S'].filter(k=>u[k]>0).map(k=>`${u[k]} ${UNIT_PLURAL[k]}`).join('+');
            const c = u.Castle ? (s?', Castle':'Castle') : '';
            return `${terr}: ${s}${c}`;
        }).join(' | ');
    step.state       = 'done';
    step.summary     = `Spent ${step.spentCoins} coins on ${step.spentSummary}. Placed across ${Object.keys(step.placements).filter(t=>Object.values(step.placements[t]).some(n=>n>0)).length} territory/ies.`;
    step.boardReminder = placeSummary
        ? `Apply on physical board: ${placeSummary}.`
        : null;
    if (step.conShield) step.boardReminder = (step.boardReminder||'') + `<br>🛡 CONSTANTINOPLE: +4 Footmen included (placed with Siege Engine).`;
    if (step.kievShield) step.boardReminder = (step.boardReminder||'') + `<br>🛡 KIEV: Units may be placed in non-city supply territories.`;
    render();
    renderHumanTurn();
}

// hfSelect: picks a FROM territory (or confirms single-choice steps)
function hfSelect(idx, choice) {
    const pc = S.playerColor;
    const step = G.humanFlow[idx];
    if (!step) return;
    const compound = ['expand','split_expand','maneuver','siege'].includes(step.type);
    if (compound) {
        // choice = territory name (from)
        step.from = choice;
        step.state = 'pick_to';
        renderHumanTurn(); return;
    }
    // Simple steps: apply effect immediately
    if (step.type === 'kingme') {
        G.pendingFirst = pc;
        addLog('You claimed First Player — takes effect next round.');
        step.state='done'; step.summary='First Player marker claimed.';
    }
    else if (step.type === 'tax_city') {
        const city = choice;
        const yld = taxYield(pc, city);
        G.coins[pc] = (G.coins[pc]||0) + yld;
        step.state='done';
        step.summary=`Taxed ${cityLabel(city)}: +${yld} coins (total now ${G.coins[pc]}).`;
        // Shield bonus: auto-apply
        const _csk = shieldKeyForTerr(city);
        const sh = _csk ? CITY_SHIELDS[_csk] : null;
        if (sh && sh.trigger==='tax' && G.shields?.[_csk]===pc) {
            let added = {};
            // Apply to territory (city is territory name like "France", shield key is "Paris")
            if (_csk==='Paris')  { G.board[city].units.C++; G.board[city].units.F++; added={C:1,F:1}; }
            if (_csk==='Madrid') { G.board[city].units.F+=4; added={F:4}; }
            if (_csk==='London') { G.board[city].units.A+=2; added={A:2}; }
            if (Object.keys(added).length)
                step.boardReminder=`🛡 ${sh.reminder}<br><b>Place ${unitStr(added)} in ${cityLabel(city)} on your physical board.</b>`;
        }
        render();
    }
    else if (step.type === 'spend') {
        // spend is now handled by hfSpendApply; this branch is a no-op fallback
    }
    else if (step.type === 'fortify_city') {
        const city = choice;
        const count = G.board[city]?.castle ? 4 : 3;
        G.board[city].units.F = (G.board[city].units.F||0) + count;
        step.state='done';
        step.summary=`Fortified ${city}: +${count} Footmen (now ${totalUnitCount(city)} total).`;
        step.boardReminder=`Place <b>${count} Footmen</b> in <b>${city}</b> on your physical board.`;
    }
    renderHumanTurn();
}

// hfSelectTo: picks the TO territory for compound steps
// ── Unit-count picker: destination chosen, now pick how many to move ────────
function hfPickDest(idx, to) {
    const step = G.humanFlow[idx];
    if (!step) return;
    const from = step.from;
    const isSiege = step.type === 'siege';
    const avail = G.board[from]?.units || {F:0,A:0,C:0,S:0};
    const totalAvail = totalUnitCount(from);
    // For split expand, total across both steps must leave 1 behind
    // If this is step 2, subtract what step 1 already committed
    let alreadyCommitted = 0;
    if (step.type === 'split_expand_2' || step.type === 'split_expand_1') {
        (G.humanFlow||[]).forEach((s,si) => {
            if (si !== (G.humanFlow||[]).indexOf(step) && (s.type==='split_expand_1'||s.type==='split_expand_2') && s.pendingUnits) {
                alreadyCommitted += (s.pendingUnits.F||0)+(s.pendingUnits.A||0)+(s.pendingUnits.C||0)+(s.pendingUnits.S||0);
            }
        });
    }
    const maxMove = totalAvail - 1 - alreadyCommitted; // must leave 1 behind total

    // Default: move everything movable (matching previous behaviour as starting point)
    const defaultUnits = isSiege ? humanSiegeMovingUnits(from) : humanMovingUnits(from);

    step.to = to;
    step.pendingUnits = { F: defaultUnits.F||0, A: defaultUnits.A||0, C: defaultUnits.C||0, S: defaultUnits.S||0 };
    step.state = 'pick_count';
    renderHumanTurn();
}

function hfAdjUnit(idx, k, delta) {
    const step = G.humanFlow[idx];
    if (!step || !step.pendingUnits) return;
    const from = step.from;
    const avail = G.board[from]?.units || {F:0,A:0,C:0,S:0};
    const totalAvail = totalUnitCount(from);
    let _committed2 = 0;
    if (step.type === 'split_expand_2' || step.type === 'split_expand_1') {
        (G.humanFlow||[]).forEach((s,si) => {
            if (s !== step && (s.type==='split_expand_1'||s.type==='split_expand_2') && s.pendingUnits) {
                _committed2 += (s.pendingUnits.F||0)+(s.pendingUnits.A||0)+(s.pendingUnits.C||0)+(s.pendingUnits.S||0);
            }
        });
    }
    const maxMove = totalAvail - 1 - _committed2;
    const pu = step.pendingUnits;
    const totalMoving = (pu.F||0)+(pu.A||0)+(pu.C||0)+(pu.S||0);
    const newVal = (pu[k]||0) + delta;
    if (newVal < 0 || newVal > (avail[k]||0)) return;
    if (delta > 0 && totalMoving >= maxMove) return;
    pu[k] = newVal;
    renderHumanTurn();
}

function hfUndoTo(idx) {
    // Go back to destination picker
    const step = G.humanFlow[idx];
    if (!step) return;
    step.to = null;
    step.pendingUnits = null;
    step.state = 'pick_to';
    renderHumanTurn();
}

function hfConfirmMove(idx) {
    const step = G.humanFlow[idx];
    if (!step || !step.pendingUnits) return;
    const from = step.from;
    const to   = step.to;
    const moving = { ...step.pendingUnits };
    hfSelectTo(idx, to, moving);
}

function hfSelectTo(idx, to, moving) {
    const pc = S.playerColor;
    const step = G.humanFlow[idx];
    if (!step) return;
    const from = step.from;
    // moving may be passed explicitly from hfConfirmMove (player-chosen counts)
    if (!moving) moving = step.type==='siege' ? humanSiegeMovingUnits(from) : humanMovingUnits(from);
    const result = applyHumanMove(from, to, moving);
    step.state='done'; step.to=to;
    step.summary=`${from} → ${to} (${unitStr(moving)}). ${result.outcome}`;
    step.boardReminder=result.boardReminder;
    if (result.type==='capture_crown') addLog(`You move ${unitStr(moving)} from ${from} to ${cityLabel(to)}. ${cityLabel(to)} is captured and you gain ${result.crowns} Crown${result.crowns>1?'s':''} (banner now at ${G.crowns[S.playerColor]}).`);
    else if (result.type==='capture')  addLog(`You move ${unitStr(moving)} from ${from} to ${to}. ${to} is captured.`);
    else if (result.type==='combat')   addLog(`You move ${unitStr(moving)} from ${from} and attack ${to}. Battle queued — resolves in Combat Phase.`);
    render();
    renderHumanTurn();
}

function hfSkip(idx) {
    const step = G.humanFlow[idx];
    if (step) { step.state='skipped'; step.summary='Skipped.'; }
    renderHumanTurn();
}

function hfUndo(idx) {
    const step = G.humanFlow[idx];
    if (step) { step.from=null; step.state='pick_from'; }
    renderHumanTurn();
}

// ── Rendering ──────────────────────────────────────────────────
function renderFlowStepBody(step, idx) {
    const pc = S.playerColor;
    const pHex = COLOR_HEX[pc]||'#888';

    function optGrid(opts, clickFn) {
        if (!opts.length) return '<div style="color:#aaa;font-size:0.82em;padding:4px 0;">None available.</div>';
        return '<div class="hcp-grid">' + opts.map(o => {
            const sel = step.pending_choice===o.value ? ' selected' : '';
            return `<div class="hcp-card${sel}" onclick="${clickFn(o)}" style="cursor:pointer">${o.label}<div class="hcp-count">${o.sub}</div></div>`;
        }).join('') + '</div>';
    }

    switch(step.type) {
        case 'kingme':
            return `<p style="font-size:0.83em;color:var(--ink-light);">You will be First Player at the start of next round.</p>
                <button class="hcp-confirm" onclick="hfSelect(${idx},null)">✓ Claim First Player marker</button>`;

        case 'tax_city': {
            const cities = humanOwnedCities();
            if (!cities.length) return `<p style="color:#aaa;font-size:0.83em;">You own no cities to tax.</p>`;
            const btns = cities.map(c => {
                const yld = taxYield(pc, c.name);
                const _tsk = shieldKeyForTerr(c.name);
                const sh = _tsk ? CITY_SHIELDS[_tsk] : null;
                const shieldNote = (sh && sh.trigger==='tax' && G.shields?.[_tsk]===pc) ? ' 🛡' : '';
                const _dispName = T[c.name]?.city && T[c.name].city !== c.name
                    ? `${c.name} <span style="font-weight:400;font-size:0.88em;">(${T[c.name].city})</span>` : c.name;
                return `<div class="hcp-card" onclick="hfSelect(${idx},'${c.name}')">
                    <b>${_dispName}${c.hasCastle?' 🏰':''}${shieldNote}</b>
                    <div class="hcp-count">Tax ${c.tax} · ${c.units} units · <b>+${yld} coins</b></div>
                </div>`;
            }).join('');
            return `<div style="font-size:0.8em;color:var(--ink-light);margin-bottom:6px;">Choose a city. Yield = Tax value + supply chain bonus.</div>
                <div class="hcp-grid">${btns}</div>`;
        }

        case 'spend': {
            // ── Placement sub-state ──────────────────────────────────────
            if (step.state === 'place_units') {
                const rem    = step.remaining || {};
                const placed = step.placements || {};
                const total  = step.toPlace   || {};
                const pc2    = S.playerColor;
                const kievShield = step.kievShield;

                // All territories the player can place in
                // Normal: owned cities + non-cities. Kiev shield: any supply territory.
                const ownedTerrs = Object.keys(G.board).filter(n => G.board[n].owner === pc2)
                    .sort((a,b) => (T[b]?.tax||0)-(T[a]?.tax||0) || a.localeCompare(b));

                const anyLeft = Object.values(rem).some(n => n > 0);
                const allPlaced = !anyLeft;

                const unitTypes = ['F','A','C','S','Castle'].filter(k => (total[k]||0) > 0);

                // Remaining pills
                const remPills = unitTypes.map(k => {
                    const r = rem[k]||0;
                    const col = r > 0 ? '#c0392b' : '#1a7a3c';
                    return `<span style="display:inline-flex;align-items:center;gap:4px;background:${r>0?'rgba(192,57,43,0.08)':'rgba(30,126,68,0.08)'};border:1px solid ${col};border-radius:12px;padding:2px 10px;font-size:0.8em;color:${col};font-weight:700;">${r} ${UNIT_PLURAL[k]} left</span>`;
                }).join(' ');

                // Territory rows
                const terrRows = ownedTerrs.map(terr => {
                    const isCity = (T[terr]?.tax||0) > 0;
                    const hasCastle = !!G.board[terr]?.castle;
                    const currUnits = totalUnitCount(terr);
                    const terPlaced = placed[terr] || {};
                    const validTypes = unitTypes.filter(k => k !== 'Castle' || isCity);
                    if (!validTypes.length) return '';

                    const controls = validTypes.map(k => {
                        const qty = terPlaced[k]||0;
                        const canAdd = (rem[k]||0) > 0 && (k !== 'Castle' || (!hasCastle && qty < 1));
                        const canSub = qty > 0;
                        const idxStr = idx;
                        const terrEsc = terr.replace(/'/g,"\'");
                        return `<div style="display:flex;align-items:center;gap:4px;margin-right:8px;">
                            <span style="font-size:0.72em;color:var(--ink-light);min-width:18px;text-align:right;">${UNIT_NAMES[k].charAt(0)}</span>
                            <button onclick="hfPlaceAdjust(${idxStr},'${terrEsc}','${k}',-1)" ${canSub?'':'disabled'} style="width:24px;height:24px;border-radius:50%;border:1px solid #ccc;background:#fff;font-size:0.9em;cursor:pointer;color:${canSub?'#8b1a1a':'#ccc'}">−</button>
                            <span style="width:18px;text-align:center;font-size:0.88em;font-weight:700;">${qty}</span>
                            <button onclick="hfPlaceAdjust(${idxStr},'${terrEsc}','${k}',1)" ${canAdd?'':'disabled'} style="width:24px;height:24px;border-radius:50%;border:1px solid #ccc;background:#fff;font-size:0.9em;cursor:pointer;color:${canAdd?'#1a7a3c':'#ccc'}">+</button>
                        </div>`;
                    }).join('');

                    const placed_here = validTypes.filter(k=>(terPlaced[k]||0)>0);
                    const bgColor = placed_here.length ? 'rgba(30,126,68,0.04)' : '#fff';

                    return `<div style="display:flex;align-items:center;gap:6px;padding:6px 8px;border-bottom:1px solid #f0ede8;background:${bgColor};border-radius:4px;margin-bottom:2px;">
                        <div style="flex:1;min-width:0;">
                            <span style="font-size:0.85em;font-weight:700;">${terrLabel(terr)}</span>
                            <span style="font-size:0.72em;color:var(--ink-light);margin-left:4px;">${isCity?'city · Tax '+T[terr].tax:'non-city'} · ${currUnits} units${hasCastle?' 🏰':''}</span>
                        </div>
                        <div style="display:flex;align-items:center;flex-wrap:wrap;">${controls}</div>
                    </div>`;
                }).filter(Boolean).join('');

                const confirmBtn = `<button class="hcp-confirm" onclick="hfPlaceConfirm(${idx})" ${allPlaced?'':'disabled'}>
                    ✓ Confirm placement${allPlaced?'':' — place all units first'}
                </button>`;

                return `<div style="margin-bottom:8px;">
                    <div style="font-size:0.82em;font-weight:700;color:var(--accent);margin-bottom:6px;">Place your units — where do they go?</div>
                    <div style="display:flex;flex-wrap:wrap;gap:4px;margin-bottom:10px;">${remPills}</div>
                    ${kievShield ? '<div class="shield-reminder" style="margin-bottom:8px;">🛡 KIEV SHIELD: You may place in non-city territories connected by supply line.</div>' : ''}
                    <div style="background:#faf8f5;border-radius:8px;padding:4px 8px;max-height:320px;overflow-y:auto;">${terrRows}</div>
                    ${confirmBtn}
                </div>`;
            }
            // ── Builder sub-state (default) ──────────────────────────────
            const coins = G.coins[pc]||0;
            if (!G.humanSpendCart) G.humanSpendCart = {F:0,A:0,C:0,S:0,Castle:0};
            const cart  = G.humanSpendCart;
            const total = spendCartTotal();
            const left  = coins - total;
            const canApply = total >= MIN_SPEND;

            const rows = [
                {k:'F',      plural:'Footmen',       cost:1 , multi:true },
                {k:'A',      plural:'Archers',       cost:2 , multi:true },
                {k:'C',      plural:'Cavalry',       cost:3 , multi:true },
                {k:'S',      plural:'Siege Engines', cost:10, multi:true },
                {k:'Castle', plural:'Castles',       cost:humanCastleCost(), multi:false},
            ];
            const rowsHTML = rows.map(r => {
                const qty     = cart[r.k]||0;
                const canAdd  = left >= r.cost && (r.multi || qty < 1);
                const canSub  = qty > 0;
                const addDis  = canAdd  ? '' : ' disabled';
                const subDis  = canSub  ? '' : ' disabled';
                const addCol  = canAdd  ? '#1a7a3c' : '#ccc';
                const subCol  = canSub  ? '#8b1a1a' : '#ccc';
                return `<div style="display:flex;align-items:center;gap:8px;padding:7px 0;border-bottom:1px solid #f0ede8;">
                    <div style="flex:1;font-size:0.88em;"><b>${r.plural}</b> <span style="color:var(--ink-light);font-size:0.8em;">${r.cost} coin${r.cost>1?'s':''} each</span></div>
                    <button onclick="hfSpendAdjust('${r.k}',-1)"${subDis} style="width:30px;height:30px;border-radius:50%;border:1px solid #ccc;background:#fff;font-size:1.1em;cursor:pointer;font-weight:700;color:${subCol}">−</button>
                    <div style="width:24px;text-align:center;font-size:1em;font-weight:700;">${qty||0}</div>
                    <button onclick="hfSpendAdjust('${r.k}',1)"${addDis} style="width:30px;height:30px;border-radius:50%;border:1px solid #ccc;background:#fff;font-size:1.1em;cursor:pointer;font-weight:700;color:${addCol}">+</button>
                </div>`;
            }).join('');

            const totalColor = total > coins ? '#c0392b' : total >= MIN_SPEND ? '#1a7a3c' : 'inherit';
            const totalBar = `<div style="display:flex;align-items:center;justify-content:space-between;padding:10px 0 4px;border-top:2px solid #e8e0d5;margin-top:4px;">
                <div style="font-size:0.85em;color:var(--ink-light);flex:1;">${total>0?spendCartSummary(cart):'Nothing selected'}</div>
                <div style="text-align:right;">
                    <span style="font-size:1em;font-weight:700;color:${totalColor}">${total}</span>
                    <span style="font-size:0.82em;color:var(--ink-light);"> / ${coins} coins (${left} left)</span>
                </div>
            </div>`;

            const minNote = (total > 0 && total < MIN_SPEND)
                ? `<div style="font-size:0.78em;color:#c0392b;margin:2px 0 6px;">Minimum spend is ${MIN_SPEND} coins — need ${MIN_SPEND-total} more.</div>` : '';

            const applyBtn = `<button class="hcp-confirm" onclick="hfSpendApply(${idx})" ${canApply?'':'disabled'}>✓ Spend ${total} coin${total!==1?'s':''}${canApply?'':' (min 5 required)'}</button>`;
            const skipBtn  = `<button class="btn-retreat" style="margin-top:6px;font-size:0.8em;" onclick="hfSkip(${idx})">Skip — don't spend this action</button>`;

            return `<div style="font-size:0.8em;color:var(--ink-light);margin-bottom:6px;">You have <b>${coins} coins</b>. Build your purchase (1 coin = 1 Footman):</div>
                <div style="background:#faf8f5;border-radius:8px;padding:4px 12px 8px;">${rowsHTML}${totalBar}</div>
                ${minNote}${applyBtn}${skipBtn}`;
        }

        case 'fortify_city': {
            const cities = humanOwnedCities();
            if (!cities.length) return `<p style="color:#aaa;font-size:0.83em;">You have no cities to fortify right now.</p>
                <button class="btn-retreat" onclick="hfSkip(${idx})">Skip fortify (no cities available)</button>`;
            const btns = cities.map(c => {
                const count = c.hasCastle ? 4 : 3;
                return `<div class="hcp-card" onclick="hfSelect(${idx},'${c.name}')">
                    <b>${terrLabel(c.name)}${c.hasCastle?' 🏰':''}</b>
                    <div class="hcp-count">+${count} Footmen · currently ${c.units} units → will have ${c.units+count}</div>
                </div>`;
            }).join('');
            return `<div style="font-size:0.8em;color:var(--ink-light);margin-bottom:6px;">Choose a city (+3 Footmen, or +4 if it has a castle 🏰):</div>
                <div class="hcp-grid">${btns}</div>`;
        }

        case 'expand':
        case 'split_expand_1':
        case 'split_expand_2':
        case 'split_expand':
        case 'maneuver':
        case 'siege': {
            // pick_count: destination chosen, player adjusting unit quantities
            if (step.state === 'pick_count') {
                const from = step.from;
                const to   = step.to;
                const pu   = step.pendingUnits || {};
                const avail = G.board[from]?.units || {F:0,A:0,C:0,S:0};
                const totalAvail = totalUnitCount(from);
                const maxMove = totalAvail - 1; // must leave at least 1
                const totalMoving = (pu.F||0)+(pu.A||0)+(pu.C||0)+(pu.S||0);
                const isSiege = step.type === 'siege';

                const owner = G.board[to]?.owner||'neutral';
                const isMine = owner === pc;
                const isEnemy = owner !== 'neutral' && !isMine;
                const borderColor = isMine ? '#1a7a3c' : isEnemy ? COLOR_HEX[owner]||'#c0392b' : '#888';
                const ownerLabel = isMine ? 'yours' : owner==='neutral' ? 'neutral' : owner.charAt(0).toUpperCase()+owner.slice(1);

                const unitRows = ['C','A','F','S'].map(k => {
                    const av = avail[k]||0;
                    if (av === 0) return null;
                    const moving = pu[k]||0;
                    // Siege engine: must always include it for siege moves
                    const locked = isSiege && k==='S';
                    const canAdd = moving < av && totalMoving < maxMove && !locked;
                    const canSub = moving > 0 && !(isSiege && k==='S' && moving <= 1);
                    const label = k==='C'?'Cavalry':k==='A'?'Archers':k==='F'?'Footmen':'Siege Engine';
                    return `<div class="unit-type-row">
                        <div><div class="ut-label">${label}</div><div class="ut-avail">${av} available</div></div>
                        <div class="ut-stepper">
                            <button class="ut-btn" onclick="hfAdjUnit(${idx},'${k}',-1)" ${canSub?'':'disabled'}>−</button>
                            <span class="ut-val">${moving}${locked?' 🔒':''}</span>
                            <button class="ut-btn" onclick="hfAdjUnit(${idx},'${k}',1)" ${canAdd?'':'disabled'}>+</button>
                        </div>
                    </div>`;
                }).filter(Boolean).join('');

                const canConfirm = totalMoving >= 1;
                return `<div style="font-size:0.8em;color:var(--ink-light);margin-bottom:6px;">
                    How many units to move from <b>${from}</b> to
                    <span style="border-left:3px solid ${borderColor};padding-left:5px;"><b>${terrLabel(to)}</b>
                    <span style="color:${borderColor};font-size:0.82em;"> — ${ownerLabel}</span></span>?
                    <span style="color:#888;"> (must leave at least 1 behind)</span>
                </div>
                <div class="unit-type-grid" style="margin-bottom:10px;">${unitRows}</div>
                <div style="font-size:0.8em;color:var(--ink-light);margin-bottom:8px;">Moving: <b>${totalMoving}</b> of ${maxMove} max</div>
                <button class="be-confirm-btn" onclick="hfConfirmMove(${idx})" ${canConfirm?'':'disabled'}>
                    ✓ Move ${totalMoving} unit${totalMoving!==1?'s':''} → ${to}
                </button>
                <button class="btn-retreat" style="margin-top:6px;" onclick="hfUndoTo(${idx})">← Change destination</button>`;
            }

            if (step.state === 'pick_from') {
                const opts = step.type==='siege' ? humanSiegeFromOpts() : humanMoveFromOpts();
                if (!opts.length) {
                    const msg = step.type==='siege' ? 'No territories with Siege Engines available.'
                              : 'No territories to move from (need 2+ units, not in contested territory).';
                    return `<p style="font-size:0.83em;color:#aaa;">${msg}</p>
                        <button class="btn-retreat" onclick="hfSkip(${idx})">Skip (no valid move)</button>`;
                }
                const lbl = step.type==='siege' ? 'Which territory has your Siege Engine?'
                          : step.type==='maneuver' ? 'Maneuver from which territory? (leave 1 unit behind; not from contested):'
                          : 'Move from which territory? (leave 1 unit behind; not from contested):';
                const btns = opts.map(o => {
                    const mov = totalUnitCount(o.name)-1;
                    const u = unitStr(G.board[o.name].units);
                    return `<div class="hcp-card" onclick="hfSelect(${idx},'${o.name}')">
                        <b>${terrLabel(o.name)}</b>
                        <div class="hcp-count">${u} · ${mov} can move</div>
                    </div>`;
                }).join('');
                return `<div style="font-size:0.8em;color:var(--ink-light);margin-bottom:6px;">${lbl}</div>
                    <div class="hcp-grid">${btns}</div>`;
            } else {
                // pick_to
                const from = step.from;
                const moving = step.type==='siege' ? humanSiegeMovingUnits(from) : humanMovingUnits(from);
                let toOpts;
                if (step.type==='siege')         toOpts = humanSiegeToOpts(from);
                else if (step.type==='split_expand_1'||step.type==='split_expand_2'||step.type==='split_expand') {
                    // Exclude destinations already picked by sibling split_expand steps
                    const usedDests = (G.humanFlow||[])
                        .filter((s,si) => si!==idx && (s.type==='split_expand_1'||s.type==='split_expand_2'||s.type==='split_expand') && s.to)
                        .map(s=>s.to);
                    toOpts = humanSplitExpandToOpts(from, usedDests);
                }
                else if (step.type==='maneuver') toOpts = humanManeuverToOpts(from);
                else                             toOpts = humanExpandToOpts(from); // all adjacent
                if (!toOpts.length) {
                    const msg = step.type==='siege' ? `No adjacent castle cities to attack from ${from}.`
                              : `No valid destinations from ${from}.`;
                    return `<p style="font-size:0.83em;color:#aaa;">${msg}</p>
                        <button class="btn-retreat" onclick="hfUndo(${idx})">← Choose different territory</button>`;
                }
                const maxMovable = totalUnitCount(from) - 1;
                const lbl = step.type==='maneuver'
                    ? `Maneuver from <b>${from}</b> to: <span style="font-size:0.78em;color:var(--ink-light)">(up to ${maxMovable} units · green=yours, grey=friendly, red=enemy)</span>`
                    : `Move from <b>${from}</b> to: <span style="font-size:0.78em;color:var(--ink-light)">(up to ${maxMovable} units)</span>`;
                const btns = toOpts.map(o => {
                    const name = o.name;
                    const owner = G.board[name]?.owner||'neutral';
                    const isMine = owner===pc;
                    const isEnemy = owner!=='neutral'&&!isMine;
                    const borderColor = isMine ? '#1a7a3c' : isEnemy ? COLOR_HEX[owner]||'#c0392b' : '#888';
                    const ownerLabel = isMine ? 'yours' : owner==='neutral' ? 'neutral' : owner.charAt(0).toUpperCase()+owner.slice(1);
                    const units = totalUnitCount(name);
                    const castleIcon = G.board[name]?.castle ? ' 🏰' : '';
                    const viaNote = o.via ? `<span style="font-size:0.78em;"> via ${o.via}</span>` : '';
                    const hopsNote = o.hops ? ` (${o.hops} step${o.hops>1?'s':''})` : '';
                    const siegeWarn = isEnemy&&G.board[name]?.castle&&!((G.board[from]?.units?.S||0)>0) ? ' ⚠ needs Siege Engine' : '';
                    return `<div class="hcp-card" onclick="hfPickDest(${idx},'${name}')" style="border-left:3px solid ${borderColor}">
                        <b>${terrLabel(name)}</b>${castleIcon ? ' 🏰' : ''}
                        <div class="hcp-count" style="color:${borderColor}">${ownerLabel}${units>0?' · '+units+' units':''}${hopsNote}${viaNote}${siegeWarn}</div>
                    </div>`;
                }).join('');
                return `<div style="font-size:0.8em;margin-bottom:6px;">${lbl}</div>
                    <div class="hcp-grid">${btns}</div>
                    <button class="btn-retreat" style="margin-top:6px;" onclick="hfUndo(${idx})">← Change starting territory</button>`;
            }
        }
    }
    return '';
}

function renderFlowStep(step, idx) {
    const flow = G.humanFlow||[];
    const activeIdx = flow.findIndex(s => s.state!=='done' && s.state!=='skipped');
    const isActive = idx===activeIdx;
    const isDone   = step.state==='done';
    const isSkipped= step.state==='skipped';

    if (isDone) {
        const reminder = step.boardReminder
            ? `<div class="board-instruction" style="margin-top:6px;font-size:0.78em;">${step.boardReminder}</div>` : '';
        return `<div class="ht-step done">
            <div class="ht-cb">✓</div>
            <div class="ht-text">
                <span style="font-family:Cinzel,serif;font-size:0.78em;color:var(--ink-light);">${step.label}</span><br>
                <span style="color:#1a7a3c;font-size:0.85em;">${step.summary||''}</span>
                ${reminder}
            </div>
        </div>`;
    }
    if (isSkipped) {
        return `<div class="ht-step done" style="opacity:0.45">
            <div class="ht-cb" style="background:#aaa;border-color:#aaa;color:#fff;">—</div>
            <div class="ht-text"><span style="font-size:0.8em;color:#aaa;">${step.label} — Skipped</span></div>
        </div>`;
    }
    if (isActive) {
        const body = renderFlowStepBody(step, idx);
        const skipBtn = step.optional
            ? `<button class="btn-retreat" style="margin-top:8px;font-size:0.78em;" onclick="hfSkip(${idx})">Skip this bonus</button>` : '';
        const editorBtn = `<button style="margin-top:8px;background:none;border:1px solid #ccc;border-radius:5px;padding:4px 10px;font-size:0.72em;color:var(--ink-light);cursor:pointer;" onclick="openBoardEditor()">🗺 Board Editor (if needed)</button>`;
        return `<div class="ht-step" style="border-left:3px solid var(--accent);background:#fff;">
            <div class="ht-cb"></div>
            <div class="ht-text">
                <div style="font-family:Cinzel,serif;font-size:0.82em;font-weight:700;color:var(--accent);margin-bottom:8px;">${step.label}</div>
                ${body}
                ${skipBtn}
                ${editorBtn}
            </div>
        </div>`;
    }
    // Pending (future step)
    return `<div class="ht-step" style="opacity:0.3;pointer-events:none;">
        <div class="ht-cb"></div>
        <div class="ht-text"><span style="font-size:0.8em;">${step.label}</span></div>
    </div>`;
}



// ── Card picker helpers ─────────────────────────────────────────
function pickHumanCard(card) {
    G._humanCardPending = card;
    renderHumanTurn();
}

function confirmHumanCard() {
    const card = G._humanCardPending;
    if (!card) return;
    const idx = G.humanDeck.indexOf(card);
    if (idx !== -1) G.humanDeck.splice(idx, 1);
    G.humanCard = card;
    G._humanCardPending = null;
    G.humanVariant = null;
    // Cards with no variant go straight to checklist
    if (humanCardVariants(card).length === 0) {
        G.humanSteps = generateHumanSteps(card, null);
        addLog('Your card: "' + card + '"');
    }
    G.humanTurnChecks = new Set();
    G.humanBoardUpdated = false;
    renderHumanTurn();
}

function pickHumanVariant(v) {
    G._humanVariantPending = v;
    renderHumanTurn();
}

function confirmHumanVariant() {
    const v = G._humanVariantPending;
    if (!v) return;
    G.humanVariant = v;
    G._humanVariantPending = null;
    G.humanFlow = buildHumanFlow(G.humanCard, v);
    addLog('Your card: "' + G.humanCard + '" — ' + v.replace(/_/g,' '));
    G.humanTurnChecks = new Set();
    G.humanBoardUpdated = false;
    renderHumanTurn();
}

// ── Main render ─────────────────────────────────────────────────
function renderHumanTurn() {
    const el = document.getElementById('human-view');
    if (!el) return;

    const pc    = S.playerColor || 'blue';
    const pHex  = COLOR_HEX[pc] || '#5bb8f5';
    const lightC= ['blue','green','orange'].includes(pc);
    document.documentElement.style.setProperty('--player-color', pHex);

    const btn   = document.getElementById('complete-btn');

    const hdr = (sub) =>
        '<div class="human-banner" style="margin-bottom:0;border-bottom:none;border-radius:8px 8px 0 0;border-color:' + pHex + ';">' +
        '<h2 style="color:' + pHex + ';">⚔ YOUR TURN — ACTION ' + G.step + ' of 2</h2>' +
        (sub ? '<p style="margin:0;font-size:0.82em;color:var(--ink-light);">' + sub + '</p>' : '') +
        '</div>';
    const panelTop = (lbl) =>
        '<div class="steps-header" style="background:' + pHex + ';color:' + (lightC?'#000':'#fff') + '">' + lbl + '</div>';

    if (btn) btn.disabled = true;

    // ════════════════════════════════════════════════════════════
    // Phase 1 — Pick a card
    // ════════════════════════════════════════════════════════════
    if (!G.humanCard) {
        const counts = {};
        (G.humanDeck||[]).forEach(c => { counts[c]=(counts[c]||0)+1; });
        const types  = Object.keys(counts);
        if (!types.length) {
            el.innerHTML = hdr() +
                '<div class="steps-panel" style="border-radius:0 0 8px 8px;"><div class="hcp-wrap">' +
                '<div class="hcp-label">Deck empty — reshuffling next turn.</div></div></div>';
            return;
        }
        const pending = G._humanCardPending||null;
        const grid = types.map(c => {
            const n = counts[c], sel = c===pending?' selected':'';
            const esc = c.replace(/'/g,"\\'");
            return '<div class="hcp-card'+sel+'" onclick="pickHumanCard(\''+esc+'\')">' +
                c + '<div class="hcp-count">'+(n>1?n+' remaining':'last copy')+'</div></div>';
        }).join('');
        const discard = (G.humanDiscard||[]).length + '/8 played this cycle';
        el.innerHTML = hdr('Step 1 of 3 — choose your card') +
            '<div class="steps-panel" style="border-radius:0 0 8px 8px;">' +
            panelTop('PLAY YOUR CARD') +
            '<div class="hcp-wrap">' +
              '<div class="hcp-label">Which card are you playing?</div>' +
              '<div class="hcp-grid">' + grid + '</div>' +
              '<button class="hcp-confirm" onclick="confirmHumanCard()" '+(pending?'':'disabled')+'>' +
                (pending?'▶ Play: '+pending:'Select a card above') +
              '</button>' +
              '<div class="hcp-discard">'+discard+'</div>' +
            '</div></div>';
        return;
    }

    // ════════════════════════════════════════════════════════════
    // Phase 2 — Choose variant (for all 8 cards)
    // ════════════════════════════════════════════════════════════
    if (!G.humanVariant && humanCardVariants(G.humanCard).length > 0) {
        const variants = humanCardVariants(G.humanCard);
        const pending  = G._humanVariantPending||null;
        const grid = variants.map(v => {
            const sel = v.value===pending?' selected':'';
            const esc = v.value.replace(/'/g,"\\'");
            return '<div class="hcp-card'+sel+'" onclick="pickHumanVariant(\''+esc+'\')">' + v.label + '</div>';
        }).join('');
        el.innerHTML = hdr('Step 2 of 3 — choose your action') +
            '<div class="steps-panel" style="border-radius:0 0 8px 8px;">' +
            '<div style="display:flex;align-items:center;gap:8px;padding:8px 14px;background:rgba(139,26,26,0.06);border-bottom:1px solid var(--border-light);">' +
              '<span style="font-family:Cinzel,serif;font-size:0.78em;font-weight:700;color:var(--accent);">🃏 '+G.humanCard+'</span>' +
            '</div>' +
            panelTop('WHICH ACTION?') +
            '<div class="hcp-wrap">' +
              '<div class="hcp-label">What are you doing this action?</div>' +
              '<div class="hcp-grid" style="grid-template-columns:1fr;">' + grid + '</div>' +
              '<button class="hcp-confirm" onclick="confirmHumanVariant()" '+(pending?'':'disabled')+'>' +
                (pending?'▶ Confirm: '+pending.replace(/_/g,' '):'Select an action above') +
              '</button>' +
            '</div></div>';
        return;
    }

    // ════════════════════════════════════════════════════════════
    // Phase 3 — Interactive flow
    // ════════════════════════════════════════════════════════════
    const flow = G.humanFlow||[];
    const allDone = flow.length > 0 && flow.every(s => s.state==='done'||s.state==='skipped');

    const variantLabel = G.humanVariant ? ' — '+G.humanVariant.replace(/_/g,' ') : '';
    const cardBadge =
        '<div style="display:flex;align-items:center;gap:8px;padding:8px 14px;background:rgba(139,26,26,0.06);border-bottom:1px solid var(--border-light);">' +
          '<span style="font-family:Cinzel,serif;font-size:0.78em;font-weight:700;color:var(--accent);">🃏 '+G.humanCard+variantLabel+'</span>' +
          '<span style="flex:1"></span>' +
          '<span style="font-size:0.7em;color:var(--ink-light);">'+G.humanDeck.length+' left in deck</span>' +
        '</div>';

    const done  = flow.filter(s=>s.state==='done'||s.state==='skipped').length;
    const total = flow.length;
    const pct   = total ? Math.round(done/total*100) : 100;

    const stepsHTML = flow.map((s,i) => renderFlowStep(s,i)).join('');

    el.innerHTML = hdr('Step 3 of 3 — complete each action') +
        '<div class="steps-panel" style="border-radius:0 0 8px 8px;">' +
        cardBadge +
        panelTop('YOUR ACTION') +
        '<div class="ht-progress"><div class="ht-progress-fill" style="width:'+pct+'%;background:'+pHex+'"></div></div>' +
        '<div class="human-turn-steps">' + stepsHTML + '</div>' +
        '</div>';

    if (btn) btn.disabled = !allDone;
}



// Show "Stuck? Force advance" hint after Complete Turn is disabled for 8 seconds
let _stuckTimer = null;
function resetStuckTimer() {
    clearTimeout(_stuckTimer);
    const hint = () => document.getElementById('stuck-hint');
    if (hint()) hint().style.display = 'none';
    const btn = document.getElementById('complete-btn');
    if (btn && btn.disabled) {
        _stuckTimer = setTimeout(() => {
            const b = document.getElementById('complete-btn');
            const h = document.getElementById('stuck-hint');
            if (b && b.disabled && h) h.style.display = 'block';
        }, 8000);
    }
}
function forceAdvance() {
    if (!confirm('Force advance to next turn?\n\nThis skips any remaining steps. Use only if you are stuck.')) return;
    const h = document.getElementById('stuck-hint');
    if (h) h.style.display = 'none';
    advanceTurn();
}


// ================================================================
// TERRITORY EDIT MODAL
// ================================================================
// TE = Territory Edit state
// TE.name        — territory being edited
// TE.attColor    — a second (attacking) color the user is setting up, or null
// TE.attUnits    — that attacker's units {F,A,C,S} — lives only in TE, NOT on G.board
let TE = { name:null, attColor:null, attUnits:{F:0,A:0,C:0,S:0} };

function openTerrEdit(name) {
    if (!G.board[name]) return;
    TE = { name, attColor:null, attUnits:{F:0,A:0,C:0,S:0} };
    document.getElementById('terr-edit-overlay').classList.add('open');
    renderTerrEdit();
}

function closeTerrEdit() {
    // If a second (attacking) army was set up, queue it as a pending battle
    if (TE.attColor && unitTotal(TE.attUnits) > 0) {
        if (!G.roundCombats) G.roundCombats = [];
        // Remove any previous editor-queued battle for the same territory + attacker
        G.roundCombats = G.roundCombats.filter(
            b => !(b._fromEditor && b.to === TE.name && b.color === TE.attColor)
        );
        G.roundCombats.push({
            color:       TE.attColor,
            from:        '__editor__',   // sentinel: no origin territory
            to:          TE.name,
            movingUnits: { ...TE.attUnits },
            movable:     unitTotal(TE.attUnits),
            isEnemy:     true,
            _fromEditor: true
        });
        addLog(`⚔ Battle queued: ${cAttacks(TE.attColor)} ${TE.name} (${G.board[TE.name]?.owner}) — resolve in Combat Phase.`);
    }
    document.getElementById('terr-edit-overlay').classList.remove('open');
    TE = { name:null, attColor:null, attUnits:{F:0,A:0,C:0,S:0} };
    renderBEFull(G.board);
}

function renderTerrEdit() {
    const name = TE.name;
    const b = G.board[name];
    if (!b) return;

    const tax = T[name]?.tax > 0 ? `Tax ${T[name].tax} city` : 'Non-urban territory';
    document.getElementById('terr-edit-title').textContent = name;

    const defColor  = b.owner;
    const hasAtt    = !!TE.attColor;

    // ── Color selector ──────────────────────────────────────────────
    // Clicking the defender's color = remove attacker (back to single-army view)
    // Clicking a different color    = set as attacker
    // Clicking Neutral              = clear the territory
    const allColors = ['orange','green','purple','blue','neutral'];
    const ownerBtns = allColors.map(c => {
        const bg  = COLOR_HEX[c] || '#aaa';
        const txt = ['orange','green','blue'].includes(c) ? '#000' : '#fff';
        // Highlight: defender color highlighted if no attacker, attacker color if attacker set
        const isSel = hasAtt ? (c === TE.attColor) : (c === defColor);
        const sel = isSel ? 'sel' : '';
        const label = c === 'neutral' ? 'Neutral'
            : c.charAt(0).toUpperCase()+c.slice(1) + (c===S.playerColor?' (You)':'');
        return `<button class="te-owner-btn ${sel}" style="background:${bg};color:${txt}"
            onclick="teSetOwner('${c}')">${label}</button>`;
    }).join('');

    // ── Unit rows helper ────────────────────────────────────────────
    const unitDefs = [
        { k:'F', label:'Footman',      sub:'1 die' },
        { k:'A', label:'Archer',       sub:'1 die' },
        { k:'C', label:'Cavalry',      sub:'2 dice' },
        { k:'S', label:'Siege Engine', sub:'Pre-battle' },
    ];
    function makeUnitRows(units, idPrefix, onAdj) {
        return unitDefs.map(({k, label, sub}) => {
            const v = units[k] || 0;
            return `<div class="te-unit-row">
                <div><div class="te-unit-label">${label}</div><div class="te-unit-sub">${sub}</div></div>
                <div class="te-stepper">
                    <button class="te-btn" onclick="${onAdj}('${k}',-1)">−</button>
                    <span class="te-val" id="${idPrefix}${k}">${v}</span>
                    <button class="te-btn" onclick="${onAdj}('${k}',1)">+</button>
                </div>
            </div>`;
        }).join('');
    }

    // ── Defender panel ──────────────────────────────────────────────
    const defHex   = COLOR_HEX[defColor] || '#aaa';
    const defLight = ['orange','green','blue'].includes(defColor);
    const defTxt   = defLight ? '#000' : '#fff';
    const defTotal = unitTotal(b.units);
    const defPanel = `
        <div class="te-section" style="border:2px solid ${defHex};border-radius:7px;margin-bottom:10px;">
            <div style="background:${defHex};color:${defTxt};padding:5px 10px;border-radius:5px 5px 0 0;
                font-family:Cinzel,serif;font-size:0.82em;font-weight:700;margin-bottom:6px;">
                ${hasAtt ? 'DEFENDER — ' : ''}${defColor.toUpperCase()}${defColor===S.playerColor?' (YOU)':''}&nbsp;
                <span style="font-weight:400">(${defTotal} units)</span>
            </div>
            <div style="padding:0 4px;">${makeUnitRows(b.units,'te-def-','teAdjDef')}</div>
        </div>`;

    // ── Attacker panel (only when a second color is selected) ───────
    let attPanel = '';
    if (hasAtt) {
        const attHex   = COLOR_HEX[TE.attColor] || '#aaa';
        const attLight = ['orange','green','blue'].includes(TE.attColor);
        const attTxt   = attLight ? '#000' : '#fff';
        const attTotal = unitTotal(TE.attUnits);
        attPanel = `
        <div class="te-section" style="border:2px solid ${attHex};border-radius:7px;margin-bottom:10px;">
            <div style="background:${attHex};color:${attTxt};padding:5px 10px;border-radius:5px 5px 0 0;
                font-family:Cinzel,serif;font-size:0.82em;font-weight:700;margin-bottom:6px;">
                ATTACKER — ${TE.attColor.toUpperCase()}${TE.attColor===S.playerColor?' (YOU)':''}
                &nbsp;<span style="font-weight:400" id="te-att-total">(${attTotal} units)</span>
            </div>
            <div style="padding:0 4px;">${makeUnitRows(TE.attUnits,'te-att-','teAdjAtt')}</div>
        </div>
        <div style="font-size:0.78em;color:var(--ink-light);margin-bottom:8px;padding:0 2px;">
            ⚔ Battle will be queued for the Combat Phase when you save.
        </div>`;
    }

    // ── Castle ──────────────────────────────────────────────────────
    const castleCls = b.castle ? 'te-castle-toggle on' : 'te-castle-toggle';
    const castleLbl = b.castle ? '🏰 Remove Castle' : '+ Add Castle';
    const castleNote = T[name]?.tax > 0 ? '' : '<div style="font-size:0.75em;color:var(--ink-light);margin-top:4px;">Note: only cities normally have castles.</div>';

    document.getElementById('terr-edit-body').innerHTML = `
        <div class="te-section">
            <div class="te-label">Territory: <b>${name}</b> &nbsp;<span style="font-size:0.8em;color:var(--ink-light);">${tax}</span></div>
        </div>
        <div class="te-section">
            <div class="te-label">${hasAtt ? 'Click a colour to set attacker / defender' : 'Owner — click another colour to add an attacker'}</div>
            <div class="te-owner-row">${ownerBtns}</div>
        </div>
        ${defPanel}
        ${attPanel}
        <div class="te-section">
            <div class="te-castle-row">
                <div class="te-castle-label">${b.castle ? '🏰 Castle present' : 'No castle'}</div>
                <button class="${castleCls}" id="te-castle-btn" onclick="teToggleCastle()">${castleLbl}</button>
            </div>
            ${castleNote}
        </div>
        <button class="te-save-btn" onclick="closeTerrEdit()">
            ${hasAtt && unitTotal(TE.attUnits)>0 ? '⚔ Save & Queue Battle' : '✓ Done — Save Changes'}
        </button>
    `;
}

// ── teSetOwner: manage which color is the "attacker" slot ──────────
function teSetOwner(color) {
    const b = G.board[TE.name];
    if (!b) return;

    if (color === 'neutral') {
        // Clear to neutral: wipe units, remove any pending attacker
        b.owner = 'neutral';
        b.units = {F:0,A:0,C:0,S:0};
        TE.attColor = null;
        TE.attUnits = {F:0,A:0,C:0,S:0};
        if (CITY_SHIELDS[TE.name]) { if (G.shields) delete G.shields[TE.name]; }
    } else if (color === b.owner) {
        // Clicking the current defender color = remove attacker
        TE.attColor = null;
        TE.attUnits = {F:0,A:0,C:0,S:0};
    } else {
        // Different color = set as attacker (preserve units if same attacker re-selected)
        if (TE.attColor !== color) {
            TE.attColor = color;
            TE.attUnits = {F:0,A:0,C:0,S:0};  // always reset to 0 when switching attacker
        }
    }
    renderTerrEdit();
}

// ── Adjust DEFENDER units ──────────────────────────────────────────
function teAdjDef(k, v) {
    if (!G.board[TE.name]) return;
    G.board[TE.name].units[k] = Math.max(0, (G.board[TE.name].units[k]||0) + v);
    const el = document.getElementById('te-def-'+k);
    if (el) el.textContent = G.board[TE.name].units[k];
}

// ── Adjust ATTACKER units (stored only in TE, not on G.board) ─────
function teAdjAtt(k, v) {
    if (!TE.attColor) return;
    TE.attUnits[k] = Math.max(0, (TE.attUnits[k]||0) + v);
    const el = document.getElementById('te-att-'+k);
    if (el) el.textContent = TE.attUnits[k];
    const tot = document.getElementById('te-att-total');
    if (tot) tot.textContent = '('+unitTotal(TE.attUnits)+' units)';
    // Refresh save button label
    const btn = document.querySelector('.te-save-btn');
    if (btn) btn.textContent = unitTotal(TE.attUnits)>0 ? '⚔ Save & Queue Battle' : '✓ Done — Save Changes';
}

// legacy alias kept so any leftover onclick="teAdjUnit(...)" still works
function teAdjUnit(k, v) { teAdjDef(k, v); }

function teToggleCastle() {
    if (!G.board[TE.name]) return;
    G.board[TE.name].castle = !G.board[TE.name].castle;
    renderTerrEdit();
}


// ================================================================
// COMBAT PHASE — runs after all players finish Action 2
// ================================================================
let CP = { idx:0, humanBattle:null, humanPhase:null, humanRounds:[] };

function openCombatPhase(roundNum) {
    CP = { idx:0, humanBattle:null, humanPhase:null, humanRounds:[] };
    document.getElementById('cp-round').textContent = roundNum || G.round;
    document.getElementById('cp-overlay').classList.add('open');
    renderCombatPhase();
}

function closeCombatPhase() {
    document.getElementById('cp-overlay').classList.remove('open');
    G.roundCombats = [];
    // Check for player elimination before starting next round
    checkElimination();
    // G.round was already incremented in advanceTurn before openCombatPhase was called
    if (!G.winner) prepareRound(false);
    render();
}

function renderCombatPhase() {
    const battles = G.roundCombats || [];
    const body = document.getElementById('cp-body');

    // Build battle cards (all of them, resolved ones dimmed)
    const cards = battles.map((b, i) => {
        const resolved = b._resolved;
        const isActive = i === CP.idx && !resolved;
        const attColor = b.color || 'neutral';
        const defColor = G.board[b.to]?.owner || 'neutral';
        const attUnits = totalUnitCount(G.board[b.from]?.units || {});
        const defUnits = totalUnitCount(G.board[b.to]?.units || {});
        const humanInvolved = b.color === S.playerColor || defColor === S.playerColor;
        const badge = resolved
            ? `<span class="cp-battle-badge done">✓ ${b._result || 'Resolved'}</span>`
            : humanInvolved
                ? `<span class="cp-battle-badge pending">YOUR BATTLE</span>`
                : `<span class="cp-battle-badge auto">Auto-resolve</span>`;

        let detail = '';
        if (resolved) {
            if (b._htmlLog && b._htmlLog.length) {
                const sections = b._htmlLog.map(s =>
                    `<div style="border-bottom:1px dotted #ddd;padding:6px 0;">${s}</div>`
                ).join('');
                detail = `<div class="cp-auto-log">${sections}</div>`;
            } else {
                detail = `<div class="cp-auto-log">${b._log || ''}</div>`;
            }
        } else if (isActive) {
            detail = humanInvolved
                ? renderCPHumanBattle(b, i)
                : renderCPAutoBattle(b, i);
        }

        return `<div class="cp-battle ${resolved?'resolved':''} ${isActive?'active':''}" id="cp-battle-${i}">
            <div class="cp-battle-hdr">
                <div>
                    <div class="cp-battle-title">${b.from === '__editor__' ? cAttacks(b.color) : b.from+' →'} ${b.to}</div>
                    <div class="cp-battle-sub">${cAttacks(b.color)} ${cName(defColor)}${b._fromEditor?' <span style="font-size:0.8em;opacity:0.6;">(manually queued)</span>':''}</div>
                </div>
                ${badge}
            </div>
            ${detail}
        </div>`;
    }).join('');

    // End button — only enabled when all resolved
    const allDone = battles.every(b => b._resolved);
    body.innerHTML = cards +
        `<button class="cp-end-btn" onclick="closeCombatPhase()" ${allDone?'':'disabled'}>
            ${allDone ? '✓ End Combat Phase — Begin Next Round' : `Resolve battle ${CP.idx+1} of ${battles.length} to continue`}
        </button>`;
}

// ── Auto-resolve a battle and render the log ─────────────────────
function renderCPAutoBattle(b, idx) {
    // Run full auto-combat immediately and store result
    const result = resolveAutoBattle(b);
    G.roundCombats[idx]._resolved = true;
    G.roundCombats[idx]._result = result.winner === b.color ? 'Attacker won' : result.winner === 'defender' ? 'Defender held' : 'Draw';
    G.roundCombats[idx]._log = result.log;
    G.roundCombats[idx]._htmlLog = result.htmlLog;
    applyBattleResult(b, result);

    // Move to next battle
    CP.idx = idx + 1;
    // Re-render after short delay so player sees the resolution
    setTimeout(renderCombatPhase, 400);
    return `<div class="cp-auto-log">⚙ Resolving…</div>`;
}

// ── Human battle UI ───────────────────────────────────────────────
function renderCPHumanBattle(b, idx) {
    const defColor = G.board[b.to]?.owner || 'neutral';
    // For __editor__ battles the attacker has no origin territory — use stored movingUnits
    const attUnits = b._fromEditor ? (b.movingUnits||{}) : (G.board[b.from]?.units || {});
    const defUnits = G.board[b.to]?.units || {};
    const attHex = COLOR_HEX[b.color] || '#888';
    const defHex = COLOR_HEX[defColor] || '#888';
    const attLight = ['orange','green','blue'].includes(b.color);
    const defLight = ['orange','green','blue'].includes(defColor);

    // Use the existing full combat modal for human battles
    return `<div class="cp-human-panel">
        <div class="cp-sides">
            <div class="cp-side" style="background:${attHex};color:${attLight?'#000':'#fff'}">
                <div class="cps-label">ATTACKER</div>
                <div class="cps-name">${b.from}</div>
                <div class="cps-units">${unitStr(attUnits)}</div>
            </div>
            <div class="cp-vs">VS</div>
            <div class="cp-side" style="background:${defHex};color:${defLight?'#000':'#fff'}">
                <div class="cps-label">DEFENDER</div>
                <div class="cps-name">${b.to}</div>
                <div class="cps-units">${unitStr(defUnits)}</div>
            </div>
        </div>
        <button class="cp-next-btn" onclick="launchCPHumanCombat(${idx})">⚔ Start Combat — Roll Dice</button>
    </div>`;
}

function launchCPHumanCombat(idx) {
    const b = G.roundCombats[idx];
    const defColor = G.board[b.to]?.owner || 'neutral';
    CP.activeBattleIdx = idx;
    openCombat(b.color, defColor, b.from, b.to, -1);
    // Override closeCombat to return to CP phase
    CP.returnToCombatPhase = true;
}

// ── Dice + unit helpers ───────────────────────────────────────────
const DICE_GLYPHS = ['','⚀','⚁','⚂','⚃','⚄','⚅'];
function rollDice(n, threshold=4) {
    // Returns array of {value, hit}
    const rolls = [];
    for (let i=0;i<n;i++) {
        const v = Math.ceil(Math.random()*6);
        rolls.push({ value:v, hit: v >= threshold });
    }
    return rolls;
}
function diceRowHTML(rolls) {
    if (!rolls || !rolls.length) return '';
    const glyphs = rolls.map(r =>
        `<span class="die ${r.hit?'hit':'miss'}" title="${r.value} — ${r.hit?'HIT':'miss'}">${DICE_GLYPHS[r.value]}</span>`
    ).join('');
    const hits = rolls.filter(r=>r.hit).length;
    return `<div class="dice-row">${glyphs}<span style="margin-left:6px;font-size:0.85em;color:#555;">${hits} hit${hits!==1?'s':''}</span></div>`;
}
function unitName(k, n) {
    if (k==='F') return n===1 ? 'Footman' : 'Footmen';
    if (k==='A') return n===1 ? 'Archer'  : 'Archers';
    if (k==='C') return 'Cavalry';
    if (k==='S') return n===1 ? 'Siege Engine' : 'Siege Engines';
    return k;
}
function unitDiffStr(before, after) {
    // Returns "2 Footmen + 1 Siege Engine" removed
    const parts = [];
    for (const k of ['S','C','A','F']) {
        const lost = Math.max(0, (before[k]||0) - (after[k]||0));
        if (lost > 0) parts.push(`${lost} ${unitName(k, lost)}`);
    }
    return parts.join(' + ') || 'nothing';
}
function unitRemainStr(u) {
    const parts = [];
    for (const k of ['C','A','F','S']) {
        if ((u[k]||0) > 0) parts.push(`${u[k]} ${unitName(k, u[k])}`);
    }
    return parts.join(' + ') || 'none';
}
function snapUnits(u) { return {F:u.F||0,A:u.A||0,C:u.C||0,S:u.S||0}; }

// ── Resolve automaton battle with dice ────────────────────────────
function resolveAutoBattle(b) {
    const att = b.movingUnits || G.board[b.from]?.units || {};
    const def = G.board[b.to]?.units || {};
    const defColor = G.board[b.to]?.owner || 'neutral';
    const attColorName = cName(b.color);
    const defColorName = cName(defColor);

    let aUnits = snapUnits(att);
    let dUnits = snapUnits(def);
    const aStart = snapUnits(att);
    const dStart = snapUnits(def);
    const htmlLog = [];

    function total(u) { return u.F+u.A+u.C+u.S; }
    function removeCasualties(u, n) {
        let rem = n;
        for (const k of ['F','A','C','S']) {
            const take = Math.min(u[k]||0, rem);
            u[k] -= take; rem -= take;
            if (rem <= 0) break;
        }
    }

    // ── Siege pre-fire ──
    const aSiege = aUnits.S;
    const targetHasCastle = G.board[b.to]?.castle || false;
    if (aSiege > 0 && targetHasCastle) {
        const rolls = rollDice(aSiege*2, 4);
        const hits = rolls.filter(r=>r.hit).length;
        const dBefore = snapUnits(dUnits);
        removeCasualties(dUnits, hits);
        const lost = unitDiffStr(dBefore, dUnits);
        htmlLog.push(
            `<div style="margin-bottom:4px"><b>Siege pre-fire</b> (${aSiege} engine${aSiege>1?'s':''} × 2 dice vs castle):</div>`+
            diceRowHTML(rolls)+
            (hits>0
                ? `<div class="board-instruction"><b>Remove from ${b.to}:</b> ${lost}<br><b>Defender ${defColorName} now has:</b> ${unitRemainStr(dUnits)}</div>`
                : `<div style="color:#888;font-size:0.8em">No casualties.</div>`)
        );
    } else if (aSiege > 0) {
        htmlLog.push(`<div style="color:#888;font-size:0.8em">Siege engines at ${b.to} — no castle, no pre-fire.</div>`);
    }

    // ── Archer volley ──
    const aArch = aUnits.A, dArch = dUnits.A;
    if (aArch+dArch > 0) {
        const aRolls = rollDice(aArch, 4);
        const dRolls = rollDice(dArch, 4);
        const aHits = aRolls.filter(r=>r.hit).length;
        const dHits = dRolls.filter(r=>r.hit).length;
        const aBefore = snapUnits(aUnits), dBefore = snapUnits(dUnits);
        removeCasualties(dUnits, aHits);
        removeCasualties(aUnits, dHits);
        const attLost = unitDiffStr(aBefore, aUnits);
        const defLost = unitDiffStr(dBefore, dUnits);
        let html = `<div style="margin-bottom:4px"><b>Archer volley</b></div>`;
        if (aArch > 0) html += `<div style="font-size:0.8em;color:#555">${attColorName} (${aArch} archer${aArch>1?'s':''})</div>`+diceRowHTML(aRolls);
        if (dArch > 0) html += `<div style="font-size:0.8em;color:#555">${defColorName} (${dArch} archer${dArch>1?'s':''})</div>`+diceRowHTML(dRolls);
        const instructions = [];
        if (aHits > 0) instructions.push(`<b>Remove from ${b.to}:</b> ${defLost}`);
        if (dHits > 0) instructions.push(`<b>Remove from ${b.from==='__editor__'?attColorName:b.from}:</b> ${attLost}`);
        if (instructions.length) {
            html += `<div class="board-instruction">${instructions.join('<br>')}</div>`;
        }
        htmlLog.push(html);
    }

    // ── Main combat rounds ──
    let rounds = 0;
    while (total(aUnits) > 0 && total(dUnits) > 0 && rounds < 10) {
        rounds++;
        const aDice = aUnits.C*2 + aUnits.F + aUnits.A + aUnits.S;
        const dDice = dUnits.C*2 + dUnits.F + dUnits.A + dUnits.S;
        const aRolls = rollDice(aDice);
        const dRolls = rollDice(dDice);
        const aHits = aRolls.filter(r=>r.hit).length;
        const dHits = dRolls.filter(r=>r.hit).length;
        const aBefore = snapUnits(aUnits), dBefore = snapUnits(dUnits);
        removeCasualties(dUnits, aHits);
        removeCasualties(aUnits, dHits);
        const attLost = unitDiffStr(aBefore, aUnits);
        const defLost = unitDiffStr(dBefore, dUnits);

        let html = `<div style="margin-bottom:3px"><b>Round ${rounds}</b></div>`;
        html += `<div style="font-size:0.8em;color:#555">${attColorName} (${aDice} dice)</div>`+diceRowHTML(aRolls);
        html += `<div style="font-size:0.8em;color:#555">${defColorName} (${dDice} dice)</div>`+diceRowHTML(dRolls);
        const instructions = [];
        if (aHits > 0) instructions.push(`<b>Remove from ${b.to}:</b> ${defLost}`);
        if (dHits > 0) instructions.push(`<b>Remove from ${b.from==='__editor__'?attColorName:b.from}:</b> ${attLost}`);
        if (!instructions.length) instructions.push('No casualties this round.');
        html += `<div class="board-instruction">${instructions.join('<br>')}</div>`;
        htmlLog.push(html);
    }

    // ── Final board state ──
    const attSurv = total(aUnits), defSurv = total(dUnits);
    const winner = attSurv > 0 && defSurv === 0 ? b.color : attSurv === 0 ? 'defender' : 'draw';

    let outcomeHTML = '';
    if (winner === b.color) {
        outcomeHTML =
            `<div class="board-instruction"><b>✓ ${attColorName} captures ${b.to}!</b><br>`+
            `Remove all ${defColorName} units from <b>${b.to}</b>.<br>`+
            `Place ${attColorName} survivors at <b>${b.to}</b>: <b>${unitRemainStr(aUnits)}</b>.<br>`+
            (b.from !== '__editor__' ? `Remove ${unitDiffStr(aStart, aUnits)} from <b>${b.from}</b> (units that fought).` : '')+
            `</div>`;
    } else if (winner === 'defender') {
        const attTotalLost = unitDiffStr(aStart, {F:0,A:0,C:0,S:0});
        const defTotalRemain = unitRemainStr(dUnits);
        outcomeHTML =
            `<div class="board-instruction neutral"><b>✗ ${defColorName} holds ${b.to}!</b><br>`+
            (b.from !== '__editor__'
                ? `Remove all attacking ${attColorName} units from <b>${b.from}</b> that moved: <b>${unitRemainStr(b.movingUnits||aStart)}</b>.<br>`
                : `All attacking ${attColorName} units eliminated.<br>`)+
            `<b>${defColorName} remaining at ${b.to}:</b> ${defTotalRemain}</div>`;
    } else {
        outcomeHTML =
            `<div class="board-instruction neutral"><b>⚡ Both sides eliminated!</b><br>`+
            `Remove all ${attColorName} attacking units`+(b.from!=='__editor__'?` from <b>${b.from}</b>`:'')+`.<br>`+
            `${b.to} is now <b>neutral</b> — remove all ${defColorName} units from it.</div>`;
    }
    htmlLog.push(outcomeHTML);

    // Plain text log for the compact view (existing renderCombatPhase uses b._log)
    const plainLog = [];
    if (aSiege > 0 && targetHasCastle) plainLog.push(`Siege pre-fire.`);
    if (aArch+dArch > 0) plainLog.push(`Archer volley.`);
    // Count rounds
    const roundCount = htmlLog.filter((_,i)=> i >= (aSiege>0?1:0) + (aArch+dArch>0?1:0) && i < htmlLog.length-1).length;
    plainLog.push(`${roundCount} combat round${roundCount!==1?'s':''}.`);
    plainLog.push(winner===b.color ? `✓ ${attColorName} captures ${b.to}! (${attSurv} survivors)` :
                  winner==='defender' ? `✗ ${defColorName} holds ${b.to}! (${defSurv} survivors)` :
                  `⚡ Both sides eliminated.`);

    return {
        winner, attSurv, defSurv,
        attUnits: aUnits, defUnits: dUnits,
        log: plainLog.join('<br>'),
        htmlLog               // rich HTML blocks, joined with <hr> for display
    };
}

function applyBattleResult(b, result) {
    const defColor = G.board[b.to]?.owner || 'neutral';
    if (result.winner === b.color) {
        // Attacker wins — move survivors to captured territory
        // __editor__ battles and pre-deducted human moves don't need from-deduction
        if (b.from !== '__editor__' && !b._prededucted) {
            G.board[b.from].units = Object.fromEntries(
                Object.entries(G.board[b.from].units).map(([k,v])=>[k, Math.max(0, v-(b.movingUnits?.[k]||0))])
            );
        }
        G.board[b.to].owner = b.color;
        G.board[b.to].units = result.attUnits;
        // Award crowns for capturing a city
        const cv = crownValueOfCity(b.to);
        if (cv > 0) {
            if (!G.crowns) G.crowns = {};
            G.crowns[b.color] = (G.crowns[b.color]||0) + cv;
            addLog(`${cName(b.color)} moves ${unitStr(b.movingUnits||{})} from ${b.from} to ${cityLabel(b.to)}. ${cityLabel(b.to)} is captured from ${cName(defColor)} and ${cName(b.color)} gains ${cv} Crown${cv>1?'s':''} (banner now at ${G.crowns[b.color]}). ${unitStr(result.attUnits)} remain in ${b.to}.`);
            checkWin(b.color);
        } else {
            addLog(`${cName(b.color)} moves ${unitStr(b.movingUnits||{})} from ${b.from} to ${b.to}. ${b.to} is captured from ${cName(defColor)}. ${unitStr(result.attUnits)} remain in ${b.to}.`);
        }
        // Assign shield token and fire reminder
        const _bsk = shieldKeyForTerr(b.to);
        if (_bsk) {
            if (!G.shields) G.shields = {};
            G.shields[_bsk] = b.color;
            addLog(`🛡 SHIELD GAINED: ${cName(b.color)} now holds the ${cityLabel(b.to)} shield token (captured via combat).`);
            showShieldReminder(_bsk, b.color);
        }
        // Stockholm shield (attacker wins any battle)
        showShieldReminder('Stockholm', b.color);
        applyShieldBonus('Stockholm', b.color, 'battle_win');
    } else if (result.winner === 'defender') {
        // Defender holds — attacking units destroyed (already gone from source for human attacks)
        if (b.from !== '__editor__' && !b._prededucted) {
            ['F','A','C','S'].forEach(k => {
                G.board[b.from].units[k] = Math.max(0, (G.board[b.from].units[k]||0) - (b.movingUnits?.[k]||0));
            });
        }
        addLog(`${cName(b.color)} attacks ${b.to} with ${unitStr(b.movingUnits||{})} from ${b.from}. ${cName(defColor)} holds ${b.to} — all attacking units are eliminated.`);
    } else {
        // Both wiped — territory goes neutral (source already cleared for human attacks)
        G.board[b.to].units = {F:0,A:0,C:0,S:0};
        G.board[b.to].owner = 'neutral';
        if (b.from !== '__editor__' && !b._prededucted) {
            ['F','A','C','S'].forEach(k => {
                G.board[b.from].units[k] = Math.max(0, (G.board[b.from].units[k]||0) - (b.movingUnits?.[k]||0));
            });
        }
        addLog(`${cName(b.color)} attacks ${b.to} with ${unitStr(b.movingUnits||{})} from ${b.from}. Both sides are eliminated — ${b.to} reverts to neutral.`);
    }
}


// ================================================================
// INIT
// ================================================================
// ── Full Log ──────────────────────────────────────────────────
function openFullLog() {
    const el = document.getElementById('full-log-body');
    if (!el || !G.logHistory) return;
    el.innerHTML = G.logHistory.map((m,i) =>
        `<div class="full-log-entry ${i>0?'old':''}">${i===0?'▶ ':'  '}${m}</div>`
    ).join('');
    document.getElementById('full-log-overlay').style.display = 'flex';
}
function closeFullLog() {
    document.getElementById('full-log-overlay').style.display = 'none';
}

// ================================================================
// SAVE / LOAD  (localStorage, 3 named slots + export/import)
// ================================================================
const SAVE_SLOTS = ['Slot 1', 'Slot 2', 'Slot 3'];
const SAVE_KEY   = (slot) => 'riskEurope_save_' + slot.replace(' ', '_');

// Serialise G + S to JSON, converting Sets → arrays
function serialiseState() {
    function replacer(key, val) {
        if (val instanceof Set) return { __type:'Set', values:[...val] };
        return val;
    }
    return JSON.stringify({ G, S }, replacer);
}

// Deserialise, converting Set-arrays back
function deserialiseState(json) {
    function reviver(key, val) {
        if (val && val.__type === 'Set') return new Set(val.values);
        return val;
    }
    return JSON.parse(json, reviver);
}

function slSave(slot) {
    if (!G.round) { alert('No game in progress to save.'); return; }
    const data = {
        savedAt: new Date().toLocaleString(),
        round: G.round,
        playerColor: S.playerColor,
        state: serialiseState()
    };
    localStorage.setItem(SAVE_KEY(slot), JSON.stringify(data));
    addLog('Game saved to ' + slot + '.');
    renderSaveSlots();
}

function slLoad(slot) {
    const raw = localStorage.getItem(SAVE_KEY(slot));
    if (!raw) { alert('No save found in ' + slot + '.'); return; }
    if (!confirm('Load ' + slot + '? Unsaved progress will be lost.')) return;
    try {
        const data = JSON.parse(raw);
        const { G: savedG, S: savedS } = deserialiseState(data.state);
        Object.assign(G, savedG);
        Object.assign(S, savedS);
        document.getElementById('setup-screen').style.display = 'none';
        document.getElementById('game-screen').style.display  = 'block';
        document.getElementById('board-btn').style.display    = 'block';
        closeSaveLoad();
        render();
        addLog('Game loaded from ' + slot + ' (Round ' + G.round + ').');
    } catch(e) {
        alert('Failed to load save: ' + e.message);
    }
}

function slDelete(slot) {
    if (!confirm('Delete save in ' + slot + '?')) return;
    localStorage.removeItem(SAVE_KEY(slot));
    renderSaveSlots();
}

function slExport() {
    if (!G.round) { alert('No game in progress to export.'); return; }
    const json = serialiseState();
    document.getElementById('sl-json').value = json;
    document.getElementById('sl-json').select();
    try { document.execCommand('copy'); } catch(e) {}
}

function slImport() {
    const json = document.getElementById('sl-json').value.trim();
    if (!json) { alert('Paste exported save data into the text box first.'); return; }
    if (!confirm('Import this save? Current game will be replaced.')) return;
    try {
        const { G: savedG, S: savedS } = deserialiseState(json);
        Object.assign(G, savedG);
        Object.assign(S, savedS);
        document.getElementById('setup-screen').style.display = 'none';
        document.getElementById('game-screen').style.display  = 'block';
        document.getElementById('board-btn').style.display    = 'block';
        closeSaveLoad();
        render();
        addLog('Game imported successfully (Round ' + G.round + ').');
    } catch(e) {
        alert('Import failed — invalid save data.\n' + e.message);
    }
}

function renderSaveSlots() {
    const el = document.getElementById('saveload-slots');
    if (!el) return;
    el.innerHTML = SAVE_SLOTS.map(slot => {
        const raw  = localStorage.getItem(SAVE_KEY(slot));
        const data = raw ? JSON.parse(raw) : null;
        const info = data
            ? `<div class="slot-name">${slot}</div><div class="slot-meta">Round ${data.round} · ${data.playerColor?.toUpperCase()} · ${data.savedAt}</div>`
            : `<div class="slot-name">${slot}</div><div class="slot-meta" style="color:#bbb;">Empty</div>`;
        const gameActive = !!(G.round);
        return `<div class="save-slot">
            <div class="save-slot-info">${info}</div>
            <div class="save-slot-btns">
                <button class="sl-btn save" onclick="slSave('${slot}')" ${gameActive?'':'disabled'} title="Save current game here">Save</button>
                <button class="sl-btn load" onclick="slLoad('${slot}')" ${data?'':'disabled'} title="Load this save">Load</button>
                <button class="sl-btn del"  onclick="slDelete('${slot}')" ${data?'':'disabled'} title="Delete this save">✕</button>
            </div>
        </div>`;
    }).join('');
}

function openSaveLoad() {
    renderSaveSlots();
    document.getElementById('sl-json').value = '';
    document.getElementById('saveload-overlay').style.display = 'flex';
}
function closeSaveLoad() {
    document.getElementById('saveload-overlay').style.display = 'none';
}

showStep(0);
</script>

<!-- BOARD EDITOR OVERLAY -->
<button class="board-btn" onclick="openBoardEditor()" id="board-btn" style="display:none">
    🗺 Board State
</button>
<div class="board-overlay" id="board-overlay">
  <div class="board-modal">
    <div class="board-modal-header">
      <span id="board-modal-title">Board State</span>
      <button class="board-close" onclick="closeBoardEditor()">✕</button>
    </div>
    <div class="board-content" id="board-content"></div>
  </div>
</div>


<!-- COMBAT MODAL -->
<div class="combat-overlay" id="combat-overlay">
  <div class="combat-modal">
    <div class="combat-header">
      <span id="combat-title">COMBAT</span>
      <span class="combat-phase-badge" id="combat-phase-label">SETUP</span>
    </div>
    <div class="combat-body" id="combat-body">
      <!-- rendered by JS -->
    </div>
  </div>
</div>



<!-- Territory Edit Modal -->
<div class="terr-edit-overlay" id="terr-edit-overlay">
  <div class="terr-edit-modal">
    <div class="terr-edit-hdr">
      <span id="terr-edit-title">Edit Territory</span>
      <button class="terr-edit-close" onclick="closeTerrEdit()">✕</button>
    </div>
    <div class="terr-edit-body" id="terr-edit-body"></div>
  </div>
</div>


<!-- COMBAT PHASE OVERLAY -->
<div class="cp-overlay" id="cp-overlay">
  <div class="cp-modal">
    <div class="cp-header">⚔ COMBAT PHASE — ROUND <span id="cp-round">1</span></div>
    <div class="cp-subhdr">All battles from this round are resolved now, in order.</div>
    <div class="cp-body" id="cp-body"></div>
  </div>
</div>

</body>
</html>
