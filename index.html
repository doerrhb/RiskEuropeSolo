<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Risk Europe: Solo Companion</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap');
        :root {
            --parchment: #f7eed8; --parchment-dark: #eedfc0; --ink: #1e140a; --ink-light: #4a3020;
            --accent: #8b1a1a; --gold: #c8952a; --gold-light: #f0c060;
            --border: #6b4c2a; --border-light: #a07050;
            --p-orange: #f97316; --p-green: #4db847; --p-purple: #3b0764; --p-blue: #5bb8f5;
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { font-family: 'Crimson Text', Georgia, serif; background: #0d0a06; color: var(--ink);
               display: flex; flex-direction: column; align-items: center; padding: 8px; margin: 0; min-height: 100vh; }
        .screen { width: 100%; max-width: 680px; }
        .paper { background: var(--parchment); border: 3px solid var(--border); border-radius: 4px;
                 box-shadow: 0 0 40px rgba(0,0,0,0.8); position: relative; overflow: hidden; }
        .inner { padding: 18px; position: relative; z-index: 1; }

        /* WIZARD */
        .wizard-header { background: var(--ink); color: var(--gold-light); padding: 13px 18px;
                         font-family: 'Cinzel', serif; display: flex; justify-content: space-between; align-items: center; }
        .wh-title { font-size: 1em; font-weight: 700; letter-spacing: 0.05em; }
        .wh-step  { font-size: 0.78em; opacity: 0.7; }
        .progress-bar { height: 4px; background: rgba(200,149,42,0.2); }
        .progress-fill { height: 100%; background: var(--gold); transition: width 0.4s; }
        .setup-title { font-family: 'Cinzel', serif; font-size: 1.35em; font-weight: 700; color: var(--accent);
                       text-align: center; margin: 0 0 6px; }
        .setup-sub { text-align: center; color: var(--ink-light); font-size: 0.93em; margin: 0 0 18px; line-height: 1.55; }
        .color-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 18px; }
        .color-choice { border-radius: 10px; padding: 18px 10px; text-align: center; cursor: pointer;
                        border: 3px solid transparent; transition: all 0.2s; color: white;
                        font-family: 'Cinzel', serif; font-weight: 700; font-size: 1em; letter-spacing: 0.06em; }
        .color-choice.selected { border-color: white; box-shadow: 0 0 0 3px var(--ink); transform: scale(1.04); }
        .color-choice:active { transform: scale(0.97); }
        .capital-card { background: rgba(255,252,245,0.92); border: 2px solid var(--border-light);
                        border-radius: 8px; padding: 12px 14px; margin-bottom: 10px; }
        .cap-header { display: flex; align-items: center; gap: 10px; margin-bottom: 7px; }
        .cap-dot { width: 15px; height: 15px; border-radius: 50%; flex-shrink: 0; border: 2px solid rgba(0,0,0,0.2); }
        .cap-name { font-family: 'Cinzel', serif; font-weight: 700; font-size: 0.95em; color: var(--accent); }
        .cap-body { font-size: 0.87em; line-height: 1.7; }
        .cap-note { font-style: italic; color: var(--ink-light); font-size: 0.85em; margin-top: 3px; }
        .cap-chooser { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 10px 0; }
        .cap-btn { background: rgba(255,252,245,0.92); border: 2px solid var(--border-light); border-radius: 8px;
                   padding: 12px 8px; text-align: center; cursor: pointer; transition: all 0.15s;
                   font-family: 'Cinzel', serif; font-weight: 700; font-size: 0.88em; color: var(--ink); }
        .cap-btn:active { transform: scale(0.97); }
        .cap-btn.selected { border-color: var(--accent); background: rgba(139,26,26,0.07); color: var(--accent); }
        .cap-btn .cap-tax { font-size: 0.75em; color: var(--ink-light); font-family: 'Crimson Text',serif; font-weight:400; margin-top:3px; }
        .info-box { background: rgba(200,149,42,0.1); border-left: 3px solid var(--gold);
                    padding: 10px 14px; border-radius: 0 6px 6px 0; font-size: 0.87em;
                    line-height: 1.6; margin: 10px 0; }

        /* GAME HEADER */
        .game-header { background: var(--ink); color: var(--gold-light); padding: 10px 16px;
                       font-family: 'Cinzel', serif; display: flex; justify-content: space-between; align-items: center;
                       border-bottom: 3px solid var(--gold); }
        .gh-round { font-size: 1.05em; font-weight: 700; }
        .gh-step  { font-size: 0.8em; opacity: 0.85; }
        .log-strip { background: #1a1208; border-bottom: 2px solid var(--border); padding: 5px 14px;
                     font-family: 'Courier New', monospace; font-size: 0.75em; min-height: 2.1em; }
        .log-entry { color: #d4a84b; }
        .log-entry.old { color: #7a6030; }

        /* PLAYER BAR */
        .players-bar { display: grid; grid-template-columns: repeat(4,1fr); border-bottom: 2px solid var(--border); padding-bottom: 18px; }
        .player-tile { padding: 9px 3px 7px; text-align: center; position: relative; border-right: 1px solid rgba(0,0,0,0.15); }
        .player-tile:last-child { border-right: none; }
        .player-tile.active { box-shadow: inset 0 0 0 3px rgba(255,255,255,0.9); z-index: 2; }
        .player-tile.active::after { content: 'â–¼ ACTIVE'; position: absolute; bottom: -16px; left: 50%;
            transform: translateX(-50%); color: white; font-size: 7px; font-family: 'Cinzel',serif; font-weight: 700;
            letter-spacing: 0.05em; white-space: nowrap; background: var(--ink); padding: 1px 5px; border-radius: 3px; z-index: 10; }
        .p-name { font-family: 'Cinzel',serif; font-size: 0.7em; font-weight: 700; letter-spacing: 0.08em;
                  color: rgba(255,255,255,0.95); display: flex; align-items: center; justify-content: center; gap: 4px; }
        .crown-badge { font-size: 11px; cursor: pointer; padding: 1px 3px; border-radius: 3px; opacity: 0.35; line-height: 1; transition: 0.15s; }
        .player-tile.is-first .crown-badge { opacity: 1; filter: drop-shadow(0 0 4px silver); }
        .player-tile.is-saved { border-color: #b8860b; background: #fef9e7; }
        .player-tile.is-eliminated { opacity: 0.45; filter: grayscale(0.7); }
        .player-tile.is-pending .crown-badge { opacity: 1; filter: drop-shadow(0 0 6px #c0c0c0); animation: pulse 1s infinite; }
        @keyframes pulse { 0%,100%{transform:scale(1)}50%{transform:scale(1.3)} }
        .coin-row { display: flex; align-items: center; justify-content: center; gap: 5px; margin: 4px 0 3px; }
        .coin-count { font-family: 'Cinzel',serif; font-size: 1.28em; font-weight: 700; color: inherit; min-width: 24px; text-align: center; }
        .coin-btn { background: rgba(128,128,128,0.2); border: 1px solid rgba(0,0,0,0.2); color: inherit;
                    width: 22px; height: 22px; border-radius: 50%; cursor: pointer; font-size: 14px;
                    display: flex; align-items: center; justify-content: center; padding: 0; transition: background 0.1s; }
        .coin-btn:active { background: rgba(128,128,128,0.4); }
        .coin-threshold { font-size: 0.58em; font-weight: 700; padding: 2px 6px; border-radius: 8px;
                          color: white; letter-spacing: 0.05em; font-family: 'Cinzel',serif; }
        .mode-tax   { background: rgba(0,0,0,0.5); border: 1px solid rgba(255,100,100,0.7); }
        .mode-spend { background: rgba(0,0,0,0.5); border: 1px solid rgba(100,255,150,0.6); }
        .deck-pip { font-size: 0.58em; color: inherit; opacity: 0.55; font-family: 'Courier New',monospace; }

        /* ACTION AREA */
        .action-area { padding: 14px; }


        .action-card { display: block; background: #fffdf5; border: 3px solid var(--border); border-radius: 10px;
                       padding: 20px 20px 16px; font-family: 'Cinzel',serif; font-size: 1.2em; font-weight: 700;
                       color: var(--accent); letter-spacing: 0.04em; text-align: center; margin-bottom: 12px;
                       box-shadow: 0 4px 12px rgba(0,0,0,0.12); position: relative; }
        .action-card.revealed  { border-color: var(--accent); }
        .action-card.unrevealed{ color: #bbb; border-color: #ccc; }
        .card-sub { font-size: 0.58em; color: var(--ink-light); font-family: 'Crimson Text',serif; font-weight: 400; margin-top: 4px; }
        .human-banner { border: 3px dashed var(--player-color); border-radius: 10px; padding: 22px 16px;
                        text-align: center; background: rgba(26,95,168,0.06); margin-bottom: 12px; }
        .human-banner h2 { font-family: 'Cinzel',serif; color: var(--player-color); margin: 0 0 6px; font-size: 1.2em; }
        .human-banner p { margin: 0; color: var(--ink-light); font-size: 0.9em; line-height: 1.55; }

        /* STEPS */
        .steps-panel { background: rgba(255,252,245,0.95); border: 2px solid var(--border-light); border-radius: 8px; overflow: hidden; margin-bottom: 12px; }
        .steps-header { color: white; padding: 8px 14px; font-family: 'Cinzel',serif; font-size: 0.8em; font-weight: 700; letter-spacing: 0.06em; }
        .step-item { display: flex; gap: 11px; padding: 11px 14px; border-bottom: 1px solid rgba(0,0,0,0.07);
                     cursor: pointer; align-items: flex-start; transition: background 0.1s; }
        .step-item:last-child { border-bottom: none; }
        .step-item.checked { background: rgba(30,126,68,0.07); }
        .step-checkbox { width: 26px; height: 26px; border: 2px solid var(--border-light); border-radius: 6px;
                         flex-shrink: 0; display: flex; align-items: center; justify-content: center;
                         font-size: 15px; transition: all 0.15s; margin-top: 2px; }
        .step-item.checked .step-checkbox { background: var(--p-green); border-color: var(--p-green); color: white; }
        .step-num { font-family: 'Cinzel',serif; font-weight: 700; color: var(--gold); font-size: 0.8em; margin-top: 4px; flex-shrink: 0; }
        .step-text { font-size: 0.88em; line-height: 1.62; color: var(--ink); flex: 1; }
        .step-text b { color: var(--accent); }
        .if-tie { font-style: italic; color: var(--ink-light); display: block; margin-top: 2px; font-size: 0.92em; }
        .rule-note { display: block; margin-top: 5px; padding: 4px 8px; background: rgba(200,149,42,0.1);
                     border-left: 2px solid var(--gold); border-radius: 0 4px 4px 0; font-size: 0.9em; color: var(--ink-light); }
        .buy-highlight { display: block; font-family: 'Cinzel',serif; font-size: 0.95em; color: var(--accent); font-weight: 700; margin: 4px 0; }
        .steps-progress { background: rgba(0,0,0,0.08); height: 4px; }
        .steps-progress-fill { height: 100%; background: var(--p-green); transition: width 0.2s; }
        .step-divider {
            display: flex; align-items: center; gap: 10px;
            padding: 8px 14px; background: var(--ink); color: var(--gold-light);
            font-family: 'Cinzel',serif; font-size: 0.78em; font-weight: 700;
            letter-spacing: 0.07em; text-transform: uppercase;
        }
        .step-divider::before, .step-divider::after {
            content:''; flex:1; height:1px; background: rgba(240,192,96,0.35);
        }

        /* BUTTONS */
        .btn-primary { display: block; width: 100%; background: var(--accent); color: white; border: none;
                       border-radius: 8px; padding: 17px; font-family: 'Cinzel',serif; font-size: 1.02em;
                       font-weight: 700; letter-spacing: 0.06em; cursor: pointer;
                       box-shadow: 0 4px 0 #4a0a0a; transition: all 0.1s; margin-bottom: 10px; }
        .btn-primary:active { transform: translateY(2px); box-shadow: 0 2px 0 #4a0a0a; }
        .btn-advance { display: block; width: 100%; background: var(--ink); color: #e8d8b8; border: none;
                       border-radius: 8px; padding: 15px; font-family: 'Cinzel',serif; font-size: 0.95em;
                       font-weight: 600; letter-spacing: 0.05em; cursor: pointer;
                       box-shadow: 0 3px 0 #050301; transition: all 0.1s; margin-bottom: 10px; }
        .btn-advance:active { transform: translateY(2px); box-shadow: 0 1px 0 #050301; }
        .btn-advance:disabled { background: #555; cursor: not-allowed; opacity: 0.55; box-shadow: 0 3px 0 #222; }
        .btn-secondary { display: block; width: 100%; background: var(--parchment-dark); color: var(--ink);
                         border: 2px solid var(--border); border-radius: 8px; padding: 13px;
                         font-family: 'Cinzel',serif; font-size: 0.93em; font-weight: 600; cursor: pointer;
                         margin-bottom: 10px; transition: all 0.1s; }
        .btn-secondary:active { transform: scale(0.98); }
        .btn-reset { background: none; border: none; color: #999; font-size: 0.8em; cursor: pointer; padding: 8px; text-decoration: underline; display: block; margin: 4px auto 0; }

        /* REFERENCE */
        .ref-toggle { background: rgba(255,252,245,0.9); border: 1px solid var(--border-light); border-radius: 6px; margin-bottom: 8px; overflow: hidden; }
        .ref-toggle-btn { width: 100%; padding: 9px 14px; background: none; border: none; cursor: pointer;
                          display: flex; justify-content: space-between; align-items: center;
                          font-family: 'Cinzel',serif; font-size: 0.76em; font-weight: 700; letter-spacing: 0.06em;
                          color: var(--accent); text-transform: uppercase; text-align: left; }
        .ref-toggle-btn .arrow { transition: transform 0.2s; font-size: 0.9em; }
        .ref-toggle-btn.open .arrow { transform: rotate(180deg); }
        .ref-body { display: none; padding: 8px 14px 12px; font-size: 0.84em; line-height: 1.65; border-top: 1px solid var(--border-light); }
        .ref-body.open { display: block; }
        .ref-body table { width: 100%; border-collapse: collapse; margin-top: 6px; }
        .ref-body td, .ref-body th { padding: 3px 5px; border-bottom: 1px solid rgba(0,0,0,0.07); }
        .ref-body th { font-weight: 700; font-family: 'Cinzel',serif; font-size: 0.82em; color: var(--accent); }

        @media (max-width: 480px) {
            .inner { padding: 13px; }
            .cap-chooser { grid-template-columns: 1fr 1fr; }
        }
    
        /* BOARD EDITOR */
        .board-btn { position:fixed; bottom:16px; right:16px; z-index:100; background:var(--ink); color:var(--gold-light); border:2px solid var(--gold); border-radius:50px; padding:10px 18px; font-family:'Cinzel',serif; font-size:0.8em; font-weight:700; letter-spacing:0.06em; cursor:pointer; box-shadow:0 4px 12px rgba(0,0,0,0.5); }
        .board-overlay { display:none; position:fixed; top:0;left:0;right:0;bottom:0; background:rgba(0,0,0,0.7); z-index:200; overflow-y:auto; padding:8px; }
        .board-overlay.open { display:block; }
        .board-modal { background:var(--parchment); max-width:680px; margin:0 auto; border:3px solid var(--border); border-radius:6px; overflow:hidden; }
        .board-modal-header { background:var(--ink); color:var(--gold-light); padding:12px 16px; display:flex; justify-content:space-between; align-items:center; font-family:'Cinzel',serif; font-weight:700; font-size:0.95em; }
        .board-close { background:none; border:none; color:var(--gold-light); font-size:1.4em; cursor:pointer; padding:0 4px; }
        .board-content { padding:10px; max-height:75vh; overflow-y:auto; }
        /* Step 1 â€” territory list */
        .be-terr-list { margin:0; padding:0; list-style:none; }
        .be-terr-item { display:flex; align-items:center; justify-content:space-between; padding:13px 14px; border-bottom:1px solid rgba(0,0,0,0.07); cursor:pointer; transition:background 0.1s; }
        .be-terr-item:last-child { border-bottom:none; }
        .be-terr-item:active, .be-terr-item.sel { background:rgba(139,26,26,0.06); }
        .be-terr-item .bt-name { font-family:'Cinzel',serif; font-size:0.95em; font-weight:700; color:var(--ink); }
        .be-terr-item .bt-sub  { font-size:0.78em; color:var(--ink-light); margin-top:2px; }
        .be-terr-item .bt-badge { font-size:0.78em; color:var(--ink-light); text-align:right; }
        .be-terr-item .bt-badge b { font-family:'Cinzel',serif; color:var(--ink); }
        .be-terr-item .bt-arrow { color:var(--accent); font-size:1.1em; margin-left:8px; }
        /* Step 2 â€” move panel */
        .be-back-btn { display:flex; align-items:center; gap:6px; background:none; border:none; font-family:'Cinzel',serif; font-size:0.82em; color:var(--accent); cursor:pointer; padding:4px 0 10px; font-weight:700; letter-spacing:0.04em; }
        .be-from-banner { background:var(--ink); color:var(--gold-light); padding:10px 14px; border-radius:6px; margin-bottom:12px; }
        .be-from-banner .bfb-name { font-family:'Cinzel',serif; font-size:1em; font-weight:700; }
        .be-from-banner .bfb-units { font-size:0.82em; opacity:0.85; margin-top:2px; }
        .be-dest-label { font-family:'Cinzel',serif; font-size:0.72em; font-weight:700; letter-spacing:0.08em; color:var(--ink-light); text-transform:uppercase; margin-bottom:8px; }
        .be-dest-list { display:flex; flex-direction:column; gap:7px; margin-bottom:14px; }
        .be-dest-item { display:flex; align-items:center; gap:10px; padding:11px 14px; border:2px solid var(--border-light); border-radius:8px; cursor:pointer; background:#fffdf5; transition:all 0.12s; }
        .be-dest-item:active { opacity:0.8; }
        .be-dest-item.sel { border-color:var(--accent); background:rgba(139,26,26,0.05); }
        .be-dest-item.is-enemy { border-color:rgba(139,26,26,0.35); }
        .be-dest-item.is-friendly { border-color:rgba(30,126,68,0.35); }
        .be-dest-dot { width:13px; height:13px; border-radius:50%; flex-shrink:0; border:1px solid rgba(0,0,0,0.15); }
        .be-dest-info { flex:1; }
        .be-dest-name { font-family:'Cinzel',serif; font-size:0.92em; font-weight:700; color:var(--ink); }
        .be-dest-sub  { font-size:0.76em; color:var(--ink-light); margin-top:1px; }
        /* Count picker */
        .be-count-box { background:rgba(0,0,0,0.04); border-radius:8px; padding:12px 14px; }
        .be-count-label { font-size:0.82em; color:var(--ink-light); margin-bottom:10px; }
        .be-count-row { display:flex; align-items:center; gap:12px; }
        .be-cnt-btn { width:36px; height:36px; border-radius:7px; border:2px solid var(--border); background:var(--parchment-dark); font-size:20px; cursor:pointer; display:flex; align-items:center; justify-content:center; font-weight:700; }
        .be-cnt-val { font-family:'Cinzel',serif; font-size:1.5em; font-weight:700; min-width:36px; text-align:center; }
        .be-cnt-note { font-size:0.78em; color:var(--ink-light); }
        .be-confirm-btn { margin-top:12px; width:100%; background:var(--accent); color:white; border:none; border-radius:8px; padding:14px; font-family:'Cinzel',serif; font-size:0.95em; font-weight:700; cursor:pointer; }
        .be-confirm-btn:active { opacity:0.85; }
        .be-confirm-btn:disabled { background:#aaa; cursor:not-allowed; }
        /* Correction panel at bottom */
        .be-corrections { margin-top:14px; border-top:1px solid var(--border-light); padding-top:10px; }
        .be-corr-title { font-family:'Cinzel',serif; font-size:0.72em; font-weight:700; letter-spacing:0.08em; color:var(--ink-light); text-transform:uppercase; margin-bottom:8px; }
        .be-owner-row { display:flex; align-items:center; gap:6px; margin-bottom:6px; flex-wrap:wrap; }
        .be-owner-row span { font-size:0.8em; color:var(--ink-light); }
        .be-odot { width:18px; height:18px; border-radius:50%; cursor:pointer; border:2px solid transparent; transition:0.12s; flex-shrink:0; }
        .be-odot.sel { border-color:var(--ink); box-shadow:0 0 0 2px white; transform:scale(1.15); }
        .be-castle-btn { font-size:0.78em; padding:4px 9px; border:1px solid var(--border-light); border-radius:5px; background:var(--parchment-dark); cursor:pointer; font-family:'Cinzel',serif; }
        .be-castle-btn.on { background:rgba(200,149,42,0.15); border-color:var(--gold); color:#7a5a00; }
        /* Full board view */
        .fbs-section { margin-bottom:14px; }
        .fbs-section-hdr { display:flex; align-items:center; gap:8px; padding:7px 10px; border-radius:6px; font-family:'Cinzel',serif; font-size:0.78em; font-weight:700; letter-spacing:0.06em; color:white; margin-bottom:4px; }
        .fbs-row { display:grid; grid-template-columns:1fr 80px 110px; align-items:center; padding:6px 10px; border-bottom:1px solid rgba(0,0,0,0.05); font-size:0.83em; }
        .fbs-row:last-child { border-bottom:none; }
        .fbs-row .fr-name { font-family:'Cinzel',serif; font-weight:700; color:var(--ink); overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
        .fbs-row .fr-sub  { font-size:0.78em; color:var(--ink-light); text-align:center; }
        .fbs-row .fr-units { font-size:0.82em; color:var(--ink); text-align:right; white-space:nowrap; }
        .fbs-empty { color:var(--ink-light); font-style:italic; padding:6px 10px; font-size:0.82em; }
        .fbs-back-btn { display:flex; align-items:center; gap:5px; background:none; border:none; font-family:'Cinzel',serif; font-size:0.82em; color:var(--accent); cursor:pointer; padding:0 0 10px; font-weight:700; }
        .btn-full-board { width:100%; margin-top:10px; padding:11px; background:var(--ink); color:var(--gold-light); border:none; border-radius:7px; font-family:'Cinzel',serif; font-size:0.82em; font-weight:700; cursor:pointer; letter-spacing:0.04em; }
        .btn-full-board:active { opacity:0.85; }
                .ub { background:rgba(0,0,0,0.08); border:1px solid rgba(0,0,0,0.15); border-radius:3px; width:20px; height:20px; cursor:pointer; font-size:12px; display:flex; align-items:center; justify-content:center; }
        .be-terr-item.be-moved { opacity:0.45; background:rgba(0,0,0,0.04); cursor:default; }
        .be-terr-item.be-moved .bt-name { text-decoration: line-through; }
        /* Unit type steppers */
        .unit-type-grid { display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:10px; }
        .unit-type-row { display:flex; align-items:center; justify-content:space-between; background:#fff; border:1px solid var(--border-light); border-radius:7px; padding:8px 10px; }
        .unit-type-row.zero { opacity:0.4; }
        .ut-label { font-family:'Cinzel',serif; font-size:0.82em; font-weight:700; color:var(--ink); }
        .ut-avail { font-size:0.72em; color:var(--ink-light); }
        .ut-stepper { display:flex; align-items:center; gap:6px; }
        .ut-btn { width:26px; height:26px; border-radius:5px; border:1px solid var(--border); background:var(--parchment-dark); font-size:15px; cursor:pointer; display:flex; align-items:center; justify-content:center; font-weight:700; }
        .ut-btn:disabled { opacity:0.3; cursor:not-allowed; }
        .ut-val { font-family:'Cinzel',serif; font-size:1em; font-weight:700; min-width:20px; text-align:center; }



        /* ---- COMBAT MODAL ---- */
        .combat-overlay {
            display:none; position:fixed; top:0;left:0;right:0;bottom:0;
            background:rgba(0,0,0,0.85); z-index:300; overflow-y:auto; padding:8px;
        }
        .combat-overlay.open { display:block; }
        .combat-modal {
            background:var(--parchment); max-width:680px; margin:0 auto;
            border:3px solid var(--accent); border-radius:6px; overflow:hidden;
            box-shadow: 0 0 40px rgba(200,0,0,0.4);
        }
        .combat-header {
            background:var(--accent); color:white; padding:12px 16px;
            font-family:'Cinzel',serif; font-weight:700; font-size:1em;
            display:flex; justify-content:space-between; align-items:center;
        }
        .combat-phase-badge {
            background:rgba(255,255,255,0.2); border-radius:20px;
            padding:3px 10px; font-size:0.75em; letter-spacing:0.06em;
        }
        .combat-body { padding:14px; }
        .combat-territory-row {
            display:flex; align-items:center; justify-content:space-between;
            gap:8px; margin-bottom:14px;
        }
        .combat-side {
            flex:1; border-radius:8px; padding:10px 12px; color:white; text-align:center;
        }
        .combat-side .side-label { font-family:'Cinzel',serif; font-size:0.72em; font-weight:700; letter-spacing:0.08em; opacity:0.85; }
        .combat-side .side-name  { font-family:'Cinzel',serif; font-size:1em; font-weight:700; margin:3px 0; }
        .combat-side .side-units { font-size:0.82em; margin-top:4px; opacity:0.9; }
        .combat-vs { font-family:'Cinzel',serif; font-size:1.3em; font-weight:700; color:var(--accent); flex-shrink:0; }
        .combat-side.neutral-side { background:#777; }

        /* Dice display */
        .dice-section {
            background:rgba(255,252,245,0.9); border:1px solid var(--border-light);
            border-radius:8px; padding:12px; margin-bottom:10px;
        }
        .dice-section h5 {
            font-family:'Cinzel',serif; font-size:0.78em; font-weight:700;
            color:var(--accent); text-transform:uppercase; letter-spacing:0.06em;
            margin:0 0 10px; border-bottom:1px solid rgba(139,26,26,0.15); padding-bottom:6px;
        }
        .dice-row { display:flex; flex-wrap:wrap; gap:6px; margin-bottom:8px; align-items:center; }
        .die-face {
            width:36px; height:36px; border-radius:6px; display:flex; align-items:center;
            justify-content:center; font-size:1.6em; border:2px solid rgba(0,0,0,0.2);
            transition: all 0.2s;
        }
        .die-face.hit   { background:#1e7e44; border-color:#155330; }
        .die-face.miss  { background:#ddd;    border-color:#bbb; }
        .die-face.rolling { animation: diceRoll 0.3s ease; }
        @keyframes diceRoll { 0%{transform:rotate(0) scale(1)} 50%{transform:rotate(180deg) scale(1.2)} 100%{transform:rotate(360deg) scale(1)} }
        .dice-label { font-size:0.82em; color:var(--ink-light); font-style:italic; }
        .hit-count { font-family:'Cinzel',serif; font-weight:700; font-size:1.05em; }
        .hit-count.has-hits { color:#1e7e44; }
        .hit-count.no-hits  { color:#aaa; }

        /* Human input */
        .human-roll-box {
            background:rgba(26,95,168,0.07); border:2px solid var(--p-blue);
            border-radius:8px; padding:12px 14px; margin-bottom:10px;
        }
        .human-roll-box h5 { font-family:'Cinzel',serif; font-size:0.82em; font-weight:700;
            color:var(--p-blue); margin:0 0 10px; }
        .dice-count-big { font-family:'Cinzel',serif; font-size:1.4em; font-weight:700;
            color:var(--p-blue); }
        .hit-input-row { display:flex; align-items:center; gap:10px; margin-top:10px; flex-wrap:wrap; }
        .hit-stepper { display:flex; align-items:center; gap:8px; }
        .hit-stepper .hs-btn { width:32px; height:32px; border-radius:6px; border:2px solid var(--border);
            background:var(--parchment-dark); font-size:18px; cursor:pointer; display:flex;
            align-items:center; justify-content:center; font-weight:700; }
        .hit-stepper .hs-val { font-family:'Cinzel',serif; font-size:1.4em; font-weight:700;
            min-width:32px; text-align:center; }

        /* Casualty report */
        .casualty-box {
            background:rgba(139,26,26,0.06); border-left:3px solid var(--accent);
            border-radius:0 6px 6px 0; padding:10px 14px; margin-bottom:10px;
            font-size:0.88em; line-height:1.7;
        }
        .casualty-box b { color:var(--accent); }
        .remove-instruction { font-weight:600; color:var(--accent); }

        /* Round history */
        .round-history { max-height:120px; overflow-y:auto; margin-bottom:10px; }
        .round-entry { font-size:0.8em; color:var(--ink-light); padding:3px 0;
            border-bottom:1px dotted #ddd; font-family:'Courier New',monospace; }
        .round-entry:last-child { border-bottom:none; }
        .round-entry.attacker-win { color:#1e7e44; }
        .round-entry.defender-win { color:var(--accent); }

        /* Auto-combat log */
        .auto-combat-log { background:#1a1208; border-radius:6px; padding:10px 14px;
            font-family:'Courier New',monospace; font-size:0.8em; max-height:200px;
            overflow-y:auto; margin-bottom:12px; }
        .acl-line { color:#d4a84b; padding:2px 0; border-bottom:1px solid rgba(255,255,255,0.05); }
        .acl-line.hit  { color:#4db847; }
        .acl-line.loss { color:#e8192c; }
        .acl-line.end  { color:#f0c060; font-weight:bold; border-top:1px solid rgba(240,192,96,0.3); margin-top:4px; padding-top:4px; }

        /* Combat action buttons */
        .combat-btn-row { display:flex; gap:10px; margin-top:10px; }
        .btn-combat-primary {
            flex:2; background:var(--accent); color:white; border:none; border-radius:8px;
            padding:15px; font-family:'Cinzel',serif; font-size:0.95em; font-weight:700;
            cursor:pointer; box-shadow:0 3px 0 #4a0a0a; transition:all 0.1s;
        }
        .btn-combat-primary:active { transform:translateY(2px); box-shadow:0 1px 0 #4a0a0a; }
        .btn-combat-primary:disabled { background:#aaa; box-shadow:0 3px 0 #666; cursor:not-allowed; }
        .btn-combat-retreat {
            flex:1; background:var(--ink); color:#e8d8b8; border:none; border-radius:8px;
            padding:15px; font-family:'Cinzel',serif; font-size:0.85em; font-weight:600;
            cursor:pointer; box-shadow:0 3px 0 #050301; transition:all 0.1s;
        }
        .btn-combat-retreat:active { transform:translateY(2px); }
        .combat-result-banner {
            text-align:center; padding:16px; border-radius:8px; margin-bottom:12px;
            font-family:'Cinzel',serif; font-size:1.1em; font-weight:700;
        }
        .combat-result-banner.win  { background:rgba(30,126,68,0.15); color:#1e7e44; border:2px solid #1e7e44; }
        .combat-result-banner.loss { background:rgba(139,26,26,0.12); color:var(--accent); border:2px solid var(--accent); }
        .combat-result-banner.draw { background:rgba(200,149,42,0.15); color:var(--gold); border:2px solid var(--gold); }

        
        /* ===== COMBAT MODAL ===== */
        .combat-overlay{display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.87);z-index:300;overflow-y:auto;padding:8px;}
        .combat-overlay.open{display:block;}
        .combat-modal{background:var(--parchment);max-width:680px;margin:0 auto;border:3px solid var(--accent);border-radius:6px;overflow:hidden;box-shadow:0 0 40px rgba(200,0,0,0.4);}
        .combat-header{background:var(--accent);color:white;padding:12px 16px;font-family:'Cinzel',serif;font-weight:700;font-size:1em;display:flex;justify-content:space-between;align-items:center;}
        .combat-phase-badge{background:rgba(255,255,255,0.2);border-radius:20px;padding:3px 10px;font-size:0.75em;letter-spacing:0.06em;}
        .combat-body{padding:14px;}
        .combat-sides-row{display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:14px;}
        .combat-side{flex:1;border-radius:8px;padding:10px 12px;text-align:center;}
        .combat-side .sl{font-family:'Cinzel',serif;font-size:0.68em;font-weight:700;letter-spacing:0.08em;opacity:0.82;}
        .combat-side .sn{font-family:'Cinzel',serif;font-size:0.95em;font-weight:700;margin:3px 0;}
        .combat-side .su{font-size:0.8em;margin-top:3px;opacity:0.9;}
        .combat-vs{font-family:'Cinzel',serif;font-size:1.3em;font-weight:700;color:var(--accent);flex-shrink:0;}
        .dice-section{background:rgba(255,252,245,0.9);border:1px solid var(--border-light);border-radius:8px;padding:11px;margin-bottom:10px;}
        .dice-section h5{font-family:'Cinzel',serif;font-size:0.76em;font-weight:700;color:var(--accent);text-transform:uppercase;letter-spacing:0.06em;margin:0 0 9px;border-bottom:1px solid rgba(139,26,26,0.15);padding-bottom:5px;}
        .dice-row{display:flex;flex-wrap:wrap;gap:5px;align-items:center;margin-bottom:5px;}
        .die-face{width:34px;height:34px;border-radius:6px;display:flex;align-items:center;justify-content:center;font-size:1.5em;border:2px solid rgba(0,0,0,0.18);}
        .die-face.hit{background:#1e7e44;border-color:#155330;}
        .die-face.miss{background:#ddd;border-color:#bbb;}
        .hits-summary{font-family:'Cinzel',serif;font-size:0.9em;font-weight:700;}
        .hits-summary.some{color:#1e7e44;}
        .hits-summary.none{color:#999;}
        .human-roll-box{background:rgba(26,95,168,0.07);border:2px solid var(--p-blue);border-radius:8px;padding:12px 14px;margin-bottom:10px;}
        .human-roll-box h5{font-family:'Cinzel',serif;font-size:0.8em;font-weight:700;color:var(--p-blue);margin:0 0 8px;}
        .dice-count-big{font-family:'Cinzel',serif;font-size:1.4em;font-weight:700;color:var(--p-blue);}
        .hit-input-row{display:flex;align-items:center;gap:10px;margin-top:10px;flex-wrap:wrap;}
        .hs-btn{width:32px;height:32px;border-radius:6px;border:2px solid var(--border);background:var(--parchment-dark);font-size:18px;cursor:pointer;display:flex;align-items:center;justify-content:center;font-weight:700;}
        .hs-val{font-family:'Cinzel',serif;font-size:1.4em;font-weight:700;min-width:32px;text-align:center;}
        .casualty-report{background:rgba(139,26,26,0.06);border-left:3px solid var(--accent);border-radius:0 6px 6px 0;padding:10px 14px;margin-bottom:10px;font-size:0.87em;line-height:1.7;}
        .round-log{max-height:130px;overflow-y:auto;margin-bottom:10px;}
        .round-log-entry{font-size:0.78em;color:var(--ink-light);padding:2px 0;border-bottom:1px dotted #ddd;font-family:'Courier New',monospace;}
        .auto-log{background:#1a1208;border-radius:6px;padding:10px 14px;font-family:'Courier New',monospace;font-size:0.78em;max-height:220px;overflow-y:auto;margin-bottom:12px;}
        .al{color:#d4a84b;padding:1px 0;}
        .al.g{color:#4db847;}
        .al.r{color:#e8192c;}
        .al.y{color:#f0c060;font-weight:bold;}
        .combat-btn-row{display:flex;gap:10px;margin-top:12px;}
        .btn-fight{flex:2;background:var(--accent);color:white;border:none;border-radius:8px;padding:15px;font-family:'Cinzel',serif;font-size:0.95em;font-weight:700;cursor:pointer;box-shadow:0 3px 0 #4a0a0a;transition:all 0.1s;}
        .btn-fight:active{transform:translateY(2px);box-shadow:0 1px 0 #4a0a0a;}
        .btn-fight:disabled{background:#aaa;box-shadow:0 3px 0 #666;cursor:not-allowed;}
        .btn-retreat{flex:1;background:var(--ink);color:#e8d8b8;border:none;border-radius:8px;padding:15px;font-family:'Cinzel',serif;font-size:0.85em;font-weight:600;cursor:pointer;box-shadow:0 3px 0 #050301;}
        .btn-retreat:active{transform:translateY(2px);}
        .result-banner{text-align:center;padding:16px;border-radius:8px;margin-bottom:12px;font-family:'Cinzel',serif;font-size:1.1em;font-weight:700;}
        .result-banner.win{background:rgba(30,126,68,0.14);color:#1e7e44;border:2px solid #1e7e44;}
        .result-banner.loss{background:rgba(139,26,26,0.1);color:var(--accent);border:2px solid var(--accent);}
        .result-banner.draw{background:rgba(200,149,42,0.14);color:var(--gold);border:2px solid var(--gold);}

        
        /* ===== HUMAN TURN ===== */
        .human-turn-steps { margin-top: 12px; }
        .ht-step {
            display: flex; align-items: flex-start; gap: 11px; padding: 11px 14px;
            border-bottom: 1px solid rgba(26,95,168,0.1); background: rgba(255,253,250,0.95);
            cursor: pointer; transition: background 0.1s;
        }
        .ht-step:last-child { border-bottom: none; }
        .ht-step.done { background: rgba(30,126,68,0.07); }
        .ht-step .ht-cb {
            width: 26px; height: 26px; border: 2px solid var(--player-color); border-radius: 6px;
            flex-shrink: 0; display: flex; align-items: center; justify-content: center;
            font-size: 15px; margin-top: 2px; transition: all 0.15s;
        }
        .ht-step.done .ht-cb { background: var(--p-green); border-color: var(--p-green); color: white; }
        .ht-step .ht-text { font-size: 0.88em; line-height: 1.62; color: var(--ink); flex: 1; }
        .ht-step .ht-text b { color: var(--player-color); }
        .ht-open-board {
            display: flex; align-items: center; gap: 8px; padding: 10px 14px;
            background: rgba(0,0,0,0.04); border: 2px solid var(--player-color);
            border-radius: 8px; font-family: 'Cinzel',serif; font-size: 0.88em;
            font-weight: 700; color: var(--player-color); cursor: pointer;
            margin: 8px 0; transition: background 0.15s; width: 100%;
        }
        .ht-open-board:active { background: rgba(26,95,168,0.15); }
        .ht-open-board.done-board { background: rgba(30,126,68,0.1); border-color: var(--p-green); color: #1e7e44; }
        .ht-progress { background: rgba(0,0,0,0.08); height: 4px; border-radius: 0 0 6px 6px; }
        .ht-progress-fill { height: 100%; background: var(--player-color); border-radius: 0 0 6px 6px; transition: width 0.2s; }

        
        /* Territory edit modal */
        .terr-edit-overlay { display:none; position:fixed; top:0;left:0;right:0;bottom:0; background:rgba(0,0,0,0.75); z-index:400; overflow-y:auto; padding:10px; }
        .terr-edit-overlay.open { display:block; }
        .terr-edit-modal { background:var(--parchment); max-width:480px; margin:0 auto; border:3px solid var(--border); border-radius:8px; overflow:hidden; }
        .terr-edit-hdr { background:var(--ink); color:var(--gold-light); padding:11px 16px; display:flex; justify-content:space-between; align-items:center; font-family:'Cinzel',serif; font-weight:700; font-size:0.95em; }
        .terr-edit-close { background:none; border:none; color:var(--gold-light); font-size:1.4em; cursor:pointer; }
        .terr-edit-body { padding:14px; }
        .te-section { margin-bottom:14px; }
        .te-label { font-family:'Cinzel',serif; font-size:0.72em; font-weight:700; letter-spacing:0.08em; color:var(--ink-light); text-transform:uppercase; margin-bottom:8px; }
        .te-owner-row { display:flex; gap:8px; flex-wrap:wrap; }
        .te-owner-btn { flex:1; min-width:60px; padding:8px 4px; border:3px solid transparent; border-radius:7px; font-family:'Cinzel',serif; font-size:0.72em; font-weight:700; cursor:pointer; text-align:center; transition:0.12s; }
        .te-owner-btn.sel { border-color:var(--ink); box-shadow:0 0 0 2px white, 0 0 0 4px var(--ink); }
        .te-units-grid { display:grid; grid-template-columns:1fr 1fr; gap:8px; }
        .te-unit-row { display:flex; align-items:center; justify-content:space-between; background:#fffdf5; border:1px solid var(--border-light); border-radius:7px; padding:8px 10px; }
        .te-unit-label { font-family:'Cinzel',serif; font-size:0.82em; font-weight:700; }
        .te-unit-sub { font-size:0.7em; color:var(--ink-light); }
        .te-stepper { display:flex; align-items:center; gap:6px; }
        .te-btn { width:28px; height:28px; border-radius:5px; border:1px solid var(--border); background:var(--parchment-dark); font-size:16px; cursor:pointer; display:flex; align-items:center; justify-content:center; font-weight:700; }
        .te-val { font-family:'Cinzel',serif; font-size:1.1em; font-weight:700; min-width:24px; text-align:center; }
        .te-castle-row { display:flex; align-items:center; justify-content:space-between; padding:10px 12px; background:#fffdf5; border:1px solid var(--border-light); border-radius:7px; }
        .te-castle-label { font-family:'Cinzel',serif; font-size:0.88em; font-weight:700; }
        .te-castle-toggle { padding:7px 16px; border-radius:6px; border:2px solid var(--border); font-family:'Cinzel',serif; font-size:0.82em; font-weight:700; cursor:pointer; background:var(--parchment-dark); transition:0.12s; }
        .te-castle-toggle.on { background:rgba(200,149,42,0.15); border-color:var(--gold); color:#7a5a00; }
        .te-save-btn { width:100%; margin-top:14px; padding:14px; background:var(--accent); color:white; border:none; border-radius:8px; font-family:'Cinzel',serif; font-size:0.95em; font-weight:700; cursor:pointer; }
        .te-save-btn:active { opacity:0.85; }
        .te-total-badge { font-size:0.8em; color:var(--ink-light); font-style:italic; }

        
        /* ===== COMBAT PHASE SCREEN ===== */
        .cp-overlay { display:none; position:fixed; top:0;left:0;right:0;bottom:0; background:rgba(10,0,0,0.92); z-index:350; overflow-y:auto; padding:10px; }
        .cp-overlay.open { display:block; }
        .cp-modal { background:var(--parchment); max-width:680px; margin:0 auto; border:3px solid var(--accent); border-radius:8px; overflow:hidden; box-shadow:0 0 60px rgba(200,0,0,0.5); }
        .cp-header { background:var(--accent); color:white; padding:14px 18px; font-family:'Cinzel',serif; font-weight:700; font-size:1.1em; letter-spacing:0.04em; text-align:center; }
        .cp-subhdr { background:rgba(139,26,26,0.08); padding:10px 16px; font-size:0.82em; color:var(--ink-light); text-align:center; border-bottom:1px solid var(--border-light); }
        .cp-body { padding:12px; }
        .cp-battle { border:2px solid var(--border-light); border-radius:8px; margin-bottom:10px; overflow:hidden; background:#fffdf5; }
        .cp-battle.resolved { opacity:0.55; }
        .cp-battle.active { border-color:var(--accent); background:#fff; box-shadow:0 2px 12px rgba(139,26,26,0.15); }
        .cp-battle-hdr { display:flex; align-items:center; justify-content:space-between; padding:10px 14px; border-bottom:1px solid var(--border-light); }
        .cp-battle-title { font-family:'Cinzel',serif; font-size:0.88em; font-weight:700; color:var(--ink); }
        .cp-battle-sub { font-size:0.75em; color:var(--ink-light); margin-top:1px; }
        .cp-battle-badge { font-size:0.72em; padding:3px 9px; border-radius:20px; font-family:'Cinzel',serif; font-weight:700; }
        .cp-battle-badge.pending { background:rgba(139,26,26,0.1); color:var(--accent); }
        .cp-battle-badge.done { background:rgba(30,126,68,0.12); color:#1e7e44; }
        .cp-battle-badge.auto { background:rgba(0,0,0,0.07); color:var(--ink-light); }
        .cp-auto-log { padding:10px 14px; font-size:0.8em; color:var(--ink-light); line-height:1.7; }
        .cp-human-panel { padding:12px 14px; }
        .cp-sides { display:flex; align-items:center; gap:8px; margin-bottom:12px; }
        .cp-side { flex:1; border-radius:7px; padding:10px 12px; color:white; text-align:center; }
        .cp-side .cps-label { font-size:0.7em; font-family:'Cinzel',serif; font-weight:700; letter-spacing:0.06em; opacity:0.8; }
        .cp-side .cps-name  { font-family:'Cinzel',serif; font-size:0.95em; font-weight:700; margin:3px 0; }
        .cp-side .cps-units { font-size:0.8em; opacity:0.9; }
        .cp-vs { font-family:'Cinzel',serif; font-size:1.2em; font-weight:700; color:var(--accent); flex-shrink:0; }
        .cp-result-banner { text-align:center; padding:12px; border-radius:7px; margin-bottom:10px; font-family:'Cinzel',serif; font-size:1em; font-weight:700; }
        .cp-result-banner.win  { background:rgba(30,126,68,0.12); color:#1e7e44; border:2px solid #1e7e44; }
        .cp-result-banner.loss { background:rgba(139,26,26,0.1); color:var(--accent); border:2px solid var(--accent); }
        .cp-result-banner.draw { background:rgba(200,149,42,0.12); color:var(--gold); border:2px solid var(--gold); }
        .cp-end-btn { width:100%; padding:16px; background:var(--ink); color:var(--gold-light); border:none; border-radius:8px; font-family:'Cinzel',serif; font-size:1em; font-weight:700; cursor:pointer; margin-top:4px; letter-spacing:0.04em; }
        .cp-end-btn:active { opacity:0.85; }
        .cp-end-btn:disabled { opacity:0.4; cursor:not-allowed; }
        .cp-next-btn { width:100%; padding:14px; background:var(--accent); color:white; border:none; border-radius:8px; font-family:'Cinzel',serif; font-size:0.95em; font-weight:700; cursor:pointer; margin-top:8px; }

        
        /* Shield reminder steps */
        .shield-reminder {
            background: linear-gradient(135deg, rgba(200,149,42,0.12), rgba(200,149,42,0.06));
            border: 2px solid var(--gold);
            border-radius: 7px;
            padding: 9px 13px;
            font-family: 'Cinzel', serif;
            font-size: 0.82em;
            font-weight: 700;
            color: #7a5a00;
            letter-spacing: 0.02em;
        }

        </style>
</head>
<body>

<div id="setup-screen" class="screen">
<div class="paper">
    <div class="wizard-header">
        <span class="wh-title">RISK EUROPE â€” SOLO SETUP</span>
        <span class="wh-step" id="wiz-step-label">Step 1 of 7</span>
    </div>
    <div class="progress-bar"><div class="progress-fill" id="wiz-progress" style="width:14%"></div></div>
    <div class="inner" id="wiz-body"></div>
</div>
</div>

<div id="game-screen" class="screen" style="display:none">
<div class="paper">
    <div class="game-header">
        <span class="gh-round" id="round-display">ROUND 1</span>
        <span class="gh-step"  id="step-display">ACTION 1 of 2</span>
    </div>
    <div class="log-strip" id="action-log"></div>
    <div class="players-bar" id="player-bar"></div>
    <div class="action-area">
        <div id="ai-view">
            <div class="action-card unrevealed" id="card-display">
                Tap button to reveal<br><span class="card-sub">Automaton card is face-down</span>
            </div>
            <button class="btn-primary" id="reveal-btn" onclick="revealAction()">â–¶ REVEAL ACTION</button>
        </div>
        <div id="human-view" style="display:none">
            <!-- populated by renderHumanTurn() -->
        </div>

        <div class="steps-panel" id="steps-panel" style="display:none">
            <div class="steps-header" id="steps-header">STEPS TO PERFORM</div>
            <div class="steps-progress"><div class="steps-progress-fill" id="steps-progress-fill" style="width:0%"></div></div>
            <div id="steps-list"></div>
        </div>

        <div class="ref-toggle">
            <button class="ref-toggle-btn" onclick="toggleRef('ref-arrival')">
                âš” Arrival Minima (Attacking) <span class="arrow">â–¼</span>
            </button>
            <div class="ref-body" id="ref-arrival">
                Each unit (regardless of type) counts as 1. To attack an enemy territory:<br><br>
                <table>
                    <tr><th>Arriving army size</th><th>Attack threshold</th></tr>
                    <tr><td>1 â€“ 5 units</td><td>Must be â‰¥ defender count</td></tr>
                    <tr><td>6 â€“ 10 units</td><td>May be up to 3 fewer than defender</td></tr>
                    <tr><td>11 â€“ 15 units</td><td>May be up to 4 fewer than defender</td></tr>
                    <tr><td>16 â€“ 20 units</td><td>May be up to 5 fewer than defender</td></tr>
                    <tr><td>21+ units</td><td>No restriction</td></tr>
                </table>
                <br>âš  A Siege Engine is always required to attack a city that has a Castle.
            </div>
        </div>
        <div class="ref-toggle">
            <button class="ref-toggle-btn" onclick="toggleRef('ref-move')">
                ðŸš¶ Movement <span class="arrow">â–¼</span>
            </button>
            <div class="ref-body" id="ref-move">
                <b>EXPAND</b> â€” Move an army from any territory into an adjacent city (non-owned).<br>
                Priority: highest Tax city &amp; largest army. If tied: fewest defenders; roll die.<br><br>

                <b>SPLIT EXPAND</b> â€” Move one army up to <b>2 territories</b> toward a city to enter it.<br>
                Cannot pass through enemy territory â€” must stop and fight if it enters one.<br>
                Priority: highest Tax â†’ 1 step preferred over 2 â†’ fewest defenders. If can't reach any city: fall back to Maneuver.<br><br>

                <b>POSITION</b> â€” When no city entry is possible, move the <b>largest army</b> one step toward the highest-Tax non-owned city.<br><br>

                <b>MANEUVER</b> â€” Relocate any units from one own territory to another own or disputed territory up to <b>2 territories away</b>, travelling only through own territories.<br>
                Cannot move out of a disputed territory. Stops upon entering a disputed territory.<br>
                Priority: reinforce threatened territory (highest Tax) â†’ reinforce frontline near enemy city â†’ reposition.<br><br>

                <hr style="border:none;border-top:1px solid var(--border);margin:8px 0;">
                <b>LEAVE-BEHIND</b> â€” When an army departs a territory it must leave units behind:<br><br>
                â€¢ <b>Non-urban territory:</b> always leave <b>1 unit</b>.<br>
                â€¢ <b>City:</b> leave units equal to the city's <b>Tax value</b> (e.g. Tax 3 â†’ leave 3).<br><br>
                <b>Which units to leave (cheapest first):</b><br>
                A. Footmen &nbsp;â†’&nbsp; B. Archers &nbsp;â†’&nbsp; C. Siege Engines &nbsp;â†’&nbsp; D. Cavalry
            </div>
        </div>
        <div class="ref-toggle">
            <button class="ref-toggle-btn" onclick="toggleRef('ref-spend')">
                ðŸ’° Full Spend Table <span class="arrow">â–¼</span>
            </button>
            <div class="ref-body" id="ref-spend">
                Automatons spend at the row matching their exact coin count (or highest row â‰¤ their coins):<br><br>
                <table>
                    <tr><th>Coins</th><th>Purchase</th></tr>
                    <tr><td>5</td><td>2 Footmen + 1 Cavalry</td></tr>
                    <tr><td>6</td><td>1 Footman + 1 Archer + 1 Cavalry</td></tr>
                    <tr><td>7</td><td>2 Footmen + 1 Archer + 1 Cavalry</td></tr>
                    <tr><td>8</td><td>2 Footmen + 2 Cavalry</td></tr>
                    <tr><td>9</td><td>2 Footmen + 2 Archers + 1 Cavalry</td></tr>
                    <tr><td>10</td><td>1 Siege Engine</td></tr>
                    <tr><td>11</td><td>1 Footman + 1 Siege Engine</td></tr>
                    <tr><td>12</td><td>1 Castle</td></tr>
                    <tr><td>13</td><td>1 Cavalry + 1 Siege Engine</td></tr>
                    <tr><td>14</td><td>2 Footmen + 1 Castle</td></tr>
                    <tr><td>15</td><td>2 Footmen + 1 Cavalry + 1 Siege Engine</td></tr>
                    <tr><td>16</td><td>2 Footmen + 1 Archer + 1 Castle</td></tr>
                    <tr><td>17</td><td>2 Footmen + 1 Archer + 1 Cavalry + 1 Siege Engine</td></tr>
                    <tr><td>18</td><td>2 Footmen + 1 Cavalry + 1 Castle</td></tr>
                    <tr><td>19</td><td>2 Footmen + 2 Archers + 1 Cavalry + 1 Siege Engine</td></tr>
                    <tr><td>20</td><td>3 Footmen + 1 Archer + 1 Cavalry + 1 Castle</td></tr>
                </table>
                <br>No castles left in supply â†’ buy 1 Crown Card + 2 Footmen instead.<br>
                Missing a figure type â†’ substitute 2 Footmen â†” 1 Archer. Keep leftover coins.
            </div>
        </div>

        <div style="margin-top: 12px;">
            <button class="btn-advance" id="complete-btn" onclick="advanceTurn()" disabled>
                âœ“ COMPLETE TURN â€” NEXT PLAYER
            </button>
            <div id="stuck-hint" style="display:none;text-align:center;margin-top:4px;">
                <button onclick="forceAdvance()" style="background:none;border:none;color:var(--ink-light);font-size:0.75em;cursor:pointer;text-decoration:underline;">Stuck? Force advance turn â†’</button>
            </div>
            <button class="btn-reset" onclick="confirmReset()">â†º Full Reset / Return to Setup</button>
        </div>
    </div>
</div>
</div>

<script>
// ================================================================
// DATA
// ================================================================
const CAPITALS = [
    { name:"Madrid",         tax:3, units:3, adjOptions:[{name:"Valencia",units:2}] },
    { name:"Paris",          tax:3, units:3, adjOptions:[{name:"Lorraine",units:2},{name:"Normandy",units:2},{name:"Navarre",units:2}] },
    { name:"London",         tax:3, units:3, adjOptions:[{name:"Lorraine",units:2},{name:"Normandy",units:2},{name:"Wales",units:2}] },
    { name:"Stockholm",      tax:3, units:3, adjOptions:[{name:"Denmark",units:2},{name:"Finland",units:2}] },
    { name:"Kiev",           tax:2, units:2, adjOptions:[{name:"Smolensk",units:3}] },
    { name:"Rome",           tax:4, units:3, adjOptions:[{name:"Lombardy",units:2}] },
    { name:"Berlin",         tax:4, units:3, adjOptions:[{name:"Lorraine",units:2},{name:"Denmark",units:2},{name:"Bohemia",units:2},{name:"Franconia",units:2}] },
    { name:"Constantinople", tax:3, units:3, adjOptions:[{name:"Bulgaria",units:2}] },
];

const DECK_BASE = [
    "TAX OR SPEND","TAX OR SPEND","TAX OR SPEND",
    "EXPAND OR MANEUVER","EXPAND OR MANEUVER",
    "SPLIT EXPAND OR MANEUVER","SPLIT EXPAND OR MANEUVER",
    "FORTIFY / EXPAND OR MANEUVER",
    "SIEGE ASSAULT / EXPAND OR MANEUVER",
    "KING ME"
];

const SPEND_TABLE = {
    5:"2 Footmen + 1 Cavalry", 6:"1 Footman + 1 Archer + 1 Cavalry",
    7:"2 Footmen + 1 Archer + 1 Cavalry", 8:"2 Footmen + 2 Cavalry",
    9:"2 Footmen + 2 Archers + 1 Cavalry", 10:"1 Siege Engine",
    11:"1 Footman + 1 Siege Engine", 12:"1 Castle",
    13:"1 Cavalry + 1 Siege Engine", 14:"2 Footmen + 1 Castle",
    15:"2 Footmen + 1 Cavalry + 1 Siege Engine", 16:"2 Footmen + 1 Archer + 1 Castle",
    17:"2 Footmen + 1 Archer + 1 Cavalry + 1 Siege Engine", 18:"2 Footmen + 1 Cavalry + 1 Castle",
    19:"2 Footmen + 2 Archers + 1 Cavalry + 1 Siege Engine", 20:"3 Footmen + 1 Archer + 1 Cavalry + 1 Castle"
};
const COLOR_HEX = { orange:'#f97316', green:'#4db847', purple:'#3b0764', blue:'#5bb8f5' };

// ================================================================
// TERRITORY MAP  (62 territories, verified from board image)
// ================================================================
const T = {
  // --- BRITISH ISLES ---
  "Scotland":          { tax:0, adj:["England","Ireland","Norway"] },
  "Ireland":           { tax:0, adj:["Scotland","Wales","Dublin","Brittany","Norway"] },
  "Dublin":            { tax:2, adj:["Ireland","Wales"] },
  "Wales":             { tax:0, adj:["Ireland","England","London"] },
  "England":           { tax:0, adj:["Scotland","Wales","London"] },
  "London":            { tax:3, adj:["England","Wales","Normandy"] },
  // --- SCANDINAVIA ---
  "Norway":            { tax:0, adj:["Scotland","Ireland","Sweden","Denmark"] },
  "Sweden":            { tax:0, adj:["Norway","Finland","Denmark","Stockholm"] },
  "Stockholm":         { tax:3, adj:["Sweden","Finland","Denmark"] },
  "Finland":           { tax:0, adj:["Sweden","Stockholm","Estonia","Novgorod"] },
  "Denmark":           { tax:0, adj:["Norway","Sweden","Stockholm","Friesland","Pomerania"] },
  // --- FRANCE / IBERIA ---
  "Brittany":          { tax:0, adj:["Ireland","Normandy","France"] },
  "Normandy":          { tax:0, adj:["London","Brittany","Paris","Lorraine","France"] },
  "Paris":             { tax:3, adj:["Normandy","France","Lorraine","Burgundy"] },
  "France":            { tax:0, adj:["Brittany","Normandy","Paris","Burgundy","Navarre"] },
  "Burgundy":          { tax:0, adj:["France","Paris","Lorraine","Swabia","Lombardy","Barcelona","Navarre"] },
  "Navarre":           { tax:0, adj:["France","Burgundy","Barcelona","LeÃ³n Castile"] },
  "LeÃ³n Castile":      { tax:0, adj:["Navarre","Portugal","Valencia","Granada","Madrid","Morocco"] },
  "Madrid":            { tax:3, adj:["LeÃ³n Castile","Portugal","Valencia"] },
  "Portugal":          { tax:0, adj:["LeÃ³n Castile","Madrid","Granada"] },
  "Valencia":          { tax:0, adj:["LeÃ³n Castile","Madrid","Barcelona","Granada"] },
  "Barcelona":         { tax:0, adj:["Navarre","Burgundy","Valencia"] },
  "Granada":           { tax:0, adj:["LeÃ³n Castile","Portugal","Valencia"] },
  "Morocco":           { tax:0, adj:["LeÃ³n Castile","Algeria"] },
  // --- HOLY ROMAN EMPIRE ---
  "Friesland":         { tax:0, adj:["Denmark","Saxony","Lorraine"] },
  "Saxony":            { tax:0, adj:["Denmark","Friesland","Berlin","Lorraine","Franconia","Bohemia","Pomerania"] },
  "Berlin":            { tax:4, adj:["Saxony","Pomerania","Franconia"] },
  "Lorraine":          { tax:0, adj:["Normandy","Friesland","Saxony","Franconia","Swabia","Burgundy","Paris"] },
  "Franconia":         { tax:0, adj:["Saxony","Berlin","Lorraine","Bohemia","Bavaria","Swabia"] },
  "Swabia":            { tax:0, adj:["Lorraine","Franconia","Zurich","Bavaria","Burgundy","Lombardy"] },
  "Zurich":            { tax:2, adj:["Swabia","Bavaria","Lombardy"] },
  "Bavaria":           { tax:0, adj:["Franconia","Swabia","Zurich","Bohemia","Highlands","Venice"] },
  "Bohemia":           { tax:0, adj:["Saxony","Franconia","Bavaria","Highlands","Poland"] },
  // --- EASTERN EUROPE ---
  "Pomerania":         { tax:0, adj:["Denmark","Saxony","Berlin","Poland","Prussia"] },
  "Prussia":           { tax:0, adj:["Pomerania","Poland","Lithuania"] },
  "Poland":            { tax:0, adj:["Pomerania","Prussia","Bohemia","Highlands","Warsaw","Galicia","Lithuania"] },
  "Warsaw":            { tax:2, adj:["Poland","Galicia","Lithuania"] },
  "Highlands":         { tax:0, adj:["Bohemia","Bavaria","Poland","Hungary","Galicia"] },
  "Hungary":           { tax:0, adj:["Highlands","Bavaria","Venice","Buda","Galicia","Serbia"] },
  "Buda":              { tax:3, adj:["Hungary","Venice","Galicia","Serbia"] },
  "Galicia":           { tax:0, adj:["Poland","Warsaw","Highlands","Hungary","Buda","Rusland"] },
  "Rusland":           { tax:0, adj:["Galicia","Lithuania","Polotsk","Smolensk","Kiev"] },
  "Kiev":              { tax:2, adj:["Rusland","Smolensk"] },
  "Lithuania":         { tax:0, adj:["Prussia","Poland","Warsaw","Rusland","Polotsk","Estonia"] },
  "Estonia":           { tax:0, adj:["Finland","Lithuania","Polotsk","Novgorod"] },
  "Polotsk":           { tax:0, adj:["Lithuania","Estonia","Rusland","Smolensk","Novgorod"] },
  "Smolensk":          { tax:0, adj:["Rusland","Kiev","Polotsk","Novgorod"] },
  "Novgorod":          { tax:4, adj:["Finland","Estonia","Polotsk","Smolensk"] },
  // --- ITALY ---
  "Lombardy":          { tax:0, adj:["Burgundy","Swabia","Zurich","Venice","Rome"] },
  "Venice":            { tax:0, adj:["Bavaria","Hungary","Buda","Lombardy","Kingdom of Sicily","Serbia"] },
  "Rome":              { tax:4, adj:["Lombardy","Kingdom of Sicily"] },
  "Kingdom of Sicily": { tax:0, adj:["Rome","Venice","Sardinia","Tunisia","Bejaia"] },
  "Sardinia":          { tax:0, adj:["Kingdom of Sicily","Tunisia"] },
  // --- BALKANS ---
  "Serbia":            { tax:0, adj:["Hungary","Buda","Venice","Bulgaria","Greece"] },
  "Bulgaria":          { tax:0, adj:["Serbia","Greece","Constantinople","Turkey"] },
  "Greece":            { tax:0, adj:["Serbia","Bulgaria","Athens","Constantinople"] },
  "Athens":            { tax:2, adj:["Greece","Constantinople"] },
  "Constantinople":    { tax:3, adj:["Bulgaria","Greece","Athens","Turkey"] },
  "Turkey":            { tax:0, adj:["Constantinople","Bulgaria"] },
  // --- NORTH AFRICA ---
  "Algeria":           { tax:0, adj:["Morocco","Tunisia","Bejaia"] },
  "Bejaia":            { tax:3, adj:["Algeria","Tunisia","Kingdom of Sicily"] },
  "Tunisia":           { tax:0, adj:["Algeria","Bejaia","Kingdom of Sicily","Sardinia"] },
};

// Helper: list all city (capital) names
const ALL_CITIES = Object.keys(T).filter(n => T[n].tax > 0);

// ================================================================
// BOARD STATE HELPERS
// ================================================================
// Normalize a territory name to match a T key (case-insensitive fallback)
function normTerrName(name) {
    if (!name) return null;
    if (T[name]) return name; // exact match
    const lower = name.toLowerCase();
    const found = Object.keys(T).find(k => k.toLowerCase() === lower);
    return found || null;
}

// Safe board set: only sets if the name resolves to a valid T key
function setBoardTerr(name, owner, units, castle) {
    const n = normTerrName(name);
    if (!n) { console.warn('Unknown territory:', name); return; }
    G.board[n] = { owner, units, castle };
}

function initBoard() {
    G.board = {};
    // Init all territories as neutral/empty
    for (const name of Object.keys(T)) {
        G.board[name] = { owner:'neutral', units:{F:0,A:0,C:0,S:0}, castle:false };
    }
    // Populate automaton territories from wizard data
    const autos = autoColors_g();
    autos.forEach(color => {
        const primary   = S.autoCapitals[color];
        const secondary = S.autoSecondary[color];
        if (primary) {
            setBoardTerr(primary.name, color, {F:primary.units,A:0,C:0,S:0}, true);
            if (primary._adj) {
                setBoardTerr(primary._adj.name, color, {F:primary._adj.units,A:0,C:0,S:0}, false);
            }
        }
        if (secondary) {
            setBoardTerr(secondary.name, color, {F:secondary.units,A:0,C:0,S:0}, false);
        }
    });
    // Player territories
    const pc = S.playerCapital;
    const ps = S.playerSecondary;
    if (pc) {
        setBoardTerr(pc.name, S.playerColor, {F: S.playerPrimaryUnits||3, A:0,C:0,S:0}, true);
        if (pc._adj) {
            const adjU = Math.max(0, 5 - (S.playerPrimaryUnits||3));
            setBoardTerr(pc._adj.name, S.playerColor, {F:adjU,A:0,C:0,S:0}, false);
        }
    }
    if (ps) {
        setBoardTerr(ps.name, S.playerColor, {F:ps.units,A:0,C:0,S:0}, false);
    }
    console.log('Board initialized:', Object.keys(G.board).length, 'territories,',
        Object.values(G.board).filter(b=>b.owner!=='neutral').length, 'owned.');
}

function totalUnitCount(name) {
    const u = G.board[name]?.units || {F:0,A:0,C:0,S:0};
    return u.F + u.A + u.C + u.S;
}

function unitStr(u, short=false) {
    const parts = [];
    if (u.C > 0) parts.push(`${u.C} Cavalry`);
    if (u.A > 0) parts.push(`${u.A} Archer${u.A>1?'s':''}`);
    if (u.F > 0) parts.push(`${u.F} Footm${u.F>1?'en':'an'}`);
    if (u.S > 0) parts.push(`${u.S} Siege`);
    return parts.length ? parts.join(' + ') : 'no units';
}

function unitTotal(u) { return u.F + u.A + u.C + u.S; }

function leaveBehindCount(name) {
    // Automaton rule: must leave Tax-value units in a city, 1 in non-urban
    return T[name]?.tax > 0 ? T[name].tax : 1;
}

function leaveBehindPlayer(name) {
    // Same leave-behind rule applies to all players: Tax value for cities, 1 for non-urban
    return T[name]?.tax > 0 ? T[name].tax : 1;
}

function movableCount(name, color) {
    if (G.board[name]?.owner !== color) return 0;
    return Math.max(0, totalUnitCount(name) - leaveBehindCount(name));
}

function movableCountPlayer(name) {
    return Math.max(0, totalUnitCount(name) - leaveBehindPlayer(name));
}

// Which units to MOVE (best quality first; keep siege if need it for castle attack)
function unitsToMove(name, count, needsSiege) {
    const u = {...G.board[name].units};
    const mv = {F:0,A:0,C:0,S:0};
    let rem = count;
    if (needsSiege && u.S > 0) { mv.S = 1; u.S--; rem--; }
    const take = (k) => { const n=Math.min(u[k],rem); mv[k]+=n; u[k]-=n; rem-=n; };
    take('C'); take('A'); take('F'); take('S');
    return mv;
}

// Units to LEAVE (worst first: F, A, S, C)
function unitsToLeave(name, count) {
    const u = {...G.board[name].units};
    const lv = {F:0,A:0,C:0,S:0};
    let rem = count;
    const keep = (k) => { const n=Math.min(u[k],rem); lv[k]+=n; rem-=n; };
    keep('F'); keep('A'); keep('S'); keep('C');
    return lv;
}

function canAttack(arriving, defending) {
    if (arriving >= 21) return true;
    if (arriving >= 16) return defending <= arriving + 5;
    if (arriving >= 11) return defending <= arriving + 4;
    if (arriving >= 6)  return defending <= arriving + 3;
    return arriving >= defending;
}

function ownedBy(color) {
    return Object.keys(G.board).filter(n => G.board[n].owner === color && T[n]);
}

// Flood-fill from city through OWN territories to calculate tax yield
function taxYield(color, cityName) {
    if (!T[cityName] || T[cityName].tax === 0) return 0;
    if (!G.board[cityName]) return 0;
    if (G.board[cityName]?.owner !== color) return 0;
    let yield_ = T[cityName].tax;
    const visited = new Set([cityName]);
    const queue = [cityName];
    while (queue.length) {
        const cur = queue.shift();
        for (const adj of T[cur].adj) {
            if (!visited.has(adj) && G.board[adj]?.owner === color) {
                visited.add(adj); queue.push(adj);
                yield_ += T[adj].tax > 0 ? T[adj].tax : 1;
            }
        }
    }
    return yield_;
}

// ================================================================
// DECISION ENGINE
// ================================================================

function decideTax(color) {
    const cities = ownedBy(color).filter(n => T[n].tax > 0);
    if (!cities.length) return null;
    const scored = cities.map(c => ({ city:c, yield:taxYield(color,c), hasTaxBonus: false }));
    scored.sort((a,b) => b.yield - a.yield);
    return scored[0];
}

function decideSpendPlacements(color, purchase) {
    // Returns array of {territory, units} placement instructions
    const owned = ownedBy(color).filter(n => T[n].tax > 0)
        .sort((a,b) => T[b].tax - T[a].tax || totalUnitCount(a) - totalUnitCount(b));
    
    const placements = [];
    const unitsToPlace = { C: purchase.C||0, A: purchase.A||0, F: purchase.F||0 };
    
    // Castle placement
    if (purchase.castle) {
        const castleDest = ownedBy(color).filter(n => T[n].tax > 0 && !G.board[n].castle)
            .sort((a,b) => T[b].tax - T[a].tax || totalUnitCount(a) - totalUnitCount(b))[0];
        if (castleDest) placements.push({ territory: castleDest, type:'castle', detail:'Place Castle here' });
    }
    
    // Unit placement â€” 1 at a time, best quality first to highest-tax city
    let cityIdx = 0;
    const unitOrder = [
        ...Array(unitsToPlace.C).fill('C'),
        ...Array(unitsToPlace.A).fill('A'),
        ...Array(unitsToPlace.F).fill('F'),
    ];
    unitOrder.forEach(type => {
        const city = owned[cityIdx % owned.length];
        if (!city) return;
        // Only merge if same city AND same unit type
        const existing = placements.find(p => p.territory === city && p.type === 'units' && p.unitType === type);
        if (existing) existing.count++;
        else placements.push({ territory: city, type:'units', unitType: type, count: 1 });
        cityIdx++;
    });
    
    // Siege Engine
    if (purchase.S) {
        // Find own territory closest to enemy castle
        const enemyCastles = Object.keys(G.board).filter(n => G.board[n].castle && G.board[n].owner !== color && G.board[n].owner !== 'neutral');
        let bestSiegeDest = null, bestDist = 999;
        for (const ec of enemyCastles) {
            for (const t of ownedBy(color)) {
                if (T[t].adj.includes(ec) || t === ec) { // adjacent
                    const d = 1;
                    if (d < bestDist || (d === bestDist && T[t].tax > (T[bestSiegeDest]?.tax||0))) {
                        bestDist = d; bestSiegeDest = t;
                    }
                }
            }
        }
        if (!bestSiegeDest) bestSiegeDest = owned[0] || ownedBy(color)[0];
        if (bestSiegeDest) placements.push({ territory: bestSiegeDest, type:'siege', detail:'Place Siege Engine here' });
    }
    return placements;
}

function decideExpand(color) {
    const candidates = [];
    for (const t of ownedBy(color)) {
        const movable = movableCount(t, color);
        if (movable <= 0) continue;
        for (const adj of (T[t]?.adj || [])) {
            if (!T[adj] || T[adj].tax === 0) continue; // not a city
            const adjB = G.board[adj];
            if (adjB.owner === color) continue;
            const defenders = totalUnitCount(adj);
            const isEnemy = adjB.owner !== 'neutral';
            const hasCastle = adjB.castle;
            const hasSiege = G.board[t].units.S > 0;
            if (hasCastle && !hasSiege) continue; // need siege engine
            if (isEnemy && !canAttack(movable, defenders)) continue;
            candidates.push({ from:t, to:adj, movable, defenders, isEnemy,
                tax:T[adj].tax, hasCastle });
        }
    }
    if (!candidates.length) return null;
    candidates.sort((a,b) => b.tax-a.tax || b.movable-a.movable || a.defenders-b.defenders);
    return candidates[0];
}

function decideSplitExpand(color) {
    const candidates = [];
    for (const t of ownedBy(color)) {
        const movable = movableCount(t, color);
        if (movable <= 0) continue;
        // 1-step cities
        for (const adj of T[t].adj) {
            if (!T[adj] || T[adj].tax === 0) continue;
            const adjB = G.board[adj];
            if (adjB.owner === color) continue;
            const defenders = totalUnitCount(adj);
            const isEnemy = adjB.owner !== 'neutral';
            const hasCastle = adjB.castle;
            const hasSiege = G.board[t].units.S > 0;
            if (hasCastle && !hasSiege) continue;
            if (isEnemy && !canAttack(movable, defenders)) continue;
            candidates.push({ from:t, via:null, to:adj, movable, defenders, isEnemy, tax:T[adj].tax, hasCastle });
        }
        // 2-step cities â€” can only pass through own territories (not neutral, not enemy)
        for (const mid of T[t].adj) {
            const midB = G.board[mid];
            // Must pass through own territory (Risk Europe rule: supply line movement only)
            if (midB.owner !== color) continue;
            for (const dest of T[mid].adj) {
                if (dest === t) continue;
                if (!T[dest] || T[dest].tax === 0) continue;
                const destB = G.board[dest];
                if (destB.owner === color) continue;
                const defenders = totalUnitCount(dest);
                const isEnemy = destB.owner !== 'neutral';
                const hasCastle = destB.castle;
                const hasSiege = G.board[t].units.S > 0;
                if (hasCastle && !hasSiege) continue;
                if (isEnemy && !canAttack(movable, defenders)) continue;
                candidates.push({ from:t, via:mid, to:dest, movable, defenders, isEnemy, tax:T[dest].tax, hasCastle });
            }
        }
    }
    if (!candidates.length) return null;
    // Priority: highest tax â†’ 1-step preferred over 2-step â†’ fewest defenders â†’ most units arriving
    candidates.sort((a,b) =>
        (b.tax - a.tax) ||
        ((a.via ? 1 : 0) - (b.via ? 1 : 0)) ||   // null via = 1-step = better
        (a.defenders - b.defenders) ||              // fewest defenders
        (b.movable - a.movable)                     // most units
    );
    return candidates[0];
}

function decidePosition(color) {
    // Move LARGEST possible army one step so it ends up ADJACENT to a non-owned city.
    // "Position" never moves INTO a city â€” that is always EXPAND.
    // The destination must be own or neutral (enemy territories require combat).
    // Primary sort: most movable units. Tiebreaker: highest-tax target city.
    const candidates = [];
    for (const t of ownedBy(color)) {
        const movable = movableCount(t, color);
        if (movable <= 0) continue;
        for (const adj of (T[t]?.adj || [])) {
            // Skip cities entirely â€” moving into a city is EXPAND, not POSITION
            if (T[adj]?.tax > 0) continue;
            // Skip enemy territories â€” moving there requires combat
            const adjOwner = G.board[adj]?.owner;
            if (adjOwner && adjOwner !== color && adjOwner !== 'neutral') continue;
            // adj is a valid destination (own non-city, or neutral non-city)
            // Add a candidate for each non-owned city adjacent to adj
            for (const city of (T[adj]?.adj || [])) {
                if (!T[city] || T[city].tax === 0) continue;
                if (G.board[city]?.owner === color) continue; // already own it
                candidates.push({ from:t, to:adj, toward:city, targetTax:T[city].tax, movable });
            }
        }
    }
    if (!candidates.length) return null;
    // Sort: largest army first, highest-tax target city second
    // Deduplicate by (from,to) â€” pick the best target city for each fromâ†’to pair
    candidates.sort((a,b) => b.movable - a.movable || b.targetTax - a.targetTax);
    const seen = new Set();
    for (const c of candidates) {
        const key = c.from + '|' + c.to;
        if (!seen.has(key)) { seen.add(key); return c; }
    }
    return candidates[0];
}

function decideFortify(color) {
    const opts = ownedBy(color).filter(n => T[n].tax > 0 || G.board[n].castle);
    if (!opts.length) return null;
    // Capitals = starting cities (any city in CAPITALS list)
    const capitalNames = new Set(CAPITALS.map(c => c.name));
    opts.sort((a,b) => {
        const ta = totalUnitCount(a), tb = totalUnitCount(b);
        if (ta !== tb) return ta - tb;                        // fewest units first
        const taxA = T[a].tax||0, taxB = T[b].tax||0;
        if (taxA !== taxB) return taxB - taxA;               // highest tax first
        const capA = capitalNames.has(a) ? 1 : 0;
        const capB = capitalNames.has(b) ? 1 : 0;
        if (capA !== capB) return capB - capA;               // capital beats regular city
        return 0;                                             // random (caller rolls die)
    });
    const t = opts[0];
    const addCount = G.board[t].castle ? 4 : 3;
    return { territory:t, count:addCount, hasCastle: G.board[t].castle };
}

function decideSiege(color) {
    // Must have at least 1 siege engine
    const withSiege = ownedBy(color).filter(n => G.board[n].units.S > 0);
    if (!withSiege.length) return null;
    let candidates = [];
    for (const t of withSiege) {
        for (const adj of T[t].adj) {
            if (G.board[adj]?.owner && G.board[adj].owner !== color && G.board[adj].owner !== 'neutral') {
                candidates.push({ from:t, to:adj, defenders: totalUnitCount(adj), defOwner: G.board[adj].owner });
            }
        }
    }
    if (!candidates.length) return null;
    // Sort by most defenders, then by color with most total units
    const totals = {};
    ['orange','green','purple','blue'].forEach(c => {
        totals[c] = ownedBy(c).reduce((s,n)=>s+totalUnitCount(n),0);
    });
    candidates.sort((a,b) => b.defenders-a.defenders || totals[b.defOwner]-totals[a.defOwner]);
    return candidates[0];
}

// Build all valid MANEUVER moves for a color.
// Rules: move from one OWN territory to another OWN or DISPUTED territory,
// up to 2 steps away, travelling only through OWN territories.
// Cannot move out of a disputed territory. Stop immediately upon entering disputed.
// "Disputed" = a pending battle queued in G.roundCombats for that territory.
function getManeuverMoves(color) {
    const owned = ownedBy(color);
    const isDisputed = (name) => (G.roundCombats||[]).some(b => b.to === name && !b._resolved);

    const moves = []; // { from, to, hops, movable }

    for (const from of owned) {
        // Cannot maneuver OUT of a disputed territory
        if (isDisputed(from)) continue;
        const movable = movableCount(from, color);
        if (movable <= 0) continue;

        // BFS up to 2 hops through own territories only
        // Each node: { name, hops }
        const visited = new Set([from]);
        const queue = [{ name: from, hops: 0 }];

        while (queue.length) {
            const { name: cur, hops } = queue.shift();
            if (hops >= 2) continue; // can't go further

            for (const adj of (T[cur]?.adj || [])) {
                if (visited.has(adj)) continue;
                const adjOwner = G.board[adj]?.owner;
                // Can only travel through own territories (or land in disputed)
                if (adjOwner !== color) {
                    // Can we land here? Only if it's own or disputed own territory
                    // (neutral/enemy are not valid maneuver destinations)
                    continue;
                }
                visited.add(adj);
                const dest = adj;
                const destHops = hops + 1;
                if (dest !== from) {
                    moves.push({ from, to: dest, hops: destHops, movable });
                    // If disputed, stop here (can't pass through)
                    if (!isDisputed(dest)) {
                        queue.push({ name: dest, hops: destHops });
                    }
                }
            }
        }
    }
    return moves;
}

function decideManeuver(color) {
    const moves = getManeuverMoves(color);
    if (!moves.length) return null;

    // Priority 1: reinforce a threatened territory
    // Rule: "choisissez son terrain qui peut apporter le plus de renfort"
    // â€” pick the source that brings the MOST units to the best threatened destination.
    // Threatened territory priority: 1. highest tax  2. most reinforcement available  3. most attackers
    const isDisputed = (name) => (G.roundCombats||[]).some(b => b.to === name && !b._resolved);
    const threatenedTerrs = new Set();
    for (const t of ownedBy(color)) {
        for (const adj of T[t].adj) {
            const b = G.board[adj];
            if (b?.owner && b.owner !== color && b.owner !== 'neutral') {
                threatenedTerrs.add(t);
            }
        }
    }
    if (threatenedTerrs.size > 0) {
        // Sort threatened territories by priority: tax â†’ most reinforcement reachable â†’ most attackers nearby
        const threatenedList = [...threatenedTerrs].map(terr => {
            const movesToHere = moves.filter(m => m.to === terr);
            const maxReinforcement = movesToHere.reduce((mx, m) => Math.max(mx, m.movable), 0);
            const attackerCount = T[terr].adj.reduce((sum, adj) => {
                const b = G.board[adj];
                return (b?.owner && b.owner !== color && b.owner !== 'neutral')
                    ? sum + totalUnitCount(adj) : sum;
            }, 0);
            return { terr, tax: T[terr].tax||0, maxReinforcement, attackerCount, movesToHere };
        }).filter(t => t.movesToHere.length > 0); // only if reachable
        if (threatenedList.length > 0) {
            threatenedList.sort((a,b) =>
                b.tax - a.tax ||                          // highest tax first
                b.maxReinforcement - a.maxReinforcement || // most reinforcement available
                b.attackerCount - a.attackerCount          // most attackers (most urgent)
            );
            const best = threatenedList[0];
            // Among moves to this territory, pick the one that delivers the most units
            best.movesToHere.sort((a,b) => b.movable - a.movable);
            const m = best.movesToHere[0];
            return { from:m.from, to:m.to, movable:m.movable,
                reason:`Reinforce threatened ${m.to} (Tax ${T[m.to].tax||0}, ${best.attackerCount} attackers nearby)${m.hops===2?' â€” 2-step':''}` };
        }
    }

    // Priority 2: reinforce territory adjacent to highest-tax enemy city
    const enemyCities = ALL_CITIES
        .filter(c => G.board[c]?.owner && G.board[c].owner !== color && G.board[c].owner !== 'neutral')
        .sort((a,b) => T[b].tax - T[a].tax);

    for (const city of enemyCities) {
        // Moves that land adjacent to this city
        const frontlineMoves = moves.filter(m => T[city].adj.includes(m.to));
        if (!frontlineMoves.length) continue;
        frontlineMoves.sort((a,b) => b.movable - a.movable);
        const m = frontlineMoves[0];
        return { from:m.from, to:m.to, movable:m.movable,
            reason:`Reinforce near ${city} (Tax ${T[city].tax})${m.hops===2?' â€” 2-step maneuver':''}` };
    }

    // Priority 3: any legal maneuver (largest army to most useful position)
    moves.sort((a,b) => b.movable - a.movable);
    const m = moves[0];
    return { from:m.from, to:m.to, movable:m.movable,
        reason:`Reposition army${m.hops===2?' â€” 2-step maneuver':''}` };
}

// ================================================================
// BOARD UPDATES (called when turn is completed)
// ================================================================
function applyFortify(territory, count) {
    if (!G.board[territory]) return;
    G.board[territory].units.F += count;
    addLog(`Board: +${count} Footmen placed at ${territory}.`);
}

function applySpend(color, purchase, placements) {
    G.coins[color] = Math.max(0, G.coins[color] - purchase.cost);
    if (purchase.crownCard) {
        // Buying a Crown Card: track it separately, add 1 crown
        G.crownCards[color] = (G.crownCards[color]||0) + 1;
        addCrown(color, 1);
    }
    placements.forEach(p => {
        if (!G.board[p.territory]) return;
        if (p.type === 'castle') {
            G.board[p.territory].castle = true;
        } else if (p.type === 'siege') {
            G.board[p.territory].units.S++;
        } else if (p.type === 'units') {
            G.board[p.territory].units[p.unitType] = (G.board[p.territory].units[p.unitType]||0) + p.count;
        }
    });
}


function applyNonCombatMove(mv) {
    if (!mv || !G.board[mv.from] || !G.board[mv.to]) return;
    const mu = mv.movingUnits || {};
    const destOwner = G.board[mv.to].owner;
    const destUnits = unitTotal(G.board[mv.to].units);
    // Safety: if destination has enemy units, don't merge â€” this should have been queued as combat
    if (destOwner !== mv.color && destOwner !== 'neutral' && destUnits > 0) {
        addLog(`âš  ${mv.color} tried to move into enemy ${mv.to} (${destOwner}) without combat â€” skipped. Check combat phase.`);
        return;
    }
    ['F','A','C','S'].forEach(k => {
        G.board[mv.from].units[k] = Math.max(0, (G.board[mv.from].units[k]||0) - (mu[k]||0));
    });
    G.board[mv.to].owner = mv.color;
    ['F','A','C','S'].forEach(k => {
        G.board[mv.to].units[k] = (G.board[mv.to].units[k]||0) + (mu[k]||0);
    });
    addLog(`Board: ${mv.color} moves ${unitStr(mu)} from ${mv.from} to ${mv.to}.`);
}
function applyMove(from, to, movingUnits, attackerWon, survivorCount, survivingColor) {
    if (!G.board[from] || !G.board[to]) return;
    // Subtract moving units from origin
    ['F','A','C','S'].forEach(k => {
        G.board[from].units[k] = Math.max(0, G.board[from].units[k] - (movingUnits[k]||0));
    });
    if (!attackerWon) {
        // Defender held â€” attacker units destroyed
        addLog(`Board: ${from} â†’ ${to} â€” Defender held. Attacker lost.`);
        return;
    }
    // Attacker won â€” take territory
    G.board[to].owner = survivingColor;
    G.board[to].units = {F:0,A:0,C:0,S:0};
    // Place survivors (we don't know breakdown, so put them as footmen for now)
    G.board[to].units.F = survivorCount;
    addLog(`Board: ${survivingColor} captures ${to} with ${survivorCount} units.`);
}


function getBestSpend(coins, color) {
    // Berlin shield: castles cost 3 fewer coins â€” simulate by adding 3 to purchasing power
    // so the automa can access castle purchases it otherwise couldn't afford
    const berlinBonus = (color && G.shields?.['Berlin'] === color && color !== S.playerColor) ? 3 : 0;
    const effectiveCoins = coins + berlinBonus;
    const keys = Object.keys(SPEND_TABLE).map(Number).sort((a,b)=>b-a);
    const k = keys.find(k => k <= effectiveCoins);
    const result = k ? { cost:k, items:SPEND_TABLE[k] } : { cost:5, items:SPEND_TABLE[5] };
    // Adjust actual cost if a castle was in the purchase and Berlin discount applies
    if (berlinBonus > 0 && result.items.includes('Castle')) {
        result.cost = Math.max(result.cost - 3, 0);
        result._berlinDiscount = true;
    }
    return result;
}

// ================================================================
// SETUP STATE
// ================================================================
const S = {
    step:0, playerColor:null, firstAuto:null,
    autoCapitals:{}, playerCapital:null,
    autoSecondary:{}, playerSecondary:null,
    takenAdj:new Set(), shuffledCaps:[], coinsData:[]
};

function autoColors() { return ['orange','green','purple','blue'].filter(c=>c!==S.playerColor); }

// ================================================================
// SETUP WIZARD
// ================================================================
const TOTAL_STEPS = 7;

function showStep(n) {
    S.step = n;
    document.getElementById('wiz-step-label').textContent = `Step ${n+1} of ${TOTAL_STEPS}`;
    document.getElementById('wiz-progress').style.width = `${Math.round(((n+1)/TOTAL_STEPS)*100)}%`;
    const b = document.getElementById('wiz-body');
    [renderWelcome, renderChooseColor, renderAssignCapitals, renderPlaceAutos,
     renderPlayerCapital, renderSecondary, renderReady][n](b);
}

function wizNext() { showStep(S.step+1); }
function wizBack() { if(S.step>0) showStep(S.step-1); }

function renderWelcome(el) {
    el.innerHTML = `
        <div class="setup-title">Welcome, Commander</div>
        <div class="setup-sub">This app runs the <b>3 Automaton players</b> so you can play Risk Europe solo. It draws their cards and tells you exactly what to do on the board each turn.</div>
        <div class="info-box"><b>How it works:</b><br>
        â€¢ You play your own turns normally using the base game rules you already know.<br>
        â€¢ For each automaton turn, this app reveals their card and shows a <b>numbered checklist</b> of exactly what to move.<br>
        â€¢ Tap each step as you carry it out on the board. When all steps are done, tap <b>Complete Turn</b>.<br>
        â€¢ The app handles turn order, coin tracking, and deck reshuffling automatically.</div>
        <div class="info-box"><b>You win</b> by reaching 7 Crown tokens first â€” same as the base game. Crown counts are tracked in the player bar.</div>
        <div class="info-box" style="border-color:var(--gold);background:rgba(200,149,42,0.08);">
            <b>âš  Before you begin:</b><br>
            â€¢ <b>Kingdom Missions variant is NOT used.</b> Crown Cards stay in the deck face-down â€” when purchased they give 1 Crown exactly as printed. Do NOT use the mission side.<br>
            â€¢ All players start with <b>2 Crown tokens</b> (Rome starter gets 3 due to shield).
        </div>
        <button class="btn-primary" onclick="wizNext()">BEGIN SETUP â†’</button>`;
}

function renderChooseColor(el) {
    el.innerHTML = `
        <div class="setup-title">Choose Your Colour</div>
        <div class="setup-sub">Pick the colour you'll play. The other three become automatons.</div>
        <div class="color-grid">
            ${['orange','green','purple','blue'].map(c=>`
                <div class="color-choice ${S.playerColor===c?'selected':''}"
                     style="background:${COLOR_HEX[c]}" onclick="selectColor('${c}')">
                    ${c.toUpperCase()}
                </div>`).join('')}
        </div>
        <div id="col-confirm" style="${S.playerColor?'':'display:none'}">
            <div class="info-box">You are <b>${(S.playerColor||'').toUpperCase()}</b>. Automatons: <b>${autoColors().map(c=>c.toUpperCase()).join(', ')}</b>. You go <b>last</b> in Round 1.</div>
            <button class="btn-primary" onclick="wizNext()">CONFIRM â†’</button>
        </div>
        <button class="btn-secondary" onclick="wizBack()">â† Back</button>`;
}

function selectColor(c) {
    S.playerColor = c;
    renderChooseColor(document.getElementById('wiz-body'));
}

function resolveAdj(capital) {
    for (const adj of capital.adjOptions) {
        if (!S.takenAdj.has(adj.name)) { S.takenAdj.add(adj.name); capital._adj = adj; return; }
    }
    capital._adj = capital.adjOptions[capital.adjOptions.length-1];
}

function renderCapCard(color, capital, isPrimary) {
    const adj = capital._adj || capital.adjOptions[0];
    const adjNote = capital.adjOptions.length > 1
        ? `<div class="cap-note">If ${adj.name} is taken: try ${capital.adjOptions.map(a=>a.name).join(' â†’ ')} in order.</div>` : '';
    const extra = isPrimary
        ? `<br>ðŸ° <b>1 Castle</b> on ${capital.name}<br>ðŸ‘‘ <b>2 Crown tokens</b> on ${capital.name}`
        : `<br><span style="color:#888;font-style:italic;">No castle on secondary capital.</span>`;
    return `<div class="capital-card">
        <div class="cap-header"><div class="cap-dot" style="background:${COLOR_HEX[color]}"></div>
        <div class="cap-name">${color.toUpperCase()} â€” ${capital.name}</div></div>
        <div class="cap-body">
            ðŸ“ <b>${capital.name}:</b> place <b>${capital.units} Footmen</b><br>
            ðŸ“ <b>${adj.name}:</b> place <b>${adj.units} Footmen</b>
            ${adjNote}${extra}
        </div></div>`;
}

function renderAssignCapitals(el) {
    const autos = autoColors();
    if (!S.shuffledCaps.length) S.shuffledCaps = shuffle([...CAPITALS]);
    S.takenAdj = new Set();
    autos.forEach((color, i) => {
        S.autoCapitals[color] = S.shuffledCaps[i];
        resolveAdj(S.shuffledCaps[i]);
    });
    el.innerHTML = `
        <div class="setup-title">Automaton Capitals</div>
        <div class="setup-sub">Capitals have been randomly assigned. Place each automaton's starting forces on the board now.</div>
        ${autos.map(c => renderCapCard(c, S.autoCapitals[c], true)).join('')}
        <div class="info-box">Each automaton also receives <b>5 starting coins</b> (plus tax income â€” we'll calculate the total in a later step).</div>
        <button class="btn-primary" onclick="wizNext()">UNITS PLACED ON BOARD â†’</button>
        <button class="btn-secondary" onclick="reshuffleCapitals()">ðŸ”€ Re-Randomise Capitals</button>
        <button class="btn-secondary" onclick="wizBack()">â† Back</button>`;
}

function reshuffleCapitals() {
    S.shuffledCaps = shuffle([...CAPITALS]);
    renderAssignCapitals(document.getElementById('wiz-body'));
}

function renderPlaceAutos(el) {
    const autos = autoColors();
    el.innerHTML = `
        <div class="setup-title">Who Goes First?</div>
        <div class="setup-sub">In Round 1 you go last. Which automaton is sitting to your <b>left</b>? They take the First Player marker and go first.</div>
        <div class="cap-chooser" id="first-picker">
            ${autos.map(c=>`<div class="cap-btn ${S.firstAuto===c?'selected':''}" onclick="pickFirst('${c}')">
                ${c.toUpperCase()}<div class="cap-tax">to your left</div></div>`).join('')}
        </div>
        <div id="first-confirm" style="${S.firstAuto?'':'display:none'}">
            <div class="info-box"><b>${(S.firstAuto||'').toUpperCase()}</b> holds the First Player marker and goes first each round (until a KING ME card transfers it).</div>
            <button class="btn-primary" onclick="wizNext()">CONTINUE â†’</button>
        </div>
        <button class="btn-secondary" onclick="wizBack()">â† Back</button>`;
}

function pickFirst(c) {
    S.firstAuto = c;
    renderPlaceAutos(document.getElementById('wiz-body'));
}

function renderPlayerCapital(el) {
    const taken = new Set(autoColors().map(c=>S.autoCapitals[c].name));
    const available = CAPITALS.filter(c=>!taken.has(c.name));
    el.innerHTML = `
        <div class="setup-title">Your Capital</div>
        <div class="setup-sub">Choose one of the remaining capitals for <b>${(S.playerColor||'').toUpperCase()}</b>. Place your units, Castle, and 2 Crowns.</div>
        <div class="cap-chooser">
            ${available.map(cap=>`<div class="cap-btn ${S.playerCapital&&S.playerCapital.name===cap.name?'selected':''}" onclick="pickPlayerCap('${cap.name}')">
                ${cap.name}<div class="cap-tax">Tax: ${cap.tax}</div></div>`).join('')}
        </div>
        <div id="player-cap-detail">${S.playerCapital ? renderPlayerCapDetail() : ''}</div>
        <button class="btn-secondary" onclick="wizBack()">â† Back</button>`;
}

function renderPlayerCapDetail() {
    const cap = S.playerCapital; if (!cap) return '';
    const adj = cap._adj || cap.adjOptions[0];
    const primary = S.playerPrimaryUnits !== undefined ? S.playerPrimaryUnits : 3;
    const adjUnits = Math.max(0, 5 - primary);
    return `<div class="capital-card">
        <div class="cap-header"><div class="cap-dot" style="background:${COLOR_HEX[S.playerColor]}"></div>
        <div class="cap-name">${(S.playerColor||'').toUpperCase()} â€” ${cap.name}</div></div>
        <div class="cap-body">
            ðŸ° <b>1 Castle</b> on ${cap.name} &nbsp; ðŸ‘‘ <b>2 Crown tokens</b><br><br>
            <b>How many Footmen at ${cap.name}?</b><br>
            <div style="display:flex;align-items:center;gap:10px;margin:8px 0;">
                <button class="ub" style="width:28px;height:28px;font-size:16px" onclick="changePlayerUnits(-1)">âˆ’</button>
                <span style="font-family:Cinzel,serif;font-size:1.4em;font-weight:700;min-width:30px;text-align:center">${primary}</span>
                <button class="ub" style="width:28px;height:28px;font-size:16px" onclick="changePlayerUnits(1)">+</button>
                <span style="color:var(--ink-light);font-size:0.9em;">at ${cap.name}</span>
            </div>
            <div style="color:var(--ink-light);font-size:0.88em;">Remaining <b>${adjUnits}</b> Footmen â†’ ${adj.name}</div>
            <span class="cap-note">Total = 5 Footmen across both territories.</span>
        </div></div>
        <button class="btn-primary" onclick="wizNext()">UNITS PLACED â†’</button>`;
}
function changePlayerUnits(v) {
    S.playerPrimaryUnits = Math.max(0, Math.min(5, (S.playerPrimaryUnits||3) + v));
    renderPlayerCapital(document.getElementById('wiz-body'));
}

function pickPlayerCap(name) {
    S.playerCapital = CAPITALS.find(c=>c.name===name);
    resolveAdj(S.playerCapital);
    renderPlayerCapital(document.getElementById('wiz-body'));
}

function renderSecondary(el) {
    const autos = autoColors();
    const fi = S.firstAuto || autos[0];
    const orderedAutos = [fi, ...autos.filter(c=>c!==fi)];
    const takenNames = new Set([...autos.map(c=>S.autoCapitals[c].name), S.playerCapital?.name].filter(Boolean));
    const remaining = CAPITALS.filter(c=>!takenNames.has(c.name));
    const assignOrder = [...orderedAutos, S.playerColor];
    S.autoSecondary = {}; S.playerSecondary = null;
    assignOrder.forEach((color, i) => {
        const cap = remaining[i];
        if (!cap) return;
        if (color === S.playerColor) S.playerSecondary = cap;
        else S.autoSecondary[color] = cap;
    });
    const coinsData = [...autos, S.playerColor].map(color => {
        const primary   = color === S.playerColor ? S.playerCapital     : S.autoCapitals[color];
        const secondary = color === S.playerColor ? S.playerSecondary   : S.autoSecondary[color];
        return { color, primary, secondary, total: 5+(primary?.tax||0)+(secondary?.tax||0) };
    });
    S.coinsData = coinsData;
    el.innerHTML = `
        <div class="setup-title">Secondary Capitals & Starting Coins</div>
        <div class="setup-sub">The remaining ${remaining.length} capitals are now distributed â€” same unit placement, but <b>no castle</b>. Each player's coin total is shown below.</div>
        ${coinsData.map(d=>`<div class="capital-card">
            <div class="cap-header"><div class="cap-dot" style="background:${COLOR_HEX[d.color]}"></div>
            <div class="cap-name">${d.color.toUpperCase()}</div></div>
            <div class="cap-body">
                ðŸ› <b>Primary:</b> ${d.primary?.name||'?'} (Tax ${d.primary?.tax||'?'})<br>
                ðŸ› <b>Secondary:</b> ${d.secondary?.name||'?'} (Tax ${d.secondary?.tax||'?'}) <i>â€” no castle</i><br>
                ðŸ’° <b>Starting coins: 5 + ${d.primary?.tax||0} + ${d.secondary?.tax||0} = <span style="color:var(--accent);font-size:1.1em;">${d.total}</span></b>
            </div></div>`).join('')}
        <div class="info-box">Place the secondary capital units on the board (same counts as shown in Step 3), set each player's coin count, and give each player their 10 Footmen, 4 Archers, 4 Cavalry, 2 Siege Engines for reserves.</div>
        <button class="btn-primary" onclick="launchGame()">âœ“ SETUP COMPLETE â€” START GAME â†’</button>
        <button class="btn-secondary" onclick="wizBack()">â† Back</button>`;
}

function renderReady(el) { launchGame(); }

// ================================================================
// GAME STATE & INIT
// ================================================================

// â”€â”€ Gold City Shield Abilities â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// These are the special abilities granted by Tax-4 cities' shields
// City Shield abilities â€” each starting city has a shield token with a special ability.
// trigger: 'tax'|'spend'|'battle_win'|'expand'|'always'|'expand_spend'
// crownBonus: extra crowns when captured (Rome only)
const CITY_SHIELDS = {
    "Paris":          { trigger:'tax',          crownBonus:0, reminder:"ðŸ›¡ PARIS SHIELD: You taxed Paris â€” place 1 Cavalry + 1 Footman in Paris for FREE." },
    "Stockholm":      { trigger:'battle_win',   crownBonus:0, reminder:"ðŸ›¡ STOCKHOLM SHIELD: You won as attacker â€” collect 4 silver coins from the reserve." },
    "Rome":           { trigger:'always',       crownBonus:1, reminder:"ðŸ›¡ ROME SHIELD: Rome is worth 2 crowns (already applied)." },
    "Berlin":         { trigger:'expand_spend', crownBonus:0, reminder:"ðŸ›¡ BERLIN SHIELD: After Expanding, you may also Maneuver this action. Also: Castles cost 3 fewer coins." },
    "Constantinople": { trigger:'spend',        crownBonus:0, reminder:"ðŸ›¡ CONSTANTINOPLE SHIELD: You recruited a Siege Engine â€” place 4 Footmen with it for FREE." },
    "Kiev":           { trigger:'spend',        crownBonus:0, reminder:"ðŸ›¡ KIEV SHIELD: You may recruit army units into any non-city territory connected to Kiev by a supply line." },
    "Madrid":         { trigger:'tax',          crownBonus:0, reminder:"ðŸ›¡ MADRID SHIELD: You taxed Madrid â€” place 4 Footmen in Madrid for FREE." },
    "London":         { trigger:'tax',          crownBonus:0, reminder:"ðŸ›¡ LONDON SHIELD: You taxed London â€” place 2 Archers in London for FREE." },
};

function showShieldReminder(city, color) {
    const sh = CITY_SHIELDS[city];
    if (!sh || !sh.reminder) return;
    if (!G.shields || G.shields[city] !== color) return;
    if (color === S.playerColor) {
        addLog(sh.reminder);
        const toast = document.createElement('div');
        toast.style.cssText = 'position:fixed;bottom:80px;left:50%;transform:translateX(-50%);background:#8b1a1a;color:white;padding:12px 18px;border-radius:8px;font-family:Cinzel,serif;font-size:0.82em;font-weight:700;z-index:500;max-width:340px;text-align:center;box-shadow:0 4px 20px rgba(0,0,0,0.6);';
        toast.textContent = sh.reminder;
        document.body.appendChild(toast);
        setTimeout(()=>toast.remove(), 6000);
    }
    // Automa: no reminder needed â€” effect applied automatically by applyShieldBonus
}

// Apply city shield bonus automatically for an automa (no-op for human â€” they get a reminder instead)
function applyShieldBonus(city, color, context) {
    if (!G.shields || G.shields[city] !== color) return;
    if (color === S.playerColor) return; // human handles manually via reminder
    const sh = CITY_SHIELDS[city];
    if (!sh) return;

    if (city === 'Paris' && context === 'tax') {
        // Free 1 Cavalry + 1 Footman in Paris
        G.board['Paris'].units.C = (G.board['Paris'].units.C||0) + 1;
        G.board['Paris'].units.F = (G.board['Paris'].units.F||0) + 1;
        addLog(`ðŸ›¡ Paris shield: ${cName(color)} receives 1 free Cavalry + 1 Footman in Paris.`);
    } else if (city === 'Madrid' && context === 'tax') {
        // Free 4 Footmen in Madrid
        G.board['Madrid'].units.F = (G.board['Madrid'].units.F||0) + 4;
        addLog(`ðŸ›¡ Madrid shield: ${cName(color)} receives 4 free Footmen in Madrid.`);
    } else if (city === 'London' && context === 'tax') {
        // Free 2 Archers in London
        G.board['London'].units.A = (G.board['London'].units.A||0) + 2;
        addLog(`ðŸ›¡ London shield: ${cName(color)} receives 2 free Archers in London.`);
    } else if (city === 'Constantinople' && context === 'siege_buy') {
        // Free 4 Footmen placed with the siege engine
        // Find the territory where the siege engine was just placed
        const siegeTerr = ownedBy(color).filter(n => G.board[n].units.S > 0)
            .sort((a,b) => G.board[b].units.S - G.board[a].units.S)[0];
        if (siegeTerr) {
            G.board[siegeTerr].units.F = (G.board[siegeTerr].units.F||0) + 4;
            addLog(`ðŸ›¡ Constantinople shield: ${cName(color)} receives 4 free Footmen at ${siegeTerr}.`);
        }
    } else if (city === 'Kiev' && context === 'spend') {
        // May recruit into non-city territory connected via supply line
        // For automa: place 2 extra Footmen in the highest-unit non-city territory connected to Kiev
        const kievOwner = G.board['Kiev']?.owner;
        if (kievOwner !== color) return;
        const visited = new Set(['Kiev']);
        const queue = ['Kiev'];
        let bestNonCity = null, bestCount = -1;
        while (queue.length) {
            const cur = queue.shift();
            for (const adj of (T[cur]?.adj || [])) {
                if (!visited.has(adj) && G.board[adj]?.owner === color) {
                    visited.add(adj); queue.push(adj);
                    if (T[adj].tax === 0) {
                        const cnt = totalUnitCount(adj);
                        if (cnt > bestCount) { bestCount = cnt; bestNonCity = adj; }
                    }
                }
            }
        }
        if (bestNonCity) {
            G.board[bestNonCity].units.F = (G.board[bestNonCity].units.F||0) + 2;
            addLog(`ðŸ›¡ Kiev shield: ${cName(color)} places 2 extra Footmen at ${bestNonCity} (supply line).`);
        }
    } else if (city === 'Stockholm' && context === 'battle_win') {
        // 4 free coins
        G.coins[color] = (G.coins[color]||0) + 4;
        addLog(`ðŸ›¡ Stockholm shield: ${cName(color)} collects 4 coins from the reserve.`);
        render();
    }
    // Berlin: extra maneuver after expand â€” handled in generateSteps / advanceTurn
    // Rome: crown bonus already handled in crownValueOfCity / applyBattleResult
}

function crownValueOfCity(name) {
    // Rome is worth 2 crowns (1 regular + 1 bonus from shield)
    return CITY_SHIELDS[name]?.crownBonus ? 1 + CITY_SHIELDS[name].crownBonus : (T[name]?.tax > 0 ? 1 : 0);
}

let G = {};

function launchGame() {
    const autos = autoColors();
    const fi = S.firstAuto || autos[0];
    const seating = [fi, ...autos.filter(c=>c!==fi), S.playerColor];
    const coins = {};
    S.coinsData.forEach(d => { coins[d.color] = d.total; });
    const crowns = {};
    const shields = {}; // shields[cityName] = color that owns it
    ['orange','green','purple','blue'].forEach(c => { crowns[c] = 2; }); // all start with 2 crowns
    // Apply shield ownership and crown bonuses for starting capitals
    const allCaps = { ...Object.fromEntries(autos.map(a=>[a, S.autoCapitals[a]?.name])), [S.playerColor]: S.playerCapital?.name };
    Object.entries(allCaps).forEach(([c, cityName]) => {
        if (cityName && CITY_SHIELDS[cityName]) {
            shields[cityName] = c; // assign shield to starting owner
            if (CITY_SHIELDS[cityName].crownBonus) {
                crowns[c] += CITY_SHIELDS[cityName].crownBonus;
            }
        }
    });
    G = {
        round:1, step:1, slot:0,
        firstPlayer:fi, pendingFirst:null,
        seating, decks:{}, hand:{}, coins, crowns, shields,
        crownCards:   Object.fromEntries(seating.map(c=>[c,0])),  // purchased Crown Cards held
        eliminated:   new Set(),   // colors permanently out of the game
        savedByCrown: new Set(),   // colors on their one-round grace period
        revealed:false, pendingMoves:[], currentSteps:[], checkedSteps:new Set(),
        humanTurnChecks:new Set(), humanBoardUpdated:false,
        roundCombats:[],
        logHistory:[]
    };
    autos.forEach(c => { G.decks[c]=[]; G.hand[c]=[]; });
    initBoard();
    prepareRound(true);
    addLog('Game started â€” Round 1 begins.');
    document.getElementById('setup-screen').style.display = 'none';
    document.getElementById('game-screen').style.display  = 'block';
    document.getElementById('board-btn').style.display = 'block';
    render();
}

function shuffle(arr) {
    const a=[...arr];
    for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}
    return a;
}
function autoColors_g() { return G.seating.filter(c=>c!==S.playerColor && !(G.eliminated||new Set()).has(c)); }
function cName(c) { return c===S.playerColor ? 'You' : c.charAt(0).toUpperCase()+c.slice(1); }
function cAttacks(c) { return c===S.playerColor ? 'You attack' : cName(c)+' attacks'; }

function refillDeck(c) { G.decks[c]=shuffle([...DECK_BASE]); addLog(`${cName(c)} deck reshuffled.`); }

function prepareRound(silent=false) {
    G.roundCombats = []; // fresh each round
    if (G.pendingFirst !== null) {
        G.firstPlayer = G.pendingFirst; G.pendingFirst = null;
        const fi = G.firstPlayer;
        G.seating = [fi, ...G.seating.filter(c=>c!==fi)];
        G.slot = 0;
        if(!silent) addLog(`${cName(fi)} is now First Player.`);
    }
    autoColors_g().forEach(c => {
        // Draw 2 cards â€” reshuffle mid-draw if deck runs out (don't discard remaining card)
        const card1 = G.decks[c].length > 0 ? G.decks[c].pop() : (refillDeck(c), G.decks[c].pop());
        if (G.decks[c].length === 0) refillDeck(c);
        const card2 = G.decks[c].pop();
        G.hand[c] = [card1, card2];
    });
    if(!silent) addLog(`Round ${G.round} â€” cards dealt.`);
}

function getTurnOrder() {
    const si = G.seating.indexOf(G.firstPlayer);
    const all = [0,1,2,3].map(i=>G.seating[(si+i)%4]);
    return all.filter(c => !(G.eliminated||new Set()).has(c));
}
function activeColor() {
    const order = getTurnOrder();
    return order[G.slot % order.length];
}

function addLog(msg) {
    G.logHistory.unshift(msg);
    if(G.logHistory.length>6) G.logHistory.pop();
    const el = document.getElementById('action-log');
    if(el) el.innerHTML = G.logHistory.slice(0,3).map((m,i)=>
        `<div class="log-entry ${i>0?'old':''}">${i===0?'â–¶ ':'  '}${m}</div>`).join('');
}

function addCoin(c, v) {
    G.coins[c] = Math.max(0, G.coins[c]+v);
    render();
    // Never regenerate steps mid-turn â€” steps are locked once revealed
}

// Remove all units from board for a color
function eliminatePlayer(color) {
    if (G.eliminated.has(color)) return;
    G.eliminated.add(color);
    G.savedByCrown.delete(color);
    // Wipe all units and ownership
    for (const name of Object.keys(G.board)) {
        if (G.board[name].owner === color) {
            G.board[name].owner = 'neutral';
            G.board[name].units = {F:0,A:0,C:0,S:0};
            // Castle stays â€” rule says return "City Bonus Tiles and coins", not castles explicitly;
            // but to keep board clean, remove the castle too
            G.board[name].castle = false;
        }
    }
    // Return coins to reserve (just zero out)
    G.coins[color] = 0;
    // Crown Cards are removed from game (NOT returned to reserve) â€” remove them from crownCards
    // but crowns from city captures stay removed (crowns are never returned)
    const cards = G.crownCards[color] || 0;
    if (cards > 0) {
        G.crownCards[color] = 0;
        // The crown tracker stays where it is â€” the banner just stays at that value, representing removed cards
        addLog(`${cName(color)}'s ${cards} Crown Card${cards>1?'s':''} removed from game.`);
    }
    const isHuman = color === S.playerColor;
    const who = isHuman ? 'YOU are' : cName(color) + ' is';
    addLog(`ðŸ’€ ${who} ELIMINATED â€” no cities and no crowns remaining.`);
    if (isHuman) {
        setTimeout(() => {
            const el = document.getElementById('winner-overlay') || (() => {
                const d = document.createElement('div'); d.id = 'winner-overlay';
                d.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;z-index:1000;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.88);';
                document.body.appendChild(d); return d;
            })();
            el.innerHTML = `<div style="background:var(--parchment);border:4px solid #8b1a1a;border-radius:12px;
                padding:36px 28px;max-width:360px;width:90%;text-align:center;">
                <div style="font-size:3em;margin-bottom:8px;">ðŸ’€</div>
                <div style="font-family:Cinzel,serif;font-size:1.4em;font-weight:700;color:#8b1a1a;margin-bottom:8px;">YOU HAVE BEEN ELIMINATED</div>
                <div style="font-size:0.9em;color:var(--ink-light);margin-bottom:24px;">No cities and no crowns remaining.</div>
                <button onclick="confirmReset()" style="background:#8b1a1a;color:#fff;border:none;border-radius:8px;
                    padding:13px 28px;font-family:Cinzel,serif;font-size:1em;font-weight:700;cursor:pointer;width:100%;">
                    â†º New Game
                </button>
            </div>`;
            el.style.display = 'flex';
        }, 200);
    }
    render();
}

// Check all players for elimination at end of round
function checkElimination() {
    const allColors = G.seating;
    for (const c of allColors) {
        if (G.eliminated.has(c)) continue;
        const cities = ownedBy(c).filter(n => T[n].tax > 0);
        if (cities.length > 0) {
            // Has cities â€” safe. Clear any grace period.
            if (G.savedByCrown.has(c)) {
                G.savedByCrown.delete(c);
                addLog(`${cName(c)} reclaimed a city â€” no longer on grace period.`);
            }
            continue;
        }
        // No cities
        const crowns = G.crowns[c] || 0;
        const cards  = G.crownCards[c] || 0;
        if (G.savedByCrown.has(c)) {
            // Already had grace period â€” now eliminate
            eliminatePlayer(c);
        } else if (crowns === 0) {
            // No cities, no crowns â€” immediate elimination
            eliminatePlayer(c);
        } else if (cards > 0) {
            // No cities but has Crown Card(s) â€” Saved by the Crown (one more round)
            G.savedByCrown.add(c);
            addLog(`ðŸ›¡ SAVED BY THE CROWN: ${cName(c)} has no cities but holds ${cards} Crown Card${cards>1?'s':''}. One more round to reclaim a city!`);
        } else {
            // No cities, has crowns from captures but no crown cards â€” eliminate
            // (Saved by the Crown specifically requires owning a Crown Card tile)
            eliminatePlayer(c);
        }
    }
}
function checkWin(c) {
    if (!G.crowns) return;
    if ((G.crowns[c]||0) >= 7 && !G.winner) {
        G.winner = c;
        // Show winner banner â€” defer slightly so any current render finishes first
        setTimeout(showWinnerScreen, 50);
    }
}

function showWinnerScreen() {
    const c = G.winner;
    if (!c) return;
    const isHuman = c === S.playerColor;
    const hex = COLOR_HEX[c] || '#888';
    const light = ['orange','green','blue'].includes(c);
    const txt = light ? '#000' : '#fff';
    const who = isHuman ? 'YOU WIN!' : cName(c).toUpperCase() + ' WINS!';
    const sub = isHuman
        ? `You reached ${G.crowns[c]} crowns. Congratulations!`
        : `${cName(c)} reached ${G.crowns[c]} crowns.`;

    // Overlay the entire screen
    let el = document.getElementById('winner-overlay');
    if (!el) {
        el = document.createElement('div');
        el.id = 'winner-overlay';
        el.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;z-index:1000;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.88);';
        document.body.appendChild(el);
    }
    el.innerHTML = `<div style="background:var(--parchment);border:4px solid ${hex};border-radius:12px;
        padding:36px 28px;max-width:360px;width:90%;text-align:center;box-shadow:0 0 60px ${hex}88;">
        <div style="font-size:3em;margin-bottom:8px;">ðŸ‘‘</div>
        <div style="font-family:Cinzel,serif;font-size:1.6em;font-weight:700;color:${hex};margin-bottom:8px;">${who}</div>
        <div style="font-size:1em;color:var(--ink-light);margin-bottom:24px;">${sub}</div>
        <button onclick="confirmReset()" style="background:${hex};color:${txt};border:none;border-radius:8px;
            padding:13px 28px;font-family:Cinzel,serif;font-size:1em;font-weight:700;cursor:pointer;width:100%;">
            â†º New Game
        </button>
    </div>`;
    el.style.display = 'flex';
}
function addCrown(c, v) {
    if (!G.crowns) G.crowns = {};
    G.crowns[c] = Math.max(0, (G.crowns[c]||0) + v);
    checkWin(c);
    render();
}

function setFirst(c) {
    G.pendingFirst = c;
    addLog(`${cName(c)} will be First Player next round (KING ME pending).`);
    render();
}



function toggleRef(id) {
    const body=document.getElementById(id);
    const btn=body.previousElementSibling;
    body.classList.toggle('open'); btn.classList.toggle('open');
}

// ================================================================
// REVEAL & STEPS
// ================================================================
function revealAction() {
    if (G.winner) { showWinnerScreen(); return; }
    const color = activeColor();
    const card  = G.hand[color]?.[G.step-1];
    if(!card) { addLog('No card available.'); return; }
    const cardEl = document.getElementById('card-display');
    cardEl.className = 'action-card revealed';
    cardEl.innerHTML = card+`<div class="card-sub">${cName(color)} Â· ${G.coins[color]} coins</div>`;
    G.revealed = true;
    document.getElementById('reveal-btn').style.display = 'none';
    addLog(`${cName(color)}: "${card}" (${G.coins[color]} coins)`);
    regenerateSteps(card, color);
}

function regenerateSteps(card, color) {
    G._stepCoinEffects = {};
    resetStuckTimer();
    try {
        G.currentSteps = generateSteps(card, color, G.coins[color]);
    } catch(e) {
        console.error('generateSteps crashed:', e);
        G.currentSteps = [
            `<b>âš  Step generation error for "${card}".</b> You can still complete this turn manually. Error: ${e.message}`
        ];
    }
    if (!G.currentSteps || !G.currentSteps.length) {
        G.currentSteps = [`<b>${card}</b> â€” no specific steps generated. Resolve per rulebook, then complete turn.`];
    }
    G.checkedSteps = new Set();
    try { renderSteps(); } catch(e) { console.error('renderSteps crashed:', e); }
    const btn = document.getElementById('complete-btn');
    if (btn) btn.disabled = true;
}

function toggleStep(i) {
    if(G.currentSteps[i] === null) return; // divider â€” not toggleable
    const wasChecked = G.checkedSteps.has(i);
    if(wasChecked) G.checkedSteps.delete(i); else G.checkedSteps.add(i);

    // Auto-apply effects when step is checked/unchecked
    if(G._stepCoinEffects && G._stepCoinEffects[i] !== undefined) {
        const effect = G._stepCoinEffects[i];
        const color = activeColor();
        if(typeof effect === 'string' && effect.startsWith('kingme:')) {
            // KING ME: queue or unqueue first player change
            const kingColor = effect.split(':')[1];
            if(!wasChecked) {
                G.pendingFirst = kingColor;
                addLog(`${cName(kingColor)} will be First Player next round.`);
            } else {
                G.pendingFirst = null;
            }
        } else {
            const delta = Number(effect);
            if(!wasChecked) {
                G.coins[color] = Math.max(0, G.coins[color] + delta);
                // Tax shield: fires when tax step is checked (delta > 0 = we just collected tax)
                if (delta > 0) {
                    const taxCity = G.pendingMoves?.find(m=>m.type==='tax')?.city;
                    if (taxCity) applyShieldBonus(taxCity, color, 'tax');
                }
            } else {
                G.coins[color] = Math.max(0, G.coins[color] - delta);
            }
        }
        render();
    }

    renderSteps();
    const checkableCount = G.currentSteps.filter(s=>s!==null).length;
    const _cb1 = document.getElementById('complete-btn');
    if(_cb1) _cb1.disabled = (G.checkedSteps.size < checkableCount);
}

function renderSteps() {
    const panel=document.getElementById('steps-panel');
    const list=document.getElementById('steps-list');
    if(!panel || !list) return; // DOM not ready
    if(!G.currentSteps || !G.currentSteps.length) { panel.style.display='none'; return; }
    panel.style.display='block';
    const color=activeColor();
    const header=document.getElementById('steps-header');
    header.textContent=`STEPS TO PERFORM â€” ${color.toUpperCase()}`;
    header.style.background=COLOR_HEX[color]||'var(--accent)';
    const checkable = G.currentSteps.filter(s=>s!==null).length;
    const pct = checkable ? Math.round((G.checkedSteps.size/checkable)*100) : 0;
    document.getElementById('steps-progress-fill').style.width = pct+'%';
    let stepNum = 0;
    list.innerHTML = G.currentSteps.map((s,i)=>{
        if(s === null) {
            return `<div class="step-divider">2nd Action â€” Expand or Maneuver</div>`;
        }
        stepNum++;
        const checked=G.checkedSteps.has(i);
        return `<div class="step-item ${checked?'checked':''}" onclick="toggleStep(${i})">
            <div class="step-checkbox">${checked?'âœ“':''}</div>
            <div class="step-num">${stepNum}</div>
            <div class="step-text">${s}</div>
        </div>`;
    }).join('');
}

// ================================================================
// STEP GENERATOR
// ================================================================
function generateSteps(card, color, coins) {
    const C = cName(color);
    const steps = [];
    // Reset pending move queue and coin effects for this turn
    G.pendingMoves = [];
    G.pendingMove = null; // legacy â€” points to last move for combat dialog use
    G._stepCoinEffects = {};

    // Compute the specific expand/split/maneuver move
    const expandDec = decideExpand(color);
    const maneuverDec = decideManeuver(color);
    const posDec = decidePosition(color);
    
    let EXPAND;
    if (expandDec) {
        const leave = leaveBehindCount(expandDec.from);
        const moving = unitsToMove(expandDec.from, expandDec.movable, expandDec.hasCastle);
        const leaveUnits = unitsToLeave(expandDec.from, leave);
        G.pendingMove = { type:'expand', color, from:expandDec.from, to:expandDec.to,
            movingUnits:moving, movable:expandDec.movable, isEnemy:expandDec.isEnemy };
        G.pendingMoves.push(G.pendingMove);
        const moveDetail = `Move <b>${unitStr(moving)}</b> from <b>${expandDec.from}</b> â†’ <b>${expandDec.to}</b>`;
        const leaveDetail = `Leave <b>${unitStr(leaveUnits)}</b> at ${expandDec.from}`;
        const combatStep = expandDec.isEnemy
            ? renderCombatDialog(G.pendingMove)
            : null;
        const hasBerlinShield = CITY_SHIELDS['Berlin']?.trigger === 'expand_spend' && G.shields?.['Berlin'] === color;
        const berlinReminder = hasBerlinShield
            ? `<div class="shield-reminder">${color === S.playerColor ? CITY_SHIELDS['Berlin'].reminder : 'ðŸ›¡ BERLIN SHIELD: ' + cName(color) + ' expands then also maneuvers (bonus action). Castles cost 3 fewer coins.'}</div>`
            : null;
        // Berlin automa: queue a bonus maneuver after the expand
        if (hasBerlinShield && color !== S.playerColor) {
            const bonusManeuver = decideManeuver(color);
            if (bonusManeuver) {
                const bmMoving = unitsToMove(bonusManeuver.from, bonusManeuver.movable, false);
                G.pendingMoves.push({ type:'maneuver', color, from:bonusManeuver.from, to:bonusManeuver.to, movingUnits:bmMoving, _berlinBonus:true });
            }
        }
        EXPAND = [
            `<b>EXPAND:</b> ${moveDetail}.<br>${leaveDetail} (leave-behind rule: ${T[expandDec.from].tax>0?'Tax value '+T[expandDec.from].tax:'1 unit for non-urban'}).
             <span class="rule-note">Target: ${expandDec.to} (Tax ${expandDec.tax}${expandDec.isEnemy?', ENEMY: '+expandDec.defenders+' defenders':', '+(G.board[expandDec.to].owner==='neutral'?'neutral':'friendly')+'.'})${expandDec.hasCastle?' âš  Has castle â€” Siege Engine required.':''}</span>`,
            ...(berlinReminder ? [berlinReminder] : []),
            ...(combatStep ? [combatStep] : []),
        ];
    } else if (posDec) {
        const posMoving = unitsToMove(posDec.from, posDec.movable, false);
        G.pendingMove = { type:'position', color, from:posDec.from, to:posDec.to, movingUnits:posMoving };
        G.pendingMoves.push(G.pendingMove);
        const leaveN2 = leaveBehindCount(posDec.from);
        EXPAND = [
            `<b>NO DIRECT CITY ENTRY POSSIBLE â€” POSITION:</b> Move <b>${unitStr(posMoving)}</b> from <b>${posDec.from}</b> â†’ <b>${posDec.to}</b> (moving toward <b>${posDec.toward}</b>).
            <span class="rule-note">Leave-behind: ${T[posDec.from].tax>0?'Tax value '+T[posDec.from].tax+' units':1+' unit'} at ${posDec.from}.</span>`,
        ];
    } else if (maneuverDec) {
        const moving = unitsToMove(maneuverDec.from, maneuverDec.movable, false);
        G.pendingMove = { type:'maneuver', color, from:maneuverDec.from, to:maneuverDec.to, movingUnits:moving };
        G.pendingMoves.push(G.pendingMove);
        const hopsNote = maneuverDec.reason?.includes('2-step') ? ' (2-step move through own territory)' : '';
        EXPAND = [
            `<b>MANEUVER:</b> Move <b>${unitStr(moving)}</b> from <b>${maneuverDec.from}</b> â†’ <b>${maneuverDec.to}</b>${hopsNote}.
            <span class="rule-note">${maneuverDec.reason}</span>`,
        ];
    } else {
        G.pendingMove = { type:'none' };
        G.pendingMoves.push(G.pendingMove);
        EXPAND = [
            `<b>NO MOVE POSSIBLE</b> â€” ${C} cannot Expand, Position, or Maneuver this action. No pieces to move. âœ“ and continue.`,
        ];
    }

    if (card === "TAX OR SPEND") {
        // Saved by the Crown restriction: no cities â†’ cannot tax; can spend only if has castle
        const _hasCities  = ownedBy(color).filter(n => T[n].tax > 0).length > 0;
        const _hasCastle  = ownedBy(color).some(n => G.board[n].castle);
        const _savedGrace = G.savedByCrown?.has(color) && !_hasCities;
        if (_savedGrace && !_hasCastle) {
            steps.push(`<b>NO ACTION â€” SAVED BY THE CROWN:</b> ${C} has no cities and no castle. Cannot tax or spend. âœ“ Skip this action.`);
            return steps;
        }
        if (_savedGrace) {
            steps.push(`<div class="shield-reminder">âš  SAVED BY THE CROWN: ${C} has no cities â€” cannot tax. May spend only because ${C} controls a castle.</div>`);
            // Force spend regardless of coin count
            const { cost, items } = getBestSpend(coins, color);
            const hasCastle2 = items.includes("Castle");
            const hasSiege2  = items.includes("Siege Engine");
            const purchase2  = { cost, items,
                F:(items.match(/(\d+) Footm/)||[0,0])[1]|0,
                A:(items.match(/(\d+) Archer/)||[0,0])[1]|0,
                C:(items.match(/(\d+) Cavalry/)||[0,0])[1]|0,
                S:hasSiege2?1:0, castle:hasCastle2 };
            const placements2 = decideSpendPlacements(color, purchase2);
            G.pendingMove = { type:'spend', color, purchase:purchase2, placements:placements2 };
            G.pendingMoves.push(G.pendingMove);
            G._stepCoinEffects[0] = -cost;
            if (coins < cost) {
                steps.push(`<b>INSUFFICIENT COINS</b> â€” ${C} cannot afford any purchase. âœ“ Skip.`);
            } else {
                steps.push(`<b>MODE: SPEND (castle only)</b> â€” Purchase: <span class="buy-highlight">${items}</span> Cost: <b>${cost} coins.</b>`);
            }
            return steps;
        }
        if (coins <= 4) {
            const taxDec = decideTax(color);
            const taxCity = taxDec ? taxDec.city : '(highest-yield city)';
            const taxAmt  = taxDec ? taxDec.yield : '?';
            G.pendingMove = { type:'tax', color, city: taxCity, amount: taxAmt };
            G.pendingMoves.push(G.pendingMove);
            steps.push(`<b>MODE: TAX</b> â€” ${C} has ${coins} coins (â‰¤ 4).`);
            // Register coin effect: checking step 1 (index 1) adds taxAmt coins
            G._stepCoinEffects[1] = taxAmt;
            steps.push(`Tax <b>${taxCity}</b> â€” yield is <b>${taxAmt} coins</b>. âœ“ Check this step to automatically add ${taxAmt} coins to ${C}'s total.
                <span class="rule-note">Yield = city's own Tax value + 1 per connected non-urban territory + Tax value of connected cities ${C} owns (all connected through ${C}'s own supply line).</span>`);
            // Shield reminders for tax-trigger cities
            if (CITY_SHIELDS[taxCity]?.trigger === 'tax' && G.shields?.[taxCity] === color) {
                steps.push(`<div class="shield-reminder">${CITY_SHIELDS[taxCity].reminder}</div>`);
            }
        } else {
            const { cost, items } = getBestSpend(coins, color);
            const hasCastle = items.includes("Castle");
            const hasSiege  = items.includes("Siege Engine");
            // Parse purchase into unit counts
            const purchase = { cost, items,
                F: (items.match(/(\d+) Footm/)||[0,0])[1]|0,
                A: (items.match(/(\d+) Archer/)||[0,0])[1]|0,
                C: (items.match(/(\d+) Cavalry/)||[0,0])[1]|0,
                S: hasSiege ? 1 : 0,
                castle: hasCastle
            };
            const placements = decideSpendPlacements(color, purchase);
            G.pendingMove = { type:'spend', color, purchase, placements };
            G.pendingMoves.push(G.pendingMove);
            // Register coin effect: checking step 0 deducts cost coins
            G._stepCoinEffects[0] = -cost;
            // Track crown card flag on purchase
            if (purchase.crownCard) G._pendingCrownCard = color;
            steps.push(`<b>MODE: SPEND</b> â€” ${C} has ${coins} coins (â‰¥ 5). Purchase:<span class="buy-highlight">${items}</span>Cost: <b>${cost} coins.</b> âœ“ Check this step to automatically deduct the cost.
                <span class="rule-note">If a figure type runs out: substitute 2 Footmen â†” 1 Archer. Never buy Crown Cards unless no Castles remain in supply.</span>`);
            placements.forEach((p,i) => {
                const curr = totalUnitCount(p.territory);
                if (p.type === 'castle') {
                    steps.push(`<b>Place Castle</b> at <b>${p.territory}</b> (Tax ${T[p.territory]?.tax||'?'}, currently ${curr} units).`);
                } else if (p.type === 'siege') {
                    steps.push(`<b>Place Siege Engine</b> at <b>${p.territory}</b> â€” closest territory to an enemy castle.`);
                    if (CITY_SHIELDS["Constantinople"]?.trigger === 'spend' && G.shields?.["Constantinople"] === color) {
                        steps.push(`<div class="shield-reminder">${CITY_SHIELDS["Constantinople"].reminder}</div>`);
                    }
                } else {
                    const qname = p.unitType==='C'?'Cavalry':p.unitType==='A'?'Archer':'Footman';
                    steps.push(`<b>Place ${p.count} ${qname}${p.count>1?'s':''}</b> at <b>${p.territory}</b> (Tax ${T[p.territory]?.tax||'?'}, currently ${curr} units).`);
                }
            });
            // Kiev shield â€” remind player they can place in non-city supply territories
            if (CITY_SHIELDS["Kiev"]?.trigger === 'spend' && G.shields?.["Kiev"] === color) {
                steps.push(`<div class="shield-reminder">${CITY_SHIELDS["Kiev"].reminder}</div>`);
            }
        }
        return steps;
    }

    if (card === "EXPAND OR MANEUVER") { steps.push(...EXPAND); return steps; }

    if (card === "SPLIT EXPAND OR MANEUVER") {
        const splitDec = decideSplitExpand(color);
        if (splitDec) {
            const moving = unitsToMove(splitDec.from, splitDec.movable, splitDec.hasCastle);
            G.pendingMove = { type:'expand', color, from:splitDec.from, to:splitDec.to,
                movingUnits:moving, movable:splitDec.movable, isEnemy:splitDec.isEnemy };
            G.pendingMoves.push(G.pendingMove);
            const route = splitDec.via ? `${splitDec.from} â†’ ${splitDec.via} â†’ ${splitDec.to}` : `${splitDec.from} â†’ ${splitDec.to}`;
            steps.push(`<b>SPLIT EXPAND:</b> Move <b>${unitStr(moving)}</b> along route: <b>${route}</b>.
                <span class="rule-note">Leave ${T[splitDec.from].tax>0?'Tax value '+T[splitDec.from].tax:'1'} unit(s) at ${splitDec.from}. Target ${splitDec.to}: Tax ${splitDec.tax}${splitDec.isEnemy?', ENEMY: '+splitDec.defenders+' defenders':''}${splitDec.hasCastle?' â€” has castle (Siege Engine required)':''}</span>`);
            if (splitDec.isEnemy) steps.push(renderCombatDialog(G.pendingMove));
        } else {
            // Rule: if no city can be entered, MANEUVER only â€” not expand or position
            if (maneuverDec) {
                const mMov = unitsToMove(maneuverDec.from, maneuverDec.movable, false);
                G.pendingMove = { type:'maneuver', color, from:maneuverDec.from, to:maneuverDec.to, movingUnits:mMov };
                G.pendingMoves.push(G.pendingMove);
                const hNote = maneuverDec.reason?.includes('2-step') ? ' (2-step)' : '';
                steps.push(`<b>NO CITY REACHABLE â€” MANEUVER:</b> Move <b>${unitStr(mMov)}</b> from <b>${maneuverDec.from}</b> â†’ <b>${maneuverDec.to}</b>${hNote}.
                <span class="rule-note">${maneuverDec.reason}</span>`);
            } else {
                G.pendingMove = { type:'none' }; G.pendingMoves.push(G.pendingMove);
                steps.push(`<b>NO MOVE POSSIBLE</b> â€” ${C} cannot Split Expand or Maneuver. âœ“ and continue.`);
            }
        }
        return steps;
    }

    if (card === "FORTIFY / EXPAND OR MANEUVER") {
        const fortDec = decideFortify(color);
        const fortTerr = fortDec ? fortDec.territory : '(city with fewest units)';
        const fortCount = fortDec ? fortDec.count : 3;
        const currCount = fortDec ? totalUnitCount(fortDec.territory) : '?';
        // Store fortify as a proper move entry
        if (fortDec) G.pendingMoves.push({ type:'fortify', territory:fortDec.territory, count:fortDec.count });
        G.pendingFortify = fortDec; // legacy
        steps.push(`<b>FORTIFY:</b> Add <b>+${fortCount} Footmen</b> to <b>${fortTerr}</b> (currently ${currCount} units${fortDec&&G.board[fortTerr]?.castle?' â€” has castle':''}). Take them from the supply.
            <span class="rule-note">${fortDec&&fortDec.hasCastle?'+4 Footmen because this location has a castle.':'+3 Footmen to a city.'} Priority: fewest units â†’ highest Tax â†’ Capital beats city â†’ roll die.</span>`);
        steps.push(null); // â”€â”€ section divider â”€â”€

        // â”€â”€ CRITICAL: recompute expand/position/maneuver AFTER applying fortify â”€â”€
        // The fortify hasn't hit G.board yet (it applies in advanceTurn), so we
        // temporarily apply it now, recompute, then undo.
        // This ensures the expand picks up the newly fortified army if it's now largest.
        if (fortDec && G.board[fortDec.territory]) {
            G.board[fortDec.territory].units.F = (G.board[fortDec.territory].units.F||0) + fortDec.count;
        }
        // Remove the EXPAND steps we pushed earlier (they used stale board state)
        // and recompute with the updated board
        // First, remove the stale pendingMove that EXPAND pushed (if any)
        G.pendingMoves = G.pendingMoves.filter(m => m._berlinBonus || m.type === 'fortify');
        G.pendingMove = null;
        const postFortExpandDec  = decideExpand(color);
        const postFortManDec     = decideManeuver(color);
        const postFortPosDec     = decidePosition(color);
        // Undo the temporary fortify
        if (fortDec && G.board[fortDec.territory]) {
            G.board[fortDec.territory].units.F = Math.max(0, (G.board[fortDec.territory].units.F||0) - fortDec.count);
        }
        // Rebuild EXPAND block with post-fortify decisions
        let EXPAND_POST;
        if (postFortExpandDec) {
            const pLeave = leaveBehindCount(postFortExpandDec.from);
            const pMoving = unitsToMove(postFortExpandDec.from, postFortExpandDec.movable, postFortExpandDec.hasCastle);
            const pLeaveUnits = unitsToLeave(postFortExpandDec.from, pLeave);
            G.pendingMove = { type:'expand', color, from:postFortExpandDec.from, to:postFortExpandDec.to,
                movingUnits:pMoving, movable:postFortExpandDec.movable, isEnemy:postFortExpandDec.isEnemy };
            G.pendingMoves.push(G.pendingMove);
            const pMoveDetail  = `Move <b>${unitStr(pMoving)}</b> from <b>${postFortExpandDec.from}</b> â†’ <b>${postFortExpandDec.to}</b>`;
            const pLeaveDetail = `Leave <b>${unitStr(pLeaveUnits)}</b> at ${postFortExpandDec.from}`;
            const pCombatStep  = postFortExpandDec.isEnemy ? renderCombatDialog(G.pendingMove) : null;
            const pHasBerlin   = CITY_SHIELDS['Berlin']?.trigger === 'expand_spend' && G.shields?.['Berlin'] === color;
            const pBerlinNote  = pHasBerlin
                ? `<div class="shield-reminder">${color===S.playerColor?CITY_SHIELDS['Berlin'].reminder:'ðŸ›¡ BERLIN SHIELD: '+cName(color)+' expands then also maneuvers. Castles cost 3 fewer coins.'}</div>`
                : null;
            if (pHasBerlin && color !== S.playerColor) {
                const bm = decideManeuver(color);
                if (bm) { const bmMv = unitsToMove(bm.from,bm.movable,false); G.pendingMoves.push({type:'maneuver',color,from:bm.from,to:bm.to,movingUnits:bmMv,_berlinBonus:true}); }
            }
            EXPAND_POST = [
                `<b>EXPAND:</b> ${pMoveDetail}.<br>${pLeaveDetail} (leave-behind: ${T[postFortExpandDec.from].tax>0?'Tax value '+T[postFortExpandDec.from].tax:'1 unit for non-urban'}).
                 <span class="rule-note">Target: ${postFortExpandDec.to} (Tax ${postFortExpandDec.tax}${postFortExpandDec.isEnemy?', ENEMY: '+postFortExpandDec.defenders+' defenders':', '+(G.board[postFortExpandDec.to].owner==='neutral'?'neutral':'friendly')+'.'}).${postFortExpandDec.hasCastle?' âš  Has castle â€” Siege Engine required.':''}</span>`,
                ...(pBerlinNote ? [pBerlinNote] : []),
                ...(pCombatStep ? [pCombatStep] : []),
            ];
        } else if (postFortPosDec) {
            const pPosMoving = unitsToMove(postFortPosDec.from, postFortPosDec.movable, false);
            G.pendingMove = { type:'position', color, from:postFortPosDec.from, to:postFortPosDec.to, movingUnits:pPosMoving };
            G.pendingMoves.push(G.pendingMove);
            EXPAND_POST = [
                `<b>NO DIRECT CITY ENTRY POSSIBLE â€” POSITION:</b> Move <b>${unitStr(pPosMoving)}</b> from <b>${postFortPosDec.from}</b> â†’ <b>${postFortPosDec.to}</b> (moving toward <b>${postFortPosDec.toward}</b>).
                <span class="rule-note">Leave-behind: ${T[postFortPosDec.from].tax>0?'Tax value '+T[postFortPosDec.from].tax+' units':'1 unit'} at ${postFortPosDec.from}.</span>`,
            ];
        } else if (postFortManDec) {
            const pManMoving = unitsToMove(postFortManDec.from, postFortManDec.movable, false);
            G.pendingMove = { type:'maneuver', color, from:postFortManDec.from, to:postFortManDec.to, movingUnits:pManMoving };
            G.pendingMoves.push(G.pendingMove);
            EXPAND_POST = [
                `<b>MANEUVER:</b> Move <b>${unitStr(pManMoving)}</b> from <b>${postFortManDec.from}</b> â†’ <b>${postFortManDec.to}</b>.
                <span class="rule-note">${postFortManDec.reason}</span>`,
            ];
        } else {
            G.pendingMove = { type:'none' };
            G.pendingMoves.push(G.pendingMove);
            EXPAND_POST = [`<b>NO MOVE POSSIBLE</b> â€” ${C} cannot Expand, Position, or Maneuver. âœ“ and continue.`];
        }
        steps.push(...EXPAND_POST);
        return steps;
    }

    if (card === "SIEGE ASSAULT / EXPAND OR MANEUVER") {
        const siegeDec = decideSiege(color);
        if (siegeDec) {
            const siegeMovable = movableCount(siegeDec.from, color);
            const siegeMovingUnits = unitsToMove(siegeDec.from, siegeMovable, true); // true = keep siege engine
            G.pendingMove = { type:'expand', color, from:siegeDec.from, to:siegeDec.to,
                movingUnits: siegeMovingUnits, movable: siegeMovable, isEnemy:true };
            G.pendingMoves.push(G.pendingMove);
            steps.push(`<b>SIEGE ASSAULT:</b> Attack <b>${siegeDec.to}</b> from <b>${siegeDec.from}</b> (${siegeDec.defenders} defenders, owned by ${siegeDec.defOwner}).`);
            steps.push(`<b>Resolve siege combat</b> (Siege Engine fires first per base game rules).`);
            steps.push(renderCombatDialog(G.pendingMove));
        } else {
            steps.push(`<b>SIEGE ASSAULT: No Siege Engine available</b> â€” ${C} has no siege engines on the board. Skip to EXPAND/MANEUVER below.`);
        }
        steps.push(null); // â”€â”€ section divider â”€â”€
        steps.push(...EXPAND);
        return steps;
    }

    if (card === "KING ME") {
        // Register auto-effect: checking step 0 sets pending first player
        G._stepCoinEffects[0] = 'kingme:' + color; // special string signal
        steps.push(`<b>KING ME:</b> ${C} claims the First Player marker. âœ“ Check this step to automatically queue the First Player change for next round.`);
        steps.push(`The change takes effect at the <b>start of next round</b>. The crown icon on ${C}'s tile will pulse yellow to confirm it is pending.`);
        return steps;
    }

    steps.push(`Unknown card: "${card}". Check the rulebook.`);
    return steps;
}

// Combat-required step â€” rendered inline in the checklist
function renderCombatDialog(move) {
    if (!move || !move.from || !move.to) return '';
    // Queue this attack for the Combat Phase at end of round
    if (!G.roundCombats) G.roundCombats = [];
    // Avoid duplicates
    const already = G.roundCombats.some(c => c.from===move.from && c.to===move.to && c.color===move.color);
    if (!already) G.roundCombats.push({ ...move });
    const defOwner = G.board[move.to]?.owner || 'neutral';
    const def = totalUnitCount(move.to);
    return `<div style="background:rgba(139,26,26,0.06);border:2px solid rgba(139,26,26,0.3);border-radius:8px;padding:10px 14px;font-size:0.87em;">
        <b style="font-family:Cinzel,serif;color:var(--accent);">âš” Attack queued for Combat Phase</b><br>
        <span style="color:var(--ink-light);">${move.movable||totalUnitCount(move.from)} units: <b>${move.from} â†’ ${move.to}</b> Â· ${def} defenders (${defOwner.toUpperCase()})</span>
    </div>`;
}

function findStepIdxContaining(text) {
    return G.currentSteps.findIndex((s, i) => s && s.includes(text) && !G.checkedSteps.has(i));
}

function applyCombatAndCheck() { /* replaced by combat subsystem */ }
function launchCombatFromStep() {} // deprecated â€” combat is now end-of-round
function skipCombatStep() {}       // deprecated

// ================================================================
// ADVANCE TURN
// ================================================================
function advanceTurn() {
    if (G.winner) return; // game over â€” don't advance
    // Apply all pending board changes for this turn in order
    for (const mv of (G.pendingMoves || [])) {
        if (!mv || mv.type === 'tax' || mv.type === 'none' || mv._applied) continue;
        if (mv.type === 'spend') {
            applySpend(mv.color, mv.purchase, mv.placements||[]);
            // Constantinople shield: fires if a Siege Engine was purchased
            if (mv.purchase?.S > 0) applyShieldBonus('Constantinople', mv.color, 'siege_buy');
            // Kiev shield: fires on any spend
            applyShieldBonus('Kiev', mv.color, 'spend');
            // Berlin shield (castle cost reduction) already baked into spend table; extra maneuver handled in generateSteps
        } else if (mv.type === 'fortify') {
            applyFortify(mv.territory, mv.count);
        } else if (mv.type === 'expand' || mv.type === 'position' || mv.type === 'maneuver') {
            if (!mv.isEnemy) {
                applyNonCombatMove(mv);
            } else {
                // Queue for end-of-round Combat Phase
                if (!G.roundCombats) G.roundCombats = [];
                const already = G.roundCombats.some(c=>c.from===mv.from&&c.to===mv.to&&c.color===mv.color);
                if (!already) G.roundCombats.push({ ...mv });
            }
        }
    }
    G.pendingMoves = [];
    G.pendingMove = null;
    G.pendingFortify = null;
    G.humanTurnChecks = new Set();
    G.humanBoardUpdated = false;
    BE.movedFrom = new Set(); // clear crossed-off territories for new turn
    G.revealed = false; G.currentSteps = []; G.checkedSteps = new Set();
    G.slot++;
    if (G.slot >= 4) {
        G.slot = 0;
        if (G.step === 1) {
            G.step = 2;
            addLog('â€” All players finished Action 1. Now Action 2. â€”');
        } else {
            G.step = 1;
            // Launch Combat Phase for the round that just ended, THEN increment
            if (G.roundCombats && G.roundCombats.length > 0) {
                openCombatPhase(G.round);   // pass current round before incrementing
                G.round++;
            } else {
                G.round++;
                checkElimination();
                if (!G.winner) prepareRound(false);
            }
        }
    }
    render();
    resetStuckTimer();
}

function confirmReset() {
    if(!confirm('Reset entire game and return to setup?')) return;
    const wo = document.getElementById('winner-overlay');
    if (wo) wo.style.display = 'none';
    G = {};
    Object.assign(S, { step:0, playerColor:null, firstAuto:null, autoCapitals:{}, playerCapital:null,
                       autoSecondary:{}, playerSecondary:null, takenAdj:new Set(), shuffledCaps:[], coinsData:[] });
    document.getElementById('game-screen').style.display  = 'none';
    document.getElementById('setup-screen').style.display = 'block';
    showStep(0);
}

// ================================================================
// RENDER
// ================================================================
function render() {
    const order  = getTurnOrder();
    const active = activeColor();
    const bar    = document.getElementById('player-bar');
    bar.innerHTML = '';
    order.forEach((c,i) => {
        const isActive  = i===G.slot;
        const isFirst   = c===G.firstPlayer;
        const isPending = c===G.pendingFirst;
        const isHuman   = c===S.playerColor;
        const tile      = document.createElement('div');
        const isSaved = G.savedByCrown?.has(c);
        const isElim  = G.eliminated?.has(c);
        tile.className  = `player-tile ${isActive?'active':''} ${isFirst?'is-first':''} ${isPending?'is-pending':''} ${isSaved?'is-saved':''} ${isElim?'is-eliminated':''}`;
        tile.style.background = `var(--p-${c})`;
        // Light backgrounds need dark text
        const lightColors = ['blue', 'green', 'orange'];
        const textColor = lightColors.includes(c) ? 'rgba(0,0,0,0.85)' : 'rgba(255,255,255,0.95)';
        const subTextColor = lightColors.includes(c) ? 'rgba(0,0,0,0.5)' : 'rgba(255,255,255,0.5)';
        tile.style.color = textColor;
        const used  = isHuman ? 'â€”' : `${10-G.decks[c].length}/10`;
        const mode  = (!isHuman && G.coins[c]<=4)
            ? '<span class="coin-threshold mode-tax">TAX</span>'
            : '<span class="coin-threshold mode-spend">SPEND</span>';
        tile.innerHTML = `
            <div class="p-name"><span class="crown-badge" onclick="setFirst('${c}')" title="KING ME: set as next First Player">ðŸª™</span>${c.toUpperCase()}${G.savedByCrown?.has(c)?' <span title="Saved by the Crown â€” must reclaim a city this round" style="font-size:0.75em;color:#b8860b;">âš  GRACE</span>':''}${G.eliminated?.has(c)?' <span style="font-size:0.75em;color:#8b1a1a;">ðŸ’€</span>':''}</div>
            <div class="coin-row">
                <button class="coin-btn" onclick="addCoin('${c}',-1)">âˆ’</button>
                <span class="coin-count">${G.coins[c]}</span>
                <button class="coin-btn" onclick="addCoin('${c}',+1)">+</button>
            </div>
            <div class="coin-row" style="margin-top:2px;">
                ${isHuman ? `<button class="coin-btn" onclick="addCrown('${c}',-1)">âˆ’</button>` : '<span style="width:18px"></span>'}
                <span title="Crowns" style="font-size:0.75em;letter-spacing:0.02em;">ðŸ‘‘${G.crowns[c]||0}</span>
                ${isHuman ? `<button class="coin-btn" onclick="addCrown('${c}',+1)">+</button>` : '<span style="width:18px"></span>'}
            </div>
            ${isHuman ? `<span style="font-size:0.58em;color:${subTextColor};">YOU</span>` : mode}
            <div class="deck-pip">${used}</div>`;
        bar.appendChild(tile);
    });

    document.getElementById('round-display').textContent = `ROUND ${G.round}`;
    document.getElementById('step-display').textContent  = `ACTION ${G.step} of 2`;

    const isHuman = active===S.playerColor;
    document.getElementById('ai-view').style.display    = isHuman ? 'none' : 'block';
    document.getElementById('human-view').style.display = isHuman ? 'block' : 'none';

    if (isHuman) {
        renderHumanTurn();
        document.getElementById('steps-panel').style.display = 'none';
    } else if (!G.revealed) {
        const cardEl = document.getElementById('card-display');
        cardEl.className = 'action-card unrevealed';
        cardEl.innerHTML = `Tap button to reveal<br><span class="card-sub">${cName(active)}'s card is face-down</span>`;
        const revBtn = document.getElementById('reveal-btn');
        if(revBtn) revBtn.style.display='block';
        document.getElementById('steps-panel').style.display='none';
        document.getElementById('complete-btn').disabled = true;
    } else {
        // AI turn, card revealed â€” always re-render steps panel
        // (handles case where render() is called after reveal without re-generating steps)
        if (G.currentSteps && G.currentSteps.length > 0) {
            renderSteps();
        } else {
            // Steps missing entirely â€” regenerate defensively
            const card = G.hand[active]?.[G.step-1];
            if (card) regenerateSteps(card, active);
        }
    }
}


// ================================================================
// BOARD EDITOR
// ================================================================
let BE = { step:'list', fromTerr:null, destTerr:null, moveCount:1 };

function openBoardEditor(focusColor) {
    BE = { step:'list', fromTerr:null, destTerr:null,
           moveUnits:{F:0,A:0,C:0,S:0},
           movedFrom: BE?.movedFrom || new Set() }; // cleared each turn in advanceTurn()
    const validColors = ['orange','green','purple','blue','neutral'];
    const resolved = (focusColor && validColors.includes(focusColor)) ? focusColor
        : (activeColor ? activeColor() : null) || S.playerColor || 'orange';
    BE.color = resolved;
    document.getElementById('board-overlay').classList.add('open');
    renderBoardEditor();
}

function closeBoardEditor() {
    document.getElementById('board-overlay').classList.remove('open');
    render();
    // Auto-check the board step if opened from human turn
    const isHumanTurn = S.playerColor && activeColor && activeColor() === S.playerColor;
    if (isHumanTurn && G._htBoardStep !== undefined) {
        G.humanBoardUpdated = true;
        G.humanTurnChecks = G.humanTurnChecks || new Set();
        G.humanTurnChecks.add(G._htBoardStep);
        G._htBoardStep = undefined;
        renderHumanTurn();
    }
}

function beUnitStr(u) {
    const p = [];
    if ((u.C||0)>0) p.push(u.C+'C');
    if ((u.A||0)>0) p.push(u.A+'A');
    if ((u.F||0)>0) p.push(u.F+'F');
    if ((u.S||0)>0) p.push(u.S+'S');
    return p.join(' + ') || 'â€”';
}

function renderBoardEditor() {
    const bs = (G.board && Object.keys(G.board).length > 0) ? G.board
        : Object.fromEntries(Object.keys(T).map(n=>[n,{owner:'neutral',units:{F:0,A:0,C:0,S:0},castle:false}]));

    const color = BE.color;
    const isPlayer = color === S.playerColor;
    const colorLabel = isPlayer ? 'YOUR' : color.charAt(0).toUpperCase()+color.slice(1)+"'s";
    document.getElementById('board-modal-title').textContent = colorLabel + ' Territories';

    if (BE.step === 'list') renderBEList(bs, color);
    else if (BE.step === 'move') renderBEMove(bs, color);
    else if (BE.step === 'full') renderBEFull(bs);
}


// â”€â”€ Supply Line Movement â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Returns all territories reachable through a chain of own territories
// (and one step beyond into enemy/neutral for attack/settle)
// depth: how many hops through own territory are allowed (MANEUVER = unlimited chain)
function getSupplyLineTerritories(fromName, color, includeEnemy=true) {
    const visited = new Set([fromName]);
    const ownChain = new Set([fromName]); // territories in own supply line
    const queue = [fromName];
    // BFS through own territories to find full supply line
    while (queue.length) {
        const cur = queue.shift();
        for (const adj of (T[cur]?.adj || [])) {
            if (!visited.has(adj) && G.board[adj]?.owner === color) {
                visited.add(adj);
                ownChain.add(adj);
                queue.push(adj);
            }
        }
    }
    // Now find all territories adjacent to any node in ownChain that are not own
    const destinations = new Map(); // name -> {type, hops}
    for (const own of ownChain) {
        for (const adj of (T[own]?.adj || [])) {
            if (ownChain.has(adj)) continue; // already own
            if (!T[adj]) continue;
            const owner = G.board[adj]?.owner || 'neutral';
            if (!destinations.has(adj) || true) {
                destinations.set(adj, { name: adj, via: own, type: owner === 'neutral' ? 'neutral' : owner === color ? 'own' : 'enemy' });
            }
        }
    }
    // Also include own chain members that are not the source (for repositioning)
    for (const own of ownChain) {
        if (own === fromName) continue;
        if (!destinations.has(own)) {
            destinations.set(own, { name: own, via: own, type: 'friendly' });
        }
    }
    return Array.from(destinations.values());
}

// â”€â”€ STEP 1: territory list â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderBEList(bs, color) {
    const owned = Object.keys(bs)
        .filter(n => bs[n].owner === color)
        .sort((a,b) => (T[b]?.tax||0)-(T[a]?.tax||0) || a.localeCompare(b));

    const content = document.getElementById('board-content');

    if (!owned.length) {
        content.innerHTML = `<p style="padding:20px;text-align:center;color:var(--ink-light);">No territories owned yet.</p>
            <button class="btn-full-board" onclick="BE.step='full';renderBoardEditor()">
                ðŸ—º View Entire Board State
            </button>`;
        return;
    }

    const rows = owned.map(name => {
        const b = bs[name];
        const u = b.units;
        const total = unitTotal(u);
        const leaveN = leaveBehindPlayer(name);
        const movable = movableCountPlayer(name);
        const taxStr = T[name]?.tax > 0 ? `Tax ${T[name].tax}  Â·  ` : '';
        const castleStr = b.castle ? 'ðŸ°  Â·  ' : '';
        const unitSummary = beUnitStr(u);
        const canMove = movable > 0;

        const hasMoved = BE.movedFrom && BE.movedFrom.has(name);
        const rowCls = hasMoved ? 'be-moved' : (!canMove ? 'be-terr-dim' : '');
        const clickable = canMove && !hasMoved;
        return `<li class="be-terr-item ${rowCls}" onclick="${clickable?`bePickFrom('${name}')`:''}" >
            <div>
                <div class="bt-name">${name}</div>
                <div class="bt-sub">${castleStr}${taxStr}${unitSummary}</div>
            </div>
            <div style="text-align:right">
                ${hasMoved
                    ? `<div class="bt-badge" style="color:#aaa">âœ“ moved</div>`
                    : canMove
                        ? `<div class="bt-badge"><b>${movable}</b> movable</div><div class="bt-arrow">â€º</div>`
                        : `<div class="bt-badge" style="color:#aaa">must leave ${leaveN}</div>`
                }
            </div>
        </li>`;
    }).join('');

    content.innerHTML = `<ul class="be-terr-list">${rows}</ul>
        <button class="btn-full-board" onclick="BE.step='full';renderBoardEditor()">
            ðŸ—º View Entire Board State
        </button>`;
}

// â”€â”€ STEP 2: pick destination + count â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderBEMove(bs, color) {
    const from = BE.fromTerr;
    if (!from || !bs[from]) { BE.step='list'; renderBoardEditor(); return; }

    const b = bs[from];
    const total = unitTotal(b.units);
    const leaveN = leaveBehindPlayer(from);
    const maxMove = movableCountPlayer(from);
    const unitSummary = beUnitStr(b.units);
    const taxStr = T[from]?.tax > 0 ? `Tax ${T[from].tax}  Â·  ` : '';
    const castleStr = b.castle ? 'ðŸ°  Â·  ' : '';

    // Adjacent territories
    const adjs = (T[from]?.adj || []).filter(n => bs[n]);
    const destRows = adjs.map(name => {
        const ab = bs[name];
        const adjTotal = unitTotal(ab.units);
        const isOwn = ab.owner === color;
        const isEnemy = !isOwn && ab.owner !== 'neutral';
        const isNeutral = ab.owner === 'neutral';
        const dotColor = COLOR_HEX[ab.owner] || '#aaa';
        const ownerLabel = isOwn ? 'Friendly' : isEnemy ? ab.owner.charAt(0).toUpperCase()+ab.owner.slice(1) : 'Neutral';
        const taxStr2 = T[name]?.tax > 0 ? ` Â· Tax ${T[name].tax}` : '';
        const castleIcon = ab.castle ? ' ðŸ°' : '';
        const cls = isEnemy ? 'is-enemy' : isOwn ? 'is-friendly' : '';
        const selCls = BE.destTerr === name ? 'sel' : '';

        return `<div class="be-dest-item ${cls} ${selCls}" onclick="bePickDest('${name}')">
            <div class="be-dest-dot" style="background:${dotColor}"></div>
            <div class="be-dest-info">
                <div class="be-dest-name">${name}${castleIcon}</div>
                <div class="be-dest-sub">${ownerLabel}${taxStr2} Â· ${adjTotal} unit${adjTotal!==1?'s':''}</div>
            </div>
            ${BE.destTerr===name ? '<span style="color:var(--accent);font-size:1.2em;font-weight:700;">âœ“</span>' : ''}
        </div>`;
    }).join('');

    // Per-unit-type picker (only when dest selected)
    let countBox = '';
    if (BE.destTerr) {
        const destB = bs[BE.destTerr];
        const isAttack = destB && destB.owner !== color && destB.owner !== 'neutral';
        const hasCastle = destB?.castle;
        const u = b.units;
        // Available per type = what's in territory minus what must stay (leave 1 total)
        // We enforce: sum of moved â‰¤ maxMove, and at least 1 unit stays
        const mu = BE.moveUnits;
        const totalMoving = (mu.F||0)+(mu.A||0)+(mu.C||0)+(mu.S||0);
        const attackWarn = isAttack && hasCastle
            ? `<div style="color:var(--accent);font-size:0.8em;margin:6px 0;">âš  Has castle â€” you need a Siege Engine to attack.</div>`
            : isAttack
                ? `<div style="color:var(--accent);font-size:0.8em;margin:6px 0;">Attacking â€” ${totalMoving} unit${totalMoving!==1?'s':''} vs ${unitTotal(destB.units)} defenders.</div>`
                : '';

        const unitNames = {C:'Cavalry',A:'Archer',F:'Footman',S:'Siege'};
        const unitRows = ['C','A','F','S'].map(k => {
            const avail = u[k]||0;
            if (avail === 0) return ''; // hide types with none
            const moving = mu[k]||0;
            // Can add more of this type if: avail remaining > 0 AND total won't exceed maxMove
            const canAdd = moving < avail && totalMoving < maxMove;
            const canSub = moving > 0;
            return `<div class="unit-type-row ${avail===0?'zero':''}">
                <div>
                    <div class="ut-label">${unitNames[k]}</div>
                    <div class="ut-avail">${avail} available</div>
                </div>
                <div class="ut-stepper">
                    <button class="ut-btn" onclick="beAdjUnit('${k}',-1)" ${canSub?'':'disabled'}>âˆ’</button>
                    <span class="ut-val">${moving}</span>
                    <button class="ut-btn" onclick="beAdjUnit('${k}',1)" ${canAdd?'':'disabled'}>+</button>
                </div>
            </div>`;
        }).filter(Boolean).join('');

        countBox = `<div class="be-count-box">
            <div class="be-count-label">Choose which units to move from <b>${from}</b><br>
                <span style="font-size:0.85em;">Must leave at least 1 unit behind Â· max ${maxMove} movable</span>
            </div>
            <div class="unit-type-grid">${unitRows}</div>
            ${attackWarn}
            <button class="be-confirm-btn" onclick="beConfirmMove()" ${totalMoving>0?'':'disabled'}>
                âœ“ Move ${totalMoving} unit${totalMoving!==1?'s':''} â†’ ${BE.destTerr}
            </button>
        </div>`;
    }

    // Corrections panel â€” owner + castle
    const ownerDots = ['orange','green','purple','blue','neutral'].map(c => {
        const bg = COLOR_HEX[c]||'#aaa';
        const sel = b.owner === c ? 'sel' : '';
        return `<button class="be-odot ${sel}" style="background:${bg}" title="${c}"
            onclick="event.stopPropagation();beSetOwner('${from}','${c}')"></button>`;
    }).join('');
    const castleCls = b.castle ? 'be-castle-btn on' : 'be-castle-btn';
    const castleLbl = b.castle ? 'ðŸ° Remove Castle' : '+ Add Castle';

    const corrections = `<div class="be-corrections">
        <div class="be-corr-title">Correct this territory</div>
        <div class="be-owner-row">
            <span>Owner:</span>${ownerDots}
        </div>
        <button class="${castleCls}" onclick="event.stopPropagation();beToggleCastle('${from}')">${castleLbl}</button>
    </div>`;

    document.getElementById('board-content').innerHTML = `
        <button class="be-back-btn" onclick="BE.step='list';BE.fromTerr=null;BE.destTerr=null;renderBoardEditor()">â€¹ Back to your territories</button>
        <div class="be-from-banner">
            <div class="bfb-name">${from}${b.castle?' ðŸ°':''}</div>
            <div class="bfb-units">${castleStr}${taxStr}${unitSummary} Â· ${maxMove} movable</div>
        </div>
        <div class="be-dest-label">Move to which adjacent territory?</div>
        <div class="be-dest-list">${destRows}</div>
        ${countBox}
        ${corrections}
    `;
}

// â”€â”€ Actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€ FULL BOARD VIEW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderBEFull(bs) {
    document.getElementById('board-modal-title').textContent = 'Full Board State';
    const colors = ['orange','green','purple','blue'];
    const allColors = [...colors, 'neutral'];

    function unitStr(u) {
        const p = [];
        if ((u.C||0)>0) p.push(u.C+'C');
        if ((u.A||0)>0) p.push(u.A+'A');
        if ((u.F||0)>0) p.push(u.F+'F');
        if ((u.S||0)>0) p.push(u.S+'S');
        return p.join('+') || 'â€”';
    }

    const sections = allColors.map(c => {
        const territories = Object.keys(bs)
            .filter(n => bs[n].owner === c)
            .sort((a,b) => (T[b]?.tax||0)-(T[a]?.tax||0) || a.localeCompare(b));

        const bg = c === 'neutral' ? '#888' : (COLOR_HEX[c] || '#888');
        const txt = ['orange','green','blue'].includes(c) ? '#000' : '#fff';
        const label = c === S.playerColor ? c.toUpperCase()+' (YOU)' : c.toUpperCase();
        const totalUnits = territories.reduce((sum,n)=>sum+unitTotal(bs[n].units),0);

        const rows = territories.length
            ? territories.map(name => {
                const b = bs[name];
                const tax = T[name]?.tax > 0 ? `Tax ${T[name].tax}` : 'non-urban';
                const castle = b.castle ? ' ðŸ°' : '';
                const units = unitStr(b.units);
                const total = unitTotal(b.units);
                const pendingBattle = (G.roundCombats||[]).find(b => b.to === name && !b._resolved);
                const pendingTag = pendingBattle
                    ? `<span style="color:#8b1a1a;font-size:0.75em;font-weight:700;margin-left:4px;">âš” ${pendingBattle.color} attacking</span>`
                    : '';
                return `<div class="fbs-row" onclick="openTerrEdit('${name.replace(/'/g,"\\'")}')" style="cursor:pointer;" title="Click to edit">
                    <div class="fr-name" style="color:var(--accent);text-decoration:underline dotted;">${name}${castle}${pendingTag}</div>
                    <div class="fr-sub">${tax}</div>
                    <div class="fr-units">${units} <span style="color:var(--ink-light)">(${total})</span></div>
                </div>`;
            }).join('')
            : `<div class="fbs-empty">No territories</div>`;

        return `<div class="fbs-section">
            <div class="fbs-section-hdr" style="background:${bg};color:${txt};">
                ${label} &nbsp;Â·&nbsp; ${territories.length} territories &nbsp;Â·&nbsp; ${totalUnits} units
            </div>
            ${rows}
        </div>`;
    }).join('');

    document.getElementById('board-content').innerHTML =
        `<button class="fbs-back-btn" onclick="BE.step='list';renderBoardEditor()">â€¹ Back</button>` +
        sections;
}

function bePickFrom(name) {
    BE.fromTerr = name;
    BE.destTerr = null;
    BE.moveUnits = {F:0,A:0,C:0,S:0};
    BE.step = 'move';
    renderBoardEditor();
}

function bePickDest(name) {
    BE.destTerr = name;
    const bs = G.board;
    const total = unitTotal(bs[BE.fromTerr]?.units || {});
    const leaveN = leaveBehindPlayer(BE.fromTerr);
    const maxMove = Math.max(1, movableCountPlayer(BE.fromTerr));
    BE.moveCount = Math.min(BE.moveCount, maxMove);
    renderBoardEditor();
}

function beAdjUnit(k, v) {
    if (!BE.moveUnits) BE.moveUnits = {F:0,A:0,C:0,S:0};
    const avail = G.board[BE.fromTerr]?.units[k] || 0;
    const maxMove = movableCountPlayer(BE.fromTerr);
    const totalMoving = (BE.moveUnits.F||0)+(BE.moveUnits.A||0)+(BE.moveUnits.C||0)+(BE.moveUnits.S||0);
    if (v > 0) {
        // Adding: check this type has room and total won't exceed max
        if (BE.moveUnits[k] < avail && totalMoving < maxMove) BE.moveUnits[k]++;
    } else {
        if (BE.moveUnits[k] > 0) BE.moveUnits[k]--;
    }
    renderBoardEditor();
}

function beConfirmMove() {
    const from = BE.fromTerr, to = BE.destTerr;
    if (!from || !to || !G.board[from] || !G.board[to]) return;
    const mu = BE.moveUnits || {};
    const count = (mu.F||0)+(mu.A||0)+(mu.C||0)+(mu.S||0);
    if (count <= 0) return;

    const destOwner    = G.board[to].owner;
    const destUnitCnt  = unitTotal(G.board[to].units);
    const isEnemy      = destOwner !== BE.color && destOwner !== 'neutral' && destUnitCnt > 0;

    const desc = ['C','A','F','S']
        .filter(k=>(mu[k]||0)>0)
        .map(k=>mu[k]+({C:'Cav',A:'Arc',F:'Ft',S:'Sie'}[k]))
        .join('+');

    if (isEnemy) {
        // â”€â”€ ENEMY TERRITORY: queue battle exactly like automaton moves â”€â”€
        // Units stay at origin until Combat Phase resolves the fight.
        // roundCombats stores movingUnits so resolveAutoBattle / csFinalize
        // knows exactly which units are committed to the attack.
        if (!G.roundCombats) G.roundCombats = [];
        const already = G.roundCombats.some(c => c.from===from && c.to===to && c.color===BE.color);
        if (!already) {
            G.roundCombats.push({
                color: BE.color,
                from,
                to,
                movingUnits: { ...mu },
                movable: count,
                isEnemy: true,
                _fromEditor: true
            });
        }
        addLog(`âš” Battle queued: ${BE.color} will attack ${to} (${destOwner}) with ${desc} from ${from} â€” resolve in Combat Phase.`);
    } else {
        // â”€â”€ FRIENDLY / NEUTRAL MOVE: apply immediately â”€â”€
        for (const k of ['F','A','C','S']) {
            G.board[from].units[k] = Math.max(0, (G.board[from].units[k]||0) - (mu[k]||0));
        }
        for (const k of ['F','A','C','S']) {
            G.board[to].units[k] = (G.board[to].units[k]||0) + (mu[k]||0);
        }
        if (G.board[to].owner === 'neutral') G.board[to].owner = BE.color;
        addLog(`Board: ${BE.color} moves ${desc} from ${from} â†’ ${to}.`);
    }

    if (!BE.movedFrom) BE.movedFrom = new Set();
    BE.movedFrom.add(from);
    BE.step = 'list'; BE.fromTerr = null; BE.destTerr = null; BE.moveUnits = {F:0,A:0,C:0,S:0};
    renderBoardEditor();
}

function beSetOwner(name, color) {
    // Inline owner correction â€” same as edit modal, direct update
    if (!G.board[name]) return;
    G.board[name].owner = color;
    if (color === 'neutral') G.board[name].units = {F:0,A:0,C:0,S:0};
    if (CITY_SHIELDS[name]) {
        if (!G.shields) G.shields = {};
        if (color !== 'neutral') G.shields[name] = color;
        else delete G.shields[name];
    }
    renderBoardEditor();
}
function beToggleCastle(name) {
    if (G.board[name]) { G.board[name].castle = !G.board[name].castle; renderBoardEditor(); }
}
// ================================================================
// COMBAT SUBSYSTEM
// ================================================================
const DFACES = ['âš€','âš','âš‚','âšƒ','âš„','âš…'];

// CS = Combat State
let CS = {};

function csReset() {
    CS = {
        active:false, attackerColor:null, defenderColor:null,
        fromTerr:null, toTerr:null,
        attUnits:null, defUnits:null,   // {F,A,C,S} â€” updated each phase
        phase:null,     // 'siege'|'archer'|'main'|'result'
        log:[],         // round history strings
        humanAtt:false, humanDef:false,
        humanHits:0, humanReady:false,
        autoRollsAtt:null, autoRollsDef:null,
        pendingStepIdx:-1,
        retreated:false,
    };
}
csReset();

// â”€â”€ helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function csTotal(u){ return (u.F||0)+(u.A||0)+(u.C||0)+(u.S||0); }
function csStr(u){
    const p=[];
    if(u.C>0) p.push(u.C+'Cav');
    if(u.A>0) p.push(u.A+'Arc');
    if(u.F>0) p.push(u.F+'Ft');
    if(u.S>0) p.push(u.S+'Sie');
    return p.length?p.join('+'):'0';
}
function csDice(u,phase){
    if(phase==='siege')  return (u.S||0)*2;           // 2 dice per siege engine (attacker only, vs castle)
    if(phase==='archer') return (u.A||0);              // 1 die per archer
    if(phase==='main')   return (u.C||0)*2+(u.F||0)+(u.A||0)+(u.S||0); // Cav=2, all others=1
    return 0;
}
function csRollN(n){ return Array.from({length:n},()=>{ const v=Math.floor(Math.random()*6)+1; return {v,hit:v>=4,f:DFACES[v-1]}; }); }
function csRemove(u,hits){
    const r={...u}; let rem=hits;
    for(const k of ['F','A','S','C']){ const t=Math.min(r[k]||0,rem); r[k]=(r[k]||0)-t; rem-=t; }
    return r;
}
function csDiff(before,after){
    const d={};
    for(const k of ['F','A','C','S']) d[k]=(before[k]||0)-(after[k]||0);
    return d;
}
function csDescLost(d){
    const p=[];
    if(d.C>0) p.push(d.C+' Cavalry');
    if(d.A>0) p.push(d.A+' Archer'+(d.A>1?'s':''));
    if(d.F>0) p.push(d.F+' Footm'+(d.F>1?'en':'an'));
    if(d.S>0) p.push(d.S+' Siege Engine'+(d.S>1?'s':''));
    return p.length?p.join(', '):'none';
}
function sideColor(color){ return color===S.playerColor?'You ('+color.toUpperCase()+')':color.toUpperCase(); }
function tileStyle(color){
    const bg=COLOR_HEX[color]||'#777';
    const txt=(color==='blue'||color==='green')?'#000':'#fff';
    return 'background:'+bg+';color:'+txt;
}

// â”€â”€ OPEN COMBAT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function openCombat(attackerColor, defenderColor, fromTerr, toTerr, stepIdx){
    if(!G.board[fromTerr]||!G.board[toTerr]){
        console.warn('openCombat: territory not found in board state', fromTerr, toTerr);
        if(stepIdx >= 0) G.checkedSteps.add(stepIdx);
        const total = G.currentSteps.filter(s=>s!==null).length;
        document.getElementById('complete-btn').disabled = (G.checkedSteps.size < total);
        renderSteps();
        return;
    }
    csReset();
    CS.active=true;
    CS.attackerColor=attackerColor; CS.defenderColor=defenderColor;
    CS.fromTerr=fromTerr; CS.toTerr=toTerr;
    // '__editor__' battles: attacker units come from the roundCombats entry, not a territory
    if (fromTerr === '__editor__') {
        const entry = (G.roundCombats||[]).find(b => b._fromEditor && b.to===toTerr && b.color===attackerColor && !b._resolved);
        CS.attUnits = entry?.movingUnits ? {...entry.movingUnits} : {F:1,A:0,C:0,S:0};
        CS._fromEditor = true;
    } else {
        CS.attUnits={...G.board[fromTerr].units};
    }
    CS.defUnits={...G.board[toTerr].units};
    CS.humanAtt=(attackerColor===S.playerColor);
    CS.humanDef=(defenderColor===S.playerColor);
    CS.pendingStepIdx=stepIdx;
    document.getElementById('combat-title').textContent='COMBAT: '+fromTerr+' â†’ '+toTerr;

    // Determine starting phase
    const hasCastle=G.board[toTerr].castle;
    const hasSiege=(CS.attUnits.S||0)>0;
    const hasArchers=(CS.attUnits.A||0)>0||(CS.defUnits.A||0)>0;
    if(hasCastle && hasSiege) CS.phase='siege';
    else if(hasArchers) CS.phase='archer';
    else CS.phase='main';

    const autoOnly=!CS.humanAtt && !CS.humanDef;
    if(autoOnly){
        runAutoCombat();
    } else {
        document.getElementById('combat-overlay').classList.add('open');
        preparePhase();
        renderCombatUI();
    }
}

// â”€â”€ AUTO-ONLY (automa vs automa) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function runAutoCombat(){
    const log=[];
    let att={...CS.attUnits}, def={...CS.defUnits};
    log.push('Att: '+sideColor(CS.attackerColor)+' ['+csStr(att)+'] vs Def: '+sideColor(CS.defenderColor)+' ['+csStr(def)+']');

    // Siege
    if(CS.phase==='siege'){
        const r=csRollN(csDice(att,'siege'));
        const h=r.filter(d=>d.hit).length;
        const b={...def}; def=csRemove(def,h);
        log.push('âš™ SIEGE: '+r.map(d=>d.f).join('')+' â†’ '+h+' hits â†’ defender loses '+csDescLost(csDiff(b,def)));
        const hasArch=(att.A||0)>0||(def.A||0)>0;
        CS.phase=hasArch?'archer':'main';
    }
    // Archers
    if(CS.phase==='archer'){
        const ra=csRollN(csDice(att,'archer')), rd=csRollN(csDice(def,'archer'));
        const ha=ra.filter(d=>d.hit).length, hd=rd.filter(d=>d.hit).length;
        const ba={...att}, bd={...def};
        def=csRemove(def,ha); att=csRemove(att,hd);
        log.push('ðŸ¹ ARCHERS: Att '+ra.map(d=>d.f).join('')+'='+ha+'h | Def '+rd.map(d=>d.f).join('')+'='+hd+'h');
        if(ha>0) log.push('  Def loses: '+csDescLost(csDiff(bd,def)));
        if(hd>0) log.push('  Att loses: '+csDescLost(csDiff(ba,att)));
        CS.phase='main';
    }
    // Main rounds
    let rnd=0;
    while(csTotal(att)>0 && csTotal(def)>0 && rnd<12){
        rnd++;
        const ra=csRollN(csDice(att,'main')), rd=csRollN(csDice(def,'main'));
        const ha=ra.filter(d=>d.hit).length, hd=rd.filter(d=>d.hit).length;
        const ba={...att}, bd={...def};
        def=csRemove(def,ha); att=csRemove(att,hd);
        log.push('âš” R'+rnd+': Att ['+ra.map(d=>d.f).join('')+']='+ha+'hâ†’Def loses '+csDescLost(csDiff(bd,def))+
                 ' | Def ['+rd.map(d=>d.f).join('')+']='+hd+'hâ†’Att loses '+csDescLost(csDiff(ba,att)));
        log.push('  Remaining â€” Att:'+csStr(att)+' Def:'+csStr(def));
    }

    const won=csTotal(att)>0 && csTotal(def)===0;
    log.push(won
        ? 'âœ“ '+CS.attackerColor.toUpperCase()+' captures '+CS.toTerr+'! ('+csStr(att)+' remain)'
        : 'âœ— Defender holds '+CS.toTerr+' ('+csStr(def)+' remain)');

    // Apply board
    csFinalize(won, att, def);
    addLog('Auto-combat: '+(won?CS.attackerColor+' captures '+CS.toTerr:CS.defenderColor+' holds '+CS.toTerr));

    // Show result overlay
    document.getElementById('combat-overlay').classList.add('open');
    document.getElementById('combat-phase-label').textContent='AUTO-RESOLVED';
    document.getElementById('combat-body').innerHTML=
        '<div class="result-banner '+(won?'win':'loss')+'">'+log[log.length-1]+'</div>'+
        '<div class="auto-log" id="alog">'+log.map(l=>'<div class="al">'+l+'</div>').join('')+'</div>'+
        '<button class="btn-fight" onclick="closeCombat()">âœ“ CLOSE â€” Continue Turn</button>';
    setTimeout(()=>{ const e=document.getElementById('alog'); if(e) e.scrollTop=e.scrollHeight; },50);
}

// â”€â”€ INTERACTIVE COMBAT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function preparePhase(){
    CS.autoRollsAtt=null; CS.autoRollsDef=null; CS.humanHits=0; CS.humanReady=false;
    if(CS.phase==='siege'){
        if(!CS.humanAtt) CS.autoRollsAtt=csRollN(csDice(CS.attUnits,'siege'));
        // Human attacker with 0 siege engines: no dice to roll, pre-ready
        if(CS.humanAtt && csDice(CS.attUnits,'siege')===0) CS.humanReady=true;
    } else if(CS.phase==='archer'){
        if(!CS.humanAtt && (CS.attUnits.A||0)>0) CS.autoRollsAtt=csRollN(csDice(CS.attUnits,'archer'));
        if(!CS.humanDef && (CS.defUnits.A||0)>0) CS.autoRollsDef=csRollN(csDice(CS.defUnits,'archer'));
        // Human side with 0 archers: pre-ready (other side's archers may still fire)
        if(CS.humanAtt && csDice(CS.attUnits,'archer')===0) CS.humanReady=true;
        if(CS.humanDef && csDice(CS.defUnits,'archer')===0) CS.humanReady=true;
    } else if(CS.phase==='main'){
        if(!CS.humanAtt) CS.autoRollsAtt=csRollN(csDice(CS.attUnits,'main'));
        if(!CS.humanDef) CS.autoRollsDef=csRollN(csDice(CS.defUnits,'main'));
        // Human side with 0 combat units: pre-ready (they're about to lose)
        if(CS.humanAtt && csDice(CS.attUnits,'main')===0) CS.humanReady=true;
        if(CS.humanDef && csDice(CS.defUnits,'main')===0) CS.humanReady=true;
    }
}

function renderCombatUI(){
    const phaseNames={siege:'SIEGE PRE-BATTLE',archer:'ARCHER VOLLEY',main:'MAIN COMBAT â€” ROUND '+(CS.log.filter(l=>l.startsWith('âš”')).length+1),result:'RESULT'};
    document.getElementById('combat-phase-label').textContent=phaseNames[CS.phase]||CS.phase.toUpperCase();

    if(CS.phase==='result'){ renderResult(); return; }

    const attTotal=csTotal(CS.attUnits), defTotal=csTotal(CS.defUnits);
    const castleIcon=G.board[CS.toTerr]?.castle?' ðŸ°':'';

    // Sides header
    const sidesHTML=
        '<div class="combat-sides-row">'+
            '<div class="combat-side" style="'+tileStyle(CS.attackerColor)+'">'+
                '<div class="sl">ATTACKER</div>'+
                '<div class="sn">'+sideColor(CS.attackerColor)+'<br><span style="font-weight:400;font-size:0.85em;">'+CS.fromTerr+'</span></div>'+
                '<div class="su">'+csStr(CS.attUnits)+' ('+attTotal+' total)</div>'+
            '</div>'+
            '<div class="combat-vs">âš”</div>'+
            '<div class="combat-side" style="'+tileStyle(CS.defenderColor)+'">'+
                '<div class="sl">DEFENDER'+castleIcon+'</div>'+
                '<div class="sn">'+sideColor(CS.defenderColor)+'<br><span style="font-weight:400;font-size:0.85em;">'+CS.toTerr+'</span></div>'+
                '<div class="su">'+csStr(CS.defUnits)+' ('+defTotal+' total)</div>'+
            '</div>'+
        '</div>';

    // Phase explanation
    const explainMap={
        siege:'<b>SIEGE PRE-BATTLE:</b> Siege Engines fire first. Each Siege Engine rolls 2 dice (hit on 4+). Only the defender takes hits â€” archers and main combat come after.',
        archer:'<b>ARCHER VOLLEY:</b> Both sides\' archers fire simultaneously before main combat. Each archer rolls 1 die (hit on 4+). Both sides remove casualties at the same time.',
        main:'<b>MAIN COMBAT:</b> Both sides fight simultaneously. Each Cavalry unit rolls 2 dice, each Footman rolls 1 die. Hit on 4+. Both sides apply hits simultaneously.',
    };
    const explainHTML='<div class="info-box" style="margin-bottom:10px;">'+explainMap[CS.phase]+'</div>';

    // Round log
    const logHTML=CS.log.length?
        '<div class="round-log">'+CS.log.map(l=>'<div class="round-log-entry">'+l+'</div>').join('')+'</div>':'';

    // Dice sections
    function diceHTML(rolls, label){
        if(!rolls||!rolls.length) return '';
        const hits=rolls.filter(d=>d.hit).length;
        return '<div class="dice-section"><h5>'+label+'</h5>'+
            '<div class="dice-row">'+
            rolls.map(d=>'<div class="die-face '+(d.hit?'hit':'miss')+'">'+d.f+'</div>').join('')+
            '&nbsp;<span class="hits-summary '+(hits>0?'some':'none')+'">= '+hits+' hit'+(hits!==1?'s':'')+'</span>'+
            '</div></div>';
    }
    function humanHTML(diceCount, label){
        if(!diceCount) return '';
        return '<div class="human-roll-box"><h5>âš” YOUR ROLL â€” '+label+'</h5>'+
            '<div>Roll <span class="dice-count-big">'+diceCount+'</span> dice &nbsp;&nbsp;<b>Hit on 4, 5, or 6</b></div>'+
            '<div class="hit-input-row">'+
                '<span>Your hits:</span>'+
                '<button class="hs-btn" onclick="csAdjHits(-1)">âˆ’</button>'+
                '<span class="hs-val" id="hs-val">'+CS.humanHits+'</span>'+
                '<button class="hs-btn" onclick="csAdjHits(1)">+</button>'+
                '<span style="color:var(--ink-light);font-size:0.85em;">(max '+diceCount+')</span>'+
            '</div>'+
            (CS.humanReady?'<div style="color:#1e7e44;font-size:0.85em;margin-top:6px;">âœ“ '+CS.humanHits+' hit'+(CS.humanHits!==1?'s':'')+'  recorded â€” tap Apply Hits to continue.</div>':'')+
        '</div>';
    }

    // Determine what to show per side per phase
    let attSection='', defSection='';
    if(CS.phase==='siege'){
        attSection=CS.humanAtt?humanHTML(csDice(CS.attUnits,'siege'),'Siege Engine (attacker)'):diceHTML(CS.autoRollsAtt,CS.attackerColor.toUpperCase()+' Siege Engine rolls');
        // No defender dice in siege phase
    } else if(CS.phase==='archer'){
        if((CS.attUnits.A||0)>0) attSection=CS.humanAtt?humanHTML(csDice(CS.attUnits,'archer'),'Archers (attacker)'):diceHTML(CS.autoRollsAtt,CS.attackerColor.toUpperCase()+' Archers roll');
        if((CS.defUnits.A||0)>0) defSection=CS.humanDef?humanHTML(csDice(CS.defUnits,'archer'),'Archers (defender)'):diceHTML(CS.autoRollsDef,CS.defenderColor.toUpperCase()+' Archers roll');
    } else if(CS.phase==='main'){
        attSection=CS.humanAtt?humanHTML(csDice(CS.attUnits,'main'),'Main combat (attacker)'):diceHTML(CS.autoRollsAtt,CS.attackerColor.toUpperCase()+' rolls');
        defSection=CS.humanDef?humanHTML(csDice(CS.defUnits,'main'),'Main combat (defender)'):diceHTML(CS.autoRollsDef,CS.defenderColor.toUpperCase()+' rolls');
    }

    // Only block if human has dice to roll this specific phase
    const humanDiceAtt = CS.humanAtt ? csDice(CS.attUnits, CS.phase==='siege'?'siege':CS.phase==='archer'?'archer':'main') : 0;
    const humanDiceDef = CS.humanDef ? csDice(CS.defUnits, CS.phase==='archer'?'archer':CS.phase==='main'?'main':0) : 0;
    const needsInput = (humanDiceAtt > 0 || humanDiceDef > 0);
    const btnLabel=CS.phase==='main'?'APPLY HITS â€” NEXT ROUND':'APPLY HITS â€” CONTINUE';
    const canApply=!needsInput||CS.humanReady;

    const btnsHTML='<div class="combat-btn-row">'+
        '<button class="btn-fight" id="cs-apply-btn" onclick="csApply()" '+(canApply?'':'disabled')+'>'+
            (canApply?btnLabel:'Enter your hits above first â†’')+
        '</button>'+
        (CS.phase==='main'?'<button class="btn-retreat" onclick="csRetreat()">â†© Retreat</button>':'')+
    '</div>';

    document.getElementById('combat-body').innerHTML=
        sidesHTML+explainHTML+logHTML+attSection+defSection+btnsHTML;
}

function csAdjHits(v){
    const phase=CS.phase;
    const isAtt=CS.humanAtt;
    const u=isAtt?CS.attUnits:CS.defUnits;
    const maxDice=csDice(u,phase);
    CS.humanHits=Math.max(0,Math.min(maxDice,CS.humanHits+v));
    CS.humanReady=true;
    const el=document.getElementById('hs-val');
    if(el) el.textContent=CS.humanHits;
    const btn=document.getElementById('cs-apply-btn');
    if(btn){ btn.disabled=false; btn.textContent='APPLY HITS â€” '+(phase==='main'?'NEXT ROUND':'CONTINUE'); }
}

function csApply(){
    const attHits=CS.humanAtt?CS.humanHits:(CS.autoRollsAtt?CS.autoRollsAtt.filter(d=>d.hit).length:0);
    const defHits=CS.humanDef?CS.humanHits:(CS.autoRollsDef?CS.autoRollsDef.filter(d=>d.hit).length:0);
    const ba={...CS.attUnits}, bd={...CS.defUnits};

    if(CS.phase==='siege'){
        CS.defUnits=csRemove(CS.defUnits,attHits);
        const lost=csDescLost(csDiff(bd,CS.defUnits));
        CS.log.push('âš™ SIEGE: '+attHits+' hits â†’ defender loses '+lost);
        // tell player what to remove
        if(attHits>0) showCasualtyReport('Defender ('+CS.defenderColor.toUpperCase()+') removes from '+CS.toTerr+': '+lost);
        const hasArch=(CS.attUnits.A||0)>0||(CS.defUnits.A||0)>0;
        CS.phase=hasArch?'archer':'main';

    } else if(CS.phase==='archer'){
        CS.defUnits=csRemove(CS.defUnits,attHits);
        CS.attUnits=csRemove(CS.attUnits,defHits);
        const attLost=csDescLost(csDiff(ba,CS.attUnits));
        const defLost=csDescLost(csDiff(bd,CS.defUnits));
        CS.log.push('ðŸ¹ ARCHERS: Att '+attHits+'h â†’ Def loses '+defLost+' | Def '+defHits+'h â†’ Att loses '+attLost);
        const msgs=[];
        if(attHits>0) msgs.push('Defender ('+CS.defenderColor.toUpperCase()+') removes '+defLost+' from '+CS.toTerr);
        if(defHits>0) msgs.push('Attacker ('+CS.attackerColor.toUpperCase()+') removes '+attLost+' from '+CS.fromTerr);
        if(msgs.length) showCasualtyReport(msgs.join('<br>'));
        CS.phase='main';

    } else if(CS.phase==='main'){
        CS.defUnits=csRemove(CS.defUnits,attHits);
        CS.attUnits=csRemove(CS.attUnits,defHits);
        const attLost=csDescLost(csDiff(ba,CS.attUnits));
        const defLost=csDescLost(csDiff(bd,CS.defUnits));
        const rndNum=CS.log.filter(l=>l.startsWith('âš”')).length+1;
        CS.log.push('âš” R'+rndNum+': Att '+attHits+'h â†’ Def loses '+defLost+' | Def '+defHits+'h â†’ Att loses '+attLost);
        const msgs=[];
        if(attHits>0) msgs.push('<b>Remove from '+CS.toTerr+':</b> '+defLost);
        if(defHits>0) msgs.push('<b>Remove from '+CS.fromTerr+':</b> '+attLost);
        if(msgs.length) showCasualtyReport(msgs.join('<br>'));
    }

    CS.humanHits=0; CS.humanReady=false;
    const attAlive=csTotal(CS.attUnits)>0, defAlive=csTotal(CS.defUnits)>0;
    if(!attAlive||!defAlive) CS.phase='result';
    preparePhase();
    renderCombatUI();
}

function showCasualtyReport(msg){
    // Prepend a casualty instruction box â€” called before renderCombatUI overwrites body
    // Store for rendering
    CS._casualtyMsg=msg;
}

function csRetreat(){
    if(!confirm('Retreat '+CS.attackerColor.toUpperCase()+' back to '+CS.fromTerr+'?')) return;
    CS.retreated=true;
    CS.log.push('â†© Attacker retreats to '+CS.fromTerr);
    CS.phase='result';
    renderCombatUI();
}

function renderResult(){
    const attAlive=csTotal(CS.attUnits)>0, defAlive=csTotal(CS.defUnits)>0;
    const won=attAlive&&!defAlive&&!CS.retreated;
    const held=CS.retreated||(!attAlive&&defAlive);

    let msg='', cls='';
    if(CS.retreated){
        msg='â†© '+CS.attackerColor.toUpperCase()+' retreats. '+CS.defenderColor.toUpperCase()+' holds '+CS.toTerr+'.';
        cls='draw';
    } else if(won){
        msg='âœ“ '+CS.attackerColor.toUpperCase()+' captures '+CS.toTerr+'! ('+csStr(CS.attUnits)+' remain)';
        cls='win';
    } else {
        msg='âœ— Attacker eliminated. '+CS.defenderColor.toUpperCase()+' holds '+CS.toTerr+' ('+csStr(CS.defUnits)+' remain)';
        cls='loss';
    }

    csFinalize(won, CS.attUnits, CS.defUnits);

    document.getElementById('combat-phase-label').textContent='RESULT';
    document.getElementById('combat-body').innerHTML=
        '<div class="result-banner '+cls+'">'+msg+'</div>'+
        '<div class="round-log" style="max-height:200px;">'+
            CS.log.map(l=>'<div class="round-log-entry">'+l+'</div>').join('')+
        '</div>'+
        '<button class="btn-fight" style="margin-top:12px;" onclick="closeCombat()">âœ“ CLOSE â€” Continue Turn</button>';
}

function csFinalize(attackerWon, finalAtt, finalDef){
    const from=CS.fromTerr, to=CS.toTerr;
    if(!G.board[from]||!G.board[to]) return;

    // Normal path
    if (from !== '__editor__') {
        const leaveN = leaveBehindCount(from);
        G.board[from].units=unitsToLeave(from,leaveN);
    }
    if(attackerWon){
        G.board[to].owner=CS.attackerColor;
        G.board[to].units={F:finalAtt.F||0,A:finalAtt.A||0,C:finalAtt.C||0,S:finalAtt.S||0};
    } else {
        G.board[to].units={F:finalDef.F||0,A:finalDef.A||0,C:finalDef.C||0,S:finalDef.S||0};
        if(CS.retreated && csTotal(finalAtt)>0){
            G.board[from].units.F=(G.board[from].units.F||0)+(finalAtt.F||0);
            G.board[from].units.A=(G.board[from].units.A||0)+(finalAtt.A||0);
            G.board[from].units.C=(G.board[from].units.C||0)+(finalAtt.C||0);
            G.board[from].units.S=(G.board[from].units.S||0)+(finalAtt.S||0);
        }
    }
    for(const mv of G.pendingMoves||[]){
        if(mv&&mv.from===from&&mv.to===to) mv._applied=true;
    }
    render();
}

function closeCombat(){
    document.getElementById('combat-overlay').classList.remove('open');

    // If we came from the Combat Phase, mark battle resolved and re-render CP
    if (CP.returnToCombatPhase) {
        CP.returnToCombatPhase = false;
        const idx = CP.activeBattleIdx;
        const b = G.roundCombats[idx];
        if (b) {
            const attackerWon = csTotal(CS.attUnits) > 0 && csTotal(CS.defUnits) === 0 && !CS.retreated;
            const defHeld     = CS.retreated || csTotal(CS.defUnits) > 0;
            b._resolved = true;
            b._result   = attackerWon ? 'Attacker won' : defHeld ? 'Defender held' : 'Both eliminated';
            b._log      = CS.log.join('<br>');
            // Award crowns + shield if attacker captured a city
            if (attackerWon) {
                const defColor = G.board[b.to]?.owner; // already updated by csFinalize
                const cv = crownValueOfCity(b.to);
                if (cv > 0) {
                    if (!G.crowns) G.crowns = {};
                    G.crowns[b.color] = (G.crowns[b.color]||0) + cv;
                    addLog(`${cName(b.color)} captures ${b.to}. +${cv} Crown${cv>1?'s':''}! (${G.crowns[b.color]} total)`);
                    checkWin(b.color);
                }
                if (CITY_SHIELDS[b.to]) {
                    if (!G.shields) G.shields = {};
                    G.shields[b.to] = b.color;
                    addLog('ðŸ›¡ ' + cName(b.color) + ' gains the ' + b.to + ' shield.');
                    showShieldReminder(b.to, b.color);
                }
                showShieldReminder('Stockholm', b.color);
                applyShieldBonus('Stockholm', b.color, 'battle_win');
            }
        }
        CP.idx = (idx || 0) + 1;
        csReset();
        renderCombatPhase();
        return;
    }

    // Normal in-turn combat close
    let stepIdx = CS.pendingStepIdx;
    if (stepIdx < 0) stepIdx = findStepIdxContaining('START COMBAT');
    if (stepIdx >= 0) G.checkedSteps.add(stepIdx);
    const total = G.currentSteps.filter(s=>s!==null).length;
    const _cb2 = document.getElementById('complete-btn');
    if(_cb2) _cb2.disabled = (G.checkedSteps.size < total);
    renderSteps();
    csReset();
    render();
}


// ================================================================
// HUMAN TURN
// ================================================================
const HUMAN_STEPS = [
    { id:'card',   text:'<b>Flip your pre-set Order Card face-up</b> and resolve it. You must play your cards in the order you placed them face-down at the start of this round.' },
    { id:'move',   text:'<b>Move your units</b> according to your card. Leave-behind: <b>non-urban = 1 unit, city = its Tax value in units</b>. <b>MANEUVER</b>: up to 2 territories away through your own territories to an owned or disputed territory. Cannot maneuver out of a disputed territory.' },
    { id:'board',  text:'<b>Update the board state</b> â€” open the editor and record territory changes. If you made no moves this action, tap to skip.' },
    { id:'crowns', text:'<b>Collect Tax / claim Crowns</b> if applicable. Use the coin [+] / [âˆ’] buttons in the player bar to adjust your total.' },
];

function renderHumanTurn() {
    const el = document.getElementById('human-view');
    if (!el) return;

    const checks = G.humanTurnChecks || new Set();
    const boardDone = G.humanBoardUpdated || false;
    const allChecked = checks.size >= HUMAN_STEPS.length;
    const stepsHTML = HUMAN_STEPS.map((s, i) => {
        const done = checks.has(i);
        if (s.id === 'board') {
            const btnCls = boardDone ? 'ht-open-board done-board' : 'ht-open-board';
            const btnTxt = boardDone ? 'âœ“ Board State Updated' : 'ðŸ—º Open Board Editor to Update State';
            return `<div class="ht-step ${done?'done':''}" onclick="htToggle(${i})">
                <div class="ht-cb">${done?'âœ“':''}</div>
                <div class="ht-text">
                    ${s.text}
                    <button class="${btnCls}" onclick="event.stopPropagation();htOpenBoard(${i})">${btnTxt}</button>
                    ${!done ? `<button style="margin-top:6px;background:none;border:1px solid #ccc;border-radius:5px;padding:5px 12px;font-size:0.8em;color:var(--ink-light);cursor:pointer;width:100%"
                        onclick="event.stopPropagation();htToggle(${i})">No moves this action â€” skip â€º</button>` : ''}
                </div>
            </div>`;
        }
        return `<div class="ht-step ${done?'done':''}" onclick="htToggle(${i})">
            <div class="ht-cb">${done?'âœ“':''}</div>
            <div class="ht-text">${s.text}</div>
        </div>`;
    }).join('');

    const pct = Math.round((checks.size / HUMAN_STEPS.length) * 100);

    const pColor = S.playerColor || 'blue';
    const pHex   = COLOR_HEX[pColor] || '#5bb8f5';
    const lightC = ['blue','green','orange'].includes(pColor);
    // Set CSS custom property so all .ht-* rules pick up the right color
    document.documentElement.style.setProperty('--player-color', pHex);
    el.innerHTML = `
        <div class="human-banner" style="margin-bottom:0;border-bottom:none;border-radius:8px 8px 0 0;border-color:${pHex};">
            <h2 style="color:${pHex};">âš” YOUR TURN â€” ACTION ${G.step} of 2</h2>
            <p>Tap each step as you do it. Update the board state so automatons plan correctly.</p>
        </div>
        <div class="steps-panel" style="margin-bottom:12px;border-radius:0 0 8px 8px;">
            <div class="steps-header" style="background:${pHex};color:${lightC?'#000':'#fff'}">YOUR ACTION CHECKLIST</div>
            <div class="ht-progress"><div class="ht-progress-fill" style="width:${pct}%;background:${pHex}"></div></div>
            <div class="human-turn-steps">${stepsHTML}</div>
        </div>`;

    // Unlock Complete Turn only when all steps checked
    const btn = document.getElementById('complete-btn');
    if (btn) btn.disabled = !allChecked;
}

function htToggle(i) {
    if (!G.humanTurnChecks) G.humanTurnChecks = new Set();
    if (G.humanTurnChecks.has(i)) G.humanTurnChecks.delete(i);
    else G.humanTurnChecks.add(i);
    renderHumanTurn();
}

function htOpenBoard(stepIdx) {
    G._htBoardStep = stepIdx;
    openBoardEditor(); // defaults to current active player's color
}

// Override closeBoardEditor to auto-check the board step if opened from human turn
const _origCloseBoardEditor = closeBoardEditor;
closeBoardEditor = function() {
    _origCloseBoardEditor();
    const isHumanTurn = activeColor() === S.playerColor;
    if (isHumanTurn && G._htBoardStep !== undefined) {
        G.humanBoardUpdated = true;
        G.humanTurnChecks = G.humanTurnChecks || new Set();
        G.humanTurnChecks.add(G._htBoardStep);
        G._htBoardStep = undefined;
        renderHumanTurn();
    }
};


// Show "Stuck? Force advance" hint after Complete Turn is disabled for 8 seconds
let _stuckTimer = null;
function resetStuckTimer() {
    clearTimeout(_stuckTimer);
    const hint = () => document.getElementById('stuck-hint');
    if (hint()) hint().style.display = 'none';
    const btn = document.getElementById('complete-btn');
    if (btn && btn.disabled) {
        _stuckTimer = setTimeout(() => {
            const b = document.getElementById('complete-btn');
            const h = document.getElementById('stuck-hint');
            if (b && b.disabled && h) h.style.display = 'block';
        }, 8000);
    }
}
function forceAdvance() {
    if (!confirm('Force advance to next turn?\n\nThis skips any remaining steps. Use only if you are stuck.')) return;
    const h = document.getElementById('stuck-hint');
    if (h) h.style.display = 'none';
    advanceTurn();
}


// ================================================================
// TERRITORY EDIT MODAL
// ================================================================
// TE = Territory Edit state
// TE.name        â€” territory being edited
// TE.attColor    â€” a second (attacking) color the user is setting up, or null
// TE.attUnits    â€” that attacker's units {F,A,C,S} â€” lives only in TE, NOT on G.board
let TE = { name:null, attColor:null, attUnits:{F:0,A:0,C:0,S:0} };

function openTerrEdit(name) {
    if (!G.board[name]) return;
    TE = { name, attColor:null, attUnits:{F:0,A:0,C:0,S:0} };
    document.getElementById('terr-edit-overlay').classList.add('open');
    renderTerrEdit();
}

function closeTerrEdit() {
    // If a second (attacking) army was set up, queue it as a pending battle
    if (TE.attColor && unitTotal(TE.attUnits) > 0) {
        if (!G.roundCombats) G.roundCombats = [];
        // Remove any previous editor-queued battle for the same territory + attacker
        G.roundCombats = G.roundCombats.filter(
            b => !(b._fromEditor && b.to === TE.name && b.color === TE.attColor)
        );
        G.roundCombats.push({
            color:       TE.attColor,
            from:        '__editor__',   // sentinel: no origin territory
            to:          TE.name,
            movingUnits: { ...TE.attUnits },
            movable:     unitTotal(TE.attUnits),
            isEnemy:     true,
            _fromEditor: true
        });
        addLog(`âš” Battle queued: ${cAttacks(TE.attColor)} ${TE.name} (${G.board[TE.name]?.owner}) â€” resolve in Combat Phase.`);
    }
    document.getElementById('terr-edit-overlay').classList.remove('open');
    TE = { name:null, attColor:null, attUnits:{F:0,A:0,C:0,S:0} };
    renderBEFull(G.board);
}

function renderTerrEdit() {
    const name = TE.name;
    const b = G.board[name];
    if (!b) return;

    const tax = T[name]?.tax > 0 ? `Tax ${T[name].tax} city` : 'Non-urban territory';
    document.getElementById('terr-edit-title').textContent = name;

    const defColor  = b.owner;
    const hasAtt    = !!TE.attColor;

    // â”€â”€ Color selector â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Clicking the defender's color = remove attacker (back to single-army view)
    // Clicking a different color    = set as attacker
    // Clicking Neutral              = clear the territory
    const allColors = ['orange','green','purple','blue','neutral'];
    const ownerBtns = allColors.map(c => {
        const bg  = COLOR_HEX[c] || '#aaa';
        const txt = ['orange','green','blue'].includes(c) ? '#000' : '#fff';
        // Highlight: defender color highlighted if no attacker, attacker color if attacker set
        const isSel = hasAtt ? (c === TE.attColor) : (c === defColor);
        const sel = isSel ? 'sel' : '';
        const label = c === 'neutral' ? 'Neutral'
            : c.charAt(0).toUpperCase()+c.slice(1) + (c===S.playerColor?' (You)':'');
        return `<button class="te-owner-btn ${sel}" style="background:${bg};color:${txt}"
            onclick="teSetOwner('${c}')">${label}</button>`;
    }).join('');

    // â”€â”€ Unit rows helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const unitDefs = [
        { k:'F', label:'Footman',      sub:'1 die' },
        { k:'A', label:'Archer',       sub:'1 die' },
        { k:'C', label:'Cavalry',      sub:'2 dice' },
        { k:'S', label:'Siege Engine', sub:'Pre-battle' },
    ];
    function makeUnitRows(units, idPrefix, onAdj) {
        return unitDefs.map(({k, label, sub}) => {
            const v = units[k] || 0;
            return `<div class="te-unit-row">
                <div><div class="te-unit-label">${label}</div><div class="te-unit-sub">${sub}</div></div>
                <div class="te-stepper">
                    <button class="te-btn" onclick="${onAdj}('${k}',-1)">âˆ’</button>
                    <span class="te-val" id="${idPrefix}${k}">${v}</span>
                    <button class="te-btn" onclick="${onAdj}('${k}',1)">+</button>
                </div>
            </div>`;
        }).join('');
    }

    // â”€â”€ Defender panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const defHex   = COLOR_HEX[defColor] || '#aaa';
    const defLight = ['orange','green','blue'].includes(defColor);
    const defTxt   = defLight ? '#000' : '#fff';
    const defTotal = unitTotal(b.units);
    const defPanel = `
        <div class="te-section" style="border:2px solid ${defHex};border-radius:7px;margin-bottom:10px;">
            <div style="background:${defHex};color:${defTxt};padding:5px 10px;border-radius:5px 5px 0 0;
                font-family:Cinzel,serif;font-size:0.82em;font-weight:700;margin-bottom:6px;">
                ${hasAtt ? 'DEFENDER â€” ' : ''}${defColor.toUpperCase()}${defColor===S.playerColor?' (YOU)':''}&nbsp;
                <span style="font-weight:400">(${defTotal} units)</span>
            </div>
            <div style="padding:0 4px;">${makeUnitRows(b.units,'te-def-','teAdjDef')}</div>
        </div>`;

    // â”€â”€ Attacker panel (only when a second color is selected) â”€â”€â”€â”€â”€â”€â”€
    let attPanel = '';
    if (hasAtt) {
        const attHex   = COLOR_HEX[TE.attColor] || '#aaa';
        const attLight = ['orange','green','blue'].includes(TE.attColor);
        const attTxt   = attLight ? '#000' : '#fff';
        const attTotal = unitTotal(TE.attUnits);
        attPanel = `
        <div class="te-section" style="border:2px solid ${attHex};border-radius:7px;margin-bottom:10px;">
            <div style="background:${attHex};color:${attTxt};padding:5px 10px;border-radius:5px 5px 0 0;
                font-family:Cinzel,serif;font-size:0.82em;font-weight:700;margin-bottom:6px;">
                ATTACKER â€” ${TE.attColor.toUpperCase()}${TE.attColor===S.playerColor?' (YOU)':''}
                &nbsp;<span style="font-weight:400" id="te-att-total">(${attTotal} units)</span>
            </div>
            <div style="padding:0 4px;">${makeUnitRows(TE.attUnits,'te-att-','teAdjAtt')}</div>
        </div>
        <div style="font-size:0.78em;color:var(--ink-light);margin-bottom:8px;padding:0 2px;">
            âš” Battle will be queued for the Combat Phase when you save.
        </div>`;
    }

    // â”€â”€ Castle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const castleCls = b.castle ? 'te-castle-toggle on' : 'te-castle-toggle';
    const castleLbl = b.castle ? 'ðŸ° Remove Castle' : '+ Add Castle';
    const castleNote = T[name]?.tax > 0 ? '' : '<div style="font-size:0.75em;color:var(--ink-light);margin-top:4px;">Note: only cities normally have castles.</div>';

    document.getElementById('terr-edit-body').innerHTML = `
        <div class="te-section">
            <div class="te-label">Territory: <b>${name}</b> &nbsp;<span style="font-size:0.8em;color:var(--ink-light);">${tax}</span></div>
        </div>
        <div class="te-section">
            <div class="te-label">${hasAtt ? 'Click a colour to set attacker / defender' : 'Owner â€” click another colour to add an attacker'}</div>
            <div class="te-owner-row">${ownerBtns}</div>
        </div>
        ${defPanel}
        ${attPanel}
        <div class="te-section">
            <div class="te-castle-row">
                <div class="te-castle-label">${b.castle ? 'ðŸ° Castle present' : 'No castle'}</div>
                <button class="${castleCls}" id="te-castle-btn" onclick="teToggleCastle()">${castleLbl}</button>
            </div>
            ${castleNote}
        </div>
        <button class="te-save-btn" onclick="closeTerrEdit()">
            ${hasAtt && unitTotal(TE.attUnits)>0 ? 'âš” Save & Queue Battle' : 'âœ“ Done â€” Save Changes'}
        </button>
    `;
}

// â”€â”€ teSetOwner: manage which color is the "attacker" slot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function teSetOwner(color) {
    const b = G.board[TE.name];
    if (!b) return;

    if (color === 'neutral') {
        // Clear to neutral: wipe units, remove any pending attacker
        b.owner = 'neutral';
        b.units = {F:0,A:0,C:0,S:0};
        TE.attColor = null;
        TE.attUnits = {F:0,A:0,C:0,S:0};
        if (CITY_SHIELDS[TE.name]) { if (G.shields) delete G.shields[TE.name]; }
    } else if (color === b.owner) {
        // Clicking the current defender color = remove attacker
        TE.attColor = null;
        TE.attUnits = {F:0,A:0,C:0,S:0};
    } else {
        // Different color = set as attacker (preserve units if same attacker re-selected)
        if (TE.attColor !== color) {
            TE.attColor = color;
            TE.attUnits = {F:0,A:0,C:0,S:0};  // always reset to 0 when switching attacker
        }
    }
    renderTerrEdit();
}

// â”€â”€ Adjust DEFENDER units â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function teAdjDef(k, v) {
    if (!G.board[TE.name]) return;
    G.board[TE.name].units[k] = Math.max(0, (G.board[TE.name].units[k]||0) + v);
    const el = document.getElementById('te-def-'+k);
    if (el) el.textContent = G.board[TE.name].units[k];
}

// â”€â”€ Adjust ATTACKER units (stored only in TE, not on G.board) â”€â”€â”€â”€â”€
function teAdjAtt(k, v) {
    if (!TE.attColor) return;
    TE.attUnits[k] = Math.max(0, (TE.attUnits[k]||0) + v);
    const el = document.getElementById('te-att-'+k);
    if (el) el.textContent = TE.attUnits[k];
    const tot = document.getElementById('te-att-total');
    if (tot) tot.textContent = '('+unitTotal(TE.attUnits)+' units)';
    // Refresh save button label
    const btn = document.querySelector('.te-save-btn');
    if (btn) btn.textContent = unitTotal(TE.attUnits)>0 ? 'âš” Save & Queue Battle' : 'âœ“ Done â€” Save Changes';
}

// legacy alias kept so any leftover onclick="teAdjUnit(...)" still works
function teAdjUnit(k, v) { teAdjDef(k, v); }

function teToggleCastle() {
    if (!G.board[TE.name]) return;
    G.board[TE.name].castle = !G.board[TE.name].castle;
    renderTerrEdit();
}


// ================================================================
// COMBAT PHASE â€” runs after all players finish Action 2
// ================================================================
let CP = { idx:0, humanBattle:null, humanPhase:null, humanRounds:[] };

function openCombatPhase(roundNum) {
    CP = { idx:0, humanBattle:null, humanPhase:null, humanRounds:[] };
    document.getElementById('cp-round').textContent = roundNum || G.round;
    document.getElementById('cp-overlay').classList.add('open');
    renderCombatPhase();
}

function closeCombatPhase() {
    document.getElementById('cp-overlay').classList.remove('open');
    G.roundCombats = [];
    // Check for player elimination before starting next round
    checkElimination();
    // G.round was already incremented in advanceTurn before openCombatPhase was called
    if (!G.winner) prepareRound(false);
    render();
}

function renderCombatPhase() {
    const battles = G.roundCombats || [];
    const body = document.getElementById('cp-body');

    // Build battle cards (all of them, resolved ones dimmed)
    const cards = battles.map((b, i) => {
        const resolved = b._resolved;
        const isActive = i === CP.idx && !resolved;
        const attColor = b.color || 'neutral';
        const defColor = G.board[b.to]?.owner || 'neutral';
        const attUnits = totalUnitCount(G.board[b.from]?.units || {});
        const defUnits = totalUnitCount(G.board[b.to]?.units || {});
        const humanInvolved = b.color === S.playerColor || defColor === S.playerColor;
        const badge = resolved
            ? `<span class="cp-battle-badge done">âœ“ ${b._result || 'Resolved'}</span>`
            : humanInvolved
                ? `<span class="cp-battle-badge pending">YOUR BATTLE</span>`
                : `<span class="cp-battle-badge auto">Auto-resolve</span>`;

        let detail = '';
        if (resolved) {
            detail = `<div class="cp-auto-log">${b._log || ''}</div>`;
        } else if (isActive) {
            detail = humanInvolved
                ? renderCPHumanBattle(b, i)
                : renderCPAutoBattle(b, i);
        }

        return `<div class="cp-battle ${resolved?'resolved':''} ${isActive?'active':''}" id="cp-battle-${i}">
            <div class="cp-battle-hdr">
                <div>
                    <div class="cp-battle-title">${b.from === '__editor__' ? cAttacks(b.color) : b.from+' â†’'} ${b.to}</div>
                    <div class="cp-battle-sub">${cAttacks(b.color)} ${cName(defColor)}${b._fromEditor?' <span style="font-size:0.8em;opacity:0.6;">(manually queued)</span>':''}</div>
                </div>
                ${badge}
            </div>
            ${detail}
        </div>`;
    }).join('');

    // End button â€” only enabled when all resolved
    const allDone = battles.every(b => b._resolved);
    body.innerHTML = cards +
        `<button class="cp-end-btn" onclick="closeCombatPhase()" ${allDone?'':'disabled'}>
            ${allDone ? 'âœ“ End Combat Phase â€” Begin Next Round' : `Resolve battle ${CP.idx+1} of ${battles.length} to continue`}
        </button>`;
}

// â”€â”€ Auto-resolve a battle and render the log â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderCPAutoBattle(b, idx) {
    // Run full auto-combat immediately and store result
    const result = resolveAutoBattle(b);
    G.roundCombats[idx]._resolved = true;
    G.roundCombats[idx]._result = result.winner === b.color ? 'Attacker won' : result.winner === 'defender' ? 'Defender held' : 'Draw';
    G.roundCombats[idx]._log = result.log;
    applyBattleResult(b, result);

    // Move to next battle
    CP.idx = idx + 1;
    // Re-render after short delay so player sees the resolution
    setTimeout(renderCombatPhase, 400);
    return `<div class="cp-auto-log">âš™ Resolvingâ€¦</div>`;
}

// â”€â”€ Human battle UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderCPHumanBattle(b, idx) {
    const defColor = G.board[b.to]?.owner || 'neutral';
    // For __editor__ battles the attacker has no origin territory â€” use stored movingUnits
    const attUnits = b._fromEditor ? (b.movingUnits||{}) : (G.board[b.from]?.units || {});
    const defUnits = G.board[b.to]?.units || {};
    const attHex = COLOR_HEX[b.color] || '#888';
    const defHex = COLOR_HEX[defColor] || '#888';
    const attLight = ['orange','green','blue'].includes(b.color);
    const defLight = ['orange','green','blue'].includes(defColor);

    // Use the existing full combat modal for human battles
    return `<div class="cp-human-panel">
        <div class="cp-sides">
            <div class="cp-side" style="background:${attHex};color:${attLight?'#000':'#fff'}">
                <div class="cps-label">ATTACKER</div>
                <div class="cps-name">${b.from}</div>
                <div class="cps-units">${unitStr(attUnits)}</div>
            </div>
            <div class="cp-vs">VS</div>
            <div class="cp-side" style="background:${defHex};color:${defLight?'#000':'#fff'}">
                <div class="cps-label">DEFENDER</div>
                <div class="cps-name">${b.to}</div>
                <div class="cps-units">${unitStr(defUnits)}</div>
            </div>
        </div>
        <button class="cp-next-btn" onclick="launchCPHumanCombat(${idx})">âš” Start Combat â€” Roll Dice</button>
    </div>`;
}

function launchCPHumanCombat(idx) {
    const b = G.roundCombats[idx];
    const defColor = G.board[b.to]?.owner || 'neutral';
    CP.activeBattleIdx = idx;
    openCombat(b.color, defColor, b.from, b.to, -1);
    // Override closeCombat to return to CP phase
    CP.returnToCombatPhase = true;
}

// â”€â”€ Resolve automaton battle with dice â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resolveAutoBattle(b) {
    // Use only the units that were designated to move, not ALL units at origin
    // (leave-behind units stay in the territory and don't fight)
    const att = b.movingUnits || G.board[b.from]?.units || {};
    const def = G.board[b.to]?.units || {};
    const log = [];

    let aUnits = { ...att };
    let dUnits = { ...def };

    function rollHits(dice, threshold=4) {
        let hits = 0;
        for(let i=0;i<dice;i++) if(Math.ceil(Math.random()*6)>=threshold) hits++;
        return hits;
    }
    function total(u) { return (u.F||0)+(u.A||0)+(u.C||0)+(u.S||0); }
    function removeCasualties(u, n) {
        let rem = n;
        // Remove weakest first: F â†’ A â†’ C â†’ S
        for (const k of ['F','A','C','S']) {
            const take = Math.min(u[k]||0, rem);
            u[k] = (u[k]||0) - take; rem -= take;
            if (rem <= 0) break;
        }
    }

    // Siege pre-battle: only the ATTACKER's siege engines fire, and only if the
    // target has a castle. Defender siege engines do NOT get a pre-battle shot.
    const aSiege = aUnits.S||0;
    const targetHasCastle = G.board[b.to]?.castle || false;
    if (aSiege > 0 && targetHasCastle) {
        const hits = rollHits(aSiege*2, 4);
        removeCasualties(dUnits, hits);
        log.push(`Siege pre-fire: ${aSiege} siege engine(s) vs castle â†’ ${hits} hits on defender.`);
    } else if (aSiege > 0) {
        log.push(`Siege engines present but no castle at ${b.to} â€” no pre-battle fire.`);
    }
    // Archer volley
    const aArch = aUnits.A||0, dArch = dUnits.A||0;
    if (aArch+dArch > 0) {
        const aHits = rollHits(aArch, 4), dHits = rollHits(dArch, 4);
        removeCasualties(dUnits, aHits);
        removeCasualties(aUnits, dHits);
        log.push(`Archers: att ${aArch} archers â†’ ${aHits} hits; def ${dArch} archers â†’ ${dHits} hits.`);
    }

    // Main combat rounds
    let rounds = 0;
    while (total(aUnits) > 0 && total(dUnits) > 0 && rounds < 10) {
        rounds++;
        // Cavalry: 2 dice; Footmen, Archers, Siege Engines: 1 die each
        const aDice = (aUnits.C||0)*2 + (aUnits.F||0) + (aUnits.A||0) + (aUnits.S||0);
        const dDice = (dUnits.C||0)*2 + (dUnits.F||0) + (dUnits.A||0) + (dUnits.S||0);
        const aHits = rollHits(aDice), dHits = rollHits(dDice);
        removeCasualties(dUnits, aHits);
        removeCasualties(aUnits, dHits);
        log.push(`Round ${rounds}: att ${aDice}dâ†’${aHits} hits; def ${dDice}dâ†’${dHits} hits.`);
    }

    const attSurv = total(aUnits), defSurv = total(dUnits);
    const winner = attSurv > 0 && defSurv === 0 ? b.color : attSurv === 0 ? 'defender' : 'draw';
    log.push(winner === b.color ? `âœ“ Attacker captures ${b.to}! (${attSurv} survivors)` :
             winner === 'defender' ? `âœ— Defender holds ${b.to}! (${defSurv} survivors)` :
             `âš¡ Both sides eliminated.`);
    return { winner, attSurv, defSurv, attUnits: aUnits, defUnits: dUnits, log: log.join('<br>') };
}

function applyBattleResult(b, result) {
    const defColor = G.board[b.to]?.owner || 'neutral';
    if (result.winner === b.color) {
        // Attacker wins â€” move survivors to captured territory
        // __editor__ battles have no origin territory to update
        if (b.from !== '__editor__') {
            G.board[b.from].units = Object.fromEntries(
                Object.entries(G.board[b.from].units).map(([k,v])=>[k, Math.max(0, v-(b.movingUnits?.[k]||0))])
            );
        }
        G.board[b.to].owner = b.color;
        G.board[b.to].units = result.attUnits;
        // Award crowns for capturing a city
        const cv = crownValueOfCity(b.to);
        if (cv > 0) {
            if (!G.crowns) G.crowns = {};
            G.crowns[b.color] = (G.crowns[b.color]||0) + cv;
            addLog(`${cName(b.color)} captures ${b.to} from ${cName(defColor)}. +${cv} Crown${cv>1?'s':''}! (now ${G.crowns[b.color]} total)`);
            checkWin(b.color);
        } else {
            addLog(`${cName(b.color)} captures ${b.to} from ${cName(defColor)}.`);
        }
        // Assign shield token and fire reminder
        if (CITY_SHIELDS[b.to]) {
            if (!G.shields) G.shields = {};
            G.shields[b.to] = b.color;
            addLog('ðŸ›¡ ' + cName(b.color) + ' gains the ' + b.to + ' shield.');
            showShieldReminder(b.to, b.color);
        }
        // Stockholm shield
        showShieldReminder('Stockholm', b.color);   // toast for human
        applyShieldBonus('Stockholm', b.color, 'battle_win');  // auto-apply for automa
    } else if (result.winner === 'defender') {
        // Defender holds â€” attacking units destroyed
        if (b.from !== '__editor__') {
            ['F','A','C','S'].forEach(k => {
                G.board[b.from].units[k] = Math.max(0, (G.board[b.from].units[k]||0) - (b.movingUnits?.[k]||0));
            });
        }
        addLog(`${cName(defColor)} holds ${b.to} against ${cName(b.color)}.`);
    } else {
        // Both wiped â€” territory goes neutral
        G.board[b.to].units = {F:0,A:0,C:0,S:0};
        G.board[b.to].owner = 'neutral';
        if (b.from !== '__editor__') {
            ['F','A','C','S'].forEach(k => {
                G.board[b.from].units[k] = Math.max(0, (G.board[b.from].units[k]||0) - (b.movingUnits?.[k]||0));
            });
        }
        addLog(`${b.to}: both sides eliminated â€” territory neutral.`);
    }
}


// ================================================================
// INIT
// ================================================================
showStep(0);
</script>

<!-- BOARD EDITOR OVERLAY -->
<button class="board-btn" onclick="openBoardEditor()" id="board-btn" style="display:none">
    ðŸ—º Board State
</button>
<div class="board-overlay" id="board-overlay">
  <div class="board-modal">
    <div class="board-modal-header">
      <span id="board-modal-title">Board State</span>
      <button class="board-close" onclick="closeBoardEditor()">âœ•</button>
    </div>
    <div class="board-content" id="board-content"></div>
  </div>
</div>


<!-- COMBAT MODAL -->
<div class="combat-overlay" id="combat-overlay">
  <div class="combat-modal">
    <div class="combat-header">
      <span id="combat-title">COMBAT</span>
      <span class="combat-phase-badge" id="combat-phase-label">SETUP</span>
    </div>
    <div class="combat-body" id="combat-body">
      <!-- rendered by JS -->
    </div>
  </div>
</div>



<!-- Territory Edit Modal -->
<div class="terr-edit-overlay" id="terr-edit-overlay">
  <div class="terr-edit-modal">
    <div class="terr-edit-hdr">
      <span id="terr-edit-title">Edit Territory</span>
      <button class="terr-edit-close" onclick="closeTerrEdit()">âœ•</button>
    </div>
    <div class="terr-edit-body" id="terr-edit-body"></div>
  </div>
</div>


<!-- COMBAT PHASE OVERLAY -->
<div class="cp-overlay" id="cp-overlay">
  <div class="cp-modal">
    <div class="cp-header">âš” COMBAT PHASE â€” ROUND <span id="cp-round">1</span></div>
    <div class="cp-subhdr">All battles from this round are resolved now, in order.</div>
    <div class="cp-body" id="cp-body"></div>
  </div>
</div>

</body>
</html>
